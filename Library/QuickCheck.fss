(*******************************************************************************
    Copyright 2011 Kang Seonghoon, KAIST
    All rights reserved.
 ******************************************************************************)

component QuickCheck

export QuickCheck
import List.{...}
import Set.{...}
import Map.{...}
import QuickSort.{...}
import Random.{...}

(** A test context. **)
object TestContext(arbitrary:Arbitrary, g:AnySeededRandomGen,
                   numTests:ZZ32, maxTests:ZZ32, size:ZZ32)
    (** Zero `size` means the generator should avoid recursion from now on. **)
    getter leaf(): Boolean = (size <= 0)

    (* XXX for now we assume that every RandomGen instances are of this type.
       there are several reasons for this; for example `Random.UniformDistribution`
       cannot generate the full range of ZZ64 yet. *)
    private getter g'(): SeededRandomGen[\ZZ64,ZZ64\] =
        g typed SeededRandomGen[\ZZ64,ZZ64\]

    (** Generates a test generator of given type, using specified `Arbitrary`
        factory. **)
    gen[\P\](): Gen[\P\] = arbitrary.gen[\P\]()

    (** Returns a copy of `TestContext` which is resized. **)
    resized(newsize:ZZ32): TestContext =
        TestContext(arbitrary, g, numTests, maxTests, newsize)

    (** Returns a copy of `TestContext` which random number generator is
        replaced to given one. **)
    withRandomGen(g':AnySeededRandomGen): TestContext =
        TestContext(arbitrary, g', numTests, maxTests, size)

    (** Generates a `ZZ32` value uniformly from the current random number
        generator. It is most suitable for the implementation of `Gen[\ZZ32\]`. **)
    random(): ZZ32 =
        narrow((self.g'.random() BITAND 4294967295 (* 2^32-1 *)) - 2147483648 (* 2^31 *))
    (** Generates a random number from `0` to `n-1` (inclusive) uniformly. **)
    random(n:ZZ32): ZZ32 = self.g'.randomR(0#n)
    (** Generates a random number from `lo` to `hi-1` (inclusive) uniformly. **)
    random(lo:ZZ32, hi:ZZ32): ZZ32 = self.g'.randomR(lo:hi)

    (** Generates a random choice from given choices. **)
    oneOf[\T\](choices:Indexed[\T,ZZ32\]): T =
        choices[self.g'.randomR(choices.bounds)]

    (** Generates a `ZZ32` value which range is determined by `level`.
        It will produce small numbers and large numbers fairly uniformly. **)
    randomByLevel(level:ZZ32): ZZ32 =
        case level of
            0 => (random() BITAND 255) - 128
            1 => (random() BITAND 65535) - 32768
            2 => (random() BITAND 16777215) - 8388608
            3 => random()
        end
end

(** Generates a random test context from a given random number generator.
    See also `genTestContext`. **)
TestContext(arb:Arbitrary, g:AnySeededRandomGen): TestContext =
    genTestContext.generate(TestContext(arb, g, 0, 0, 0))

(** Generates a random test context from a given random number generator and
    a given number of maximum tests. **)
TestContext(arb:Arbitrary, g:AnySeededRandomGen, numTests:ZZ32): TestContext = do
    c = TestContext(arb, g)
    TestContext(arb, c.g, numTests, numTests + (c.maxTests - c.numTests), c.size)
end

(**********************************************************)
(* `Gen` interface and utilities *)

(** A version of `Gen[\T\]` without static parameters. **)
trait AnyGen
    abstract generate(c:TestContext): Any
    abstract perturb(obj:Any, g:AnySeededRandomGen): AnySeededRandomGen
end

(** A test generator for type `T`. Minimal complete definition of `Gen` is
    `generate`, but one should provide `perturb` and `shrink` methods if
    applicable.

    `Gen[\T\]` is a generator for type `T`, //exactly//. Naturally if `T <: U`
    then it is appropriate that `Gen[\T\]` is usable for `U` too (as any
    instance of `T` can be used in place of instance of `U`), and this is
    supported by the fact that `Gen[\T\] <: Gen[\U\]`. The problem is, however,
    an arrow type which has a contravariant context. Assuming `P' <: P` and
    `Q <: Q'`:

    {{{
      Gen[\P->Q\]     <:     Gen[\P'->Q\]     <:    Gen[\P'->Q'\]
          ..                      ..                     ..
          \/                      \/                     \/
    genArrow[\P,Q\]   :>   genArrow[\P',Q\]   <:  genArrow[\P',Q'\]
    }}}

    What this means is `Gen[\P->Q\] :> genArrow[\P',Q\]`, which enables the use
    of an instance of `Gen[\P'->Q\]` in place of `Gen[\P->Q\]` while it is
    actually invalid. Also we may unintentionally omit the testing of some
    values, if trait `T` comprises of object `T1` and `T2` and we only have
    an instance of `Gen[\T1\]`. (In this case we should report `Gen[\T2\]` is
    missing when `Gen[\T\]` is requested.) Thus we use exact matching,
    eliminating these subtle problems. **)
trait Gen[\T\] extends AnyGen
    (** Generates an instance of `T` in the context of `c`. It should depend
        only on `c`, as the test should be deterministic. **)
    abstract generate(c:TestContext): T

    (** Perturbs a random number generator using a given `obj`. It should return
        a copy of the generator which is independent of `g`, and its return
        should depend on `obj` and `g` only. See `genArrow` test generator for
        the use of this method. **)
    perturb(obj:T, g:AnySeededRandomGen): AnySeededRandomGen = g

    (** Returns a list of objects which are similar to `obj` but also smaller.
        The default implementation is to return nothing. See `shrink` function
        for the use of this method. **)
    shrink(obj:T): Generator[\T\] = Nothing[\T\]
end

(** A default implementation of test generators for `Generator[\E\]`. **)
trait GenGenerator[\E,T extends Generator[\E\]\] extends Gen[\T\]
    (** A test generator for `E`. **)
    genE: Gen[\E\]
    (** Transforms a resulting `Generator[\E\]` back to a desired type, `T`. **)
    abstract fromGenerator(obj:Generator[\E\]): T

    generate(c:TestContext): Generator[\E\] = do
        c.random() (* Somehow permute the internal state to avoid duplicate results. *)
        fromGenerator RandomGenerator[\E\](self.genE, c.withRandomGen(c.g.perturbed(0)))
    end
    shrink(obj:T): Generator[\T\] =
        ShrinkingGenerator[\E,T\](obj, self.genE, fromGenerator)
end

(** A generator of `E` which randomly chooses whether to call itself or not.
    This is a default implementation of `generate` method for `Generator[\E\]`. **)
private object RandomGenerator[\E\](genE:Gen[\E\], c:TestContext) extends Generator[\E\]
    generate[\R\](r:Reduction[\R\], body:E->R): R = do
        c' = c.withRandomGen(c.g.perturbed(0))

        (* The algorithm is especially tuned for `Generator[\Generator[\E\]\]`,
           the most visible case of "unnatural" test data distribution.

           In detail, the procedure recursively splits given `size` into smaller
           halves, which size are chosen randomly, or generates one element of
           given size. The probability of the first case decreases as `size`
           decreases, and the probability of the second case decreases every
           recursive call (roughly) by the reduction factor, so we can expect
           the moderate number and distribution of elements. The reduction
           factor 3/4 is determined heuristically. *)

        recur(size:ZZ32, basesize:ZZ32): R =
            if size < 3 OR basesize < 2 then
                if c'.random(size+1) = 0 then
                    r.empty()
                else
                    body(genE.generate(c'.resized(size)))
                end
            else
                pivot = c'.random(1, basesize-1)
                if pivot < size then
                    basesize' = 3 (size MAX basesize) DIV 4
                    x = recur(pivot, basesize')
                    y = recur(size - pivot, basesize')
                    r.join(x, y)
                else
                    body(genE.generate(c'.resized(size)))
                end
            end

        recur(c'.size, c'.size)
    end
end

(** A generator of `T`, a subtype of `Generator[\E\]`, which returns a list of
    `g` minus one element. This is a default implementation of `shrink` method
    for `Generator[\E\]`. **)
private object ShrinkingGenerator[\E,T\](g:Generator[\E\], genE:Gen[\E\],
                                         fromGenerator:Generator[\E\]->T)
    extends Generator[\T\]

    generate[\R\](r:Reduction[\R\], body:T->R): R = do
        (* The basic idea: For every instance `obj` of `T`, we keep a list of
           `obj` minus one element and also `obj` itself. `obj` itself is
           required when we join two instances `obj1` and `obj2`. Since we want
           to return no elements when `obj` is empty, we also keep a separate
           flag to check this. *)

        body'(obj:E): (Boolean,Generator[\Generator[\E\]\],Generator[\E\]) = do
            (*) Lift shrunk objects to single-element lists (i.e. generators)
            shrunk: Generator[\Generator[\E\]\] =
                genE.shrink(obj).map[\Generator[\E\]\](Just[\E\])
            (false,
             ConcatGenerator[\Generator[\E\]\](Just[\Generator[\E\]\](Nothing[\E\]), shrunk),
             Just[\E\](obj))
        end

        (*) Generate `Generator[\Generator[\E\]\]` first.
        (_, ret, _) = g.generate[\(Boolean,Generator[\Generator[\E\]\],Generator[\E\])\](
            ConcatReduction[\E\], body')

        (*) Translate the generator of generators into `Generator[\T\]`.
        ret.generate[\R\](r, fn obj => body(fromGenerator(obj)))
    end
end

(** See `ShrinkingGenerator.generate[\E\]` for details. **)
private object ConcatReduction[\E\]
    extends Reduction[\(Boolean,Generator[\Generator[\E\]\],Generator[\E\])\]

    empty(): (Boolean,Generator[\Generator[\E\]\],Generator[\E\]) =
        (true, Nothing[\Generator[\E\]\], Nothing[\E\])

    join(x:(Boolean,Generator[\Generator[\E\]\],Generator[\E\]),
         y:(Boolean,Generator[\Generator[\E\]\],Generator[\E\])):
            (Boolean,Generator[\Generator[\E\]\],Generator[\E\]) = do
        (xempty, x0, x1) = x
        (yempty, y0, y1) = y
        if xempty then
            y
        elif yempty then
            x
        else
            (false,
             ConcatGenerator(x0.map[\Generator[\E\]\](fn i => ConcatGenerator(i, y1)),
                             y0.map[\Generator[\E\]\](fn j => ConcatGenerator(x1, j))),
             ConcatGenerator(x1, y1))
        end
    end
end

(** A concatenated generator. **)
private object ConcatGenerator[\E\](g1:Generator[\E\], g2:Generator[\E\])
    extends Generator[\E\]

    getter reverse(): Generator[\E\] =
        ConcatGenerator[\E\](g2.reverse, g1.reverse)

    generate[\R\](r:Reduction[\R\], body:E->R): R =
        r.join(g1.generate[\R\](r, body), g2.generate[\R\](r, body))

    map[\G\](f:E->G): Generator[\G\] =
        ConcatGenerator[\G\](g1.map[\G\](f), g2.map[\G\](f))
    filter(f:E->Condition[\()\]): Generator[\E\] =
        ConcatGenerator[\E\](g1.filter(f), g2.filter(f))
end

(**********************************************************)
(* `Gen` instances *)

object genVoid extends Gen[\()\]
    getter asString(): String = "genVoid"
    generate(c:TestContext): () = ()
    perturb(_:(), g:AnySeededRandomGen): AnySeededRandomGen = g.perturbed(0)
end

object genBoolean extends Gen[\Boolean\]
    getter asString(): String = "genBoolean"
    generate(c:TestContext): Boolean = (c.random(2) = 1)
    perturb(obj:Boolean, g:AnySeededRandomGen): AnySeededRandomGen =
        g.perturbed(if obj then 2 else 1 end)
end

object genZZ32 extends Gen[\ZZ32\]
    getter asString(): String = "genZZ32"
    generate(c:TestContext): ZZ32 = c.randomByLevel(c.random(4))
    perturb(obj:ZZ32, g:AnySeededRandomGen): AnySeededRandomGen = g.perturbed(obj)
end

object genZZ64 extends Gen[\ZZ64\]
    getter asString(): String = "genZZ64"

    generate(c:TestContext): ZZ64 = do
        level = c.random(8)
        case level of
            0:3 => widen(c.randomByLevel(level))
            4:7 => do
                x = widen(c.randomByLevel(level MOD 4))
                y = widen(c.random()) BITAND 4294967295 (* 2^32-1 *)
                (x LSHIFT 32) BITOR y
            end
        end
    end

    perturb(obj:ZZ64, g:AnySeededRandomGen): AnySeededRandomGen =
        g.perturbed(narrow(obj RSHIFT 32),
                    narrow((obj BITAND 4294967295 (* 2^32-1 *)) - 2147483648 (* 2^31 *)))
end

object genZZ extends Gen[\ZZ\]
    getter asString(): String = "genZZ"

    generate(c:TestContext): ZZ = do
        level = c.random(12)
        case level of
            0:3 => widen(c.randomByLevel(level))
            4:7 => do
                x = widen(c.randomByLevel(level MOD 4))
                y = widen(c.random()) BITAND 4294967295 (* 2^32-1 *)
                (x LSHIFT 32) BITOR y
            end
            else => do
                x = generate(c)
                y = widen(c.random()) BITAND 4294967295 (* 2^32-1 *)
                z = widen(c.random()) BITAND 4294967295 (* 2^32-1 *)
                (x LSHIFT 64) BITOR (y LSHIFT 32) BITOR z
            end
        end
    end

    perturb(obj:ZZ, g:AnySeededRandomGen): AnySeededRandomGen =
        if -2147483648 <= obj < 2147483648 then
            g.perturbed(0, narrow(obj))
        else
            perturb(obj LSHIFT 32,
                    g.perturbed(1, narrow((obj BITAND 4294967295 (* 2^32-1 *)) -
                                          2147483648 (* 2^31 *))))
        end
end

object genQQ extends Gen[\QQ\]
    getter asString(): String = "genQQ"

    generate(c:TestContext): QQ = do
        num = genZZ.generate(c)
        den = genZZ.generate(c)
        if den >= 0 then num / (den+1) else num / den end    (*) avoid num/0
    end

    perturb(obj:QQ, g:AnySeededRandomGen): AnySeededRandomGen = do
        num = numerator(obj)
        den = denominator(obj)
        div = num GCD den    (*) so we have unique representation for every equivalent `QQ`
        genZZ.perturb(den / div, genZZ.perturb(num / div, g))
    end
end

object genRR32 extends Gen[\RR32\]
    getter asString(): String = "genRR32"

    generate(c:TestContext): RR32 = do
        x = c.random()
        narrow(genZZ32.generate(c) (x / 4294967296.0 (* 2.0^32 *)))
    end

    perturb(obj:RR32, g:AnySeededRandomGen): AnySeededRandomGen =
        genZZ32.perturb(obj.rawBits, g)
end

object genRR32small extends Gen[\RR32\]
    getter asString(): String = "genRR32small"
    generate(c:TestContext): RR32 =
        narrow(c.random() / 2147483648.0 (* 2.0^31 *) - 0.5)
    perturb(obj:RR32, g:AnySeededRandomGen): AnySeededRandomGen =
        genZZ32.perturb(obj.rawBits, g)
end

object genRR64 extends Gen[\RR64\]
    getter asString(): String = "genRR64"

    generate(c:TestContext): RR64 = do
        x = c.random()
        y = c.random()
        genZZ64.generate(c) (x / 4294967296.0 (* 2.0^32 *) +
                             y / 18446744073709551616.0 (* 2.0^64 *))
    end

    perturb(obj:RR64, g:AnySeededRandomGen): AnySeededRandomGen =
        genZZ64.perturb(obj.rawBits, g)
end

object genRR64small extends Gen[\RR64\]
    getter asString(): String = "genRR64small"

    generate(c:TestContext): RR64 = do
        x = c.random()
        y = c.random()
        (x / 2147483648.0 (* 2.0^31 *) + y / 9223372036854775808.0 (* 2.0^63 *) - 0.5)
    end

    perturb(obj:RR64, g:AnySeededRandomGen): AnySeededRandomGen =
        genZZ64.perturb(obj.rawBits, g)
end

object genChar extends Gen[\Char\]
    getter asString(): String = "genChar"
    generate(c:TestContext): Char = char(c.random(94)+33)
    perturb(obj:Char, g:AnySeededRandomGen): AnySeededRandomGen = g.perturbed(obj.codePoint)
end

object genString extends GenGenerator[\Char,String\]
    getter asString(): String = "genString"

    genE: Gen[\Char\] = genChar
    fromGenerator(obj:Generator[\Char\]): String = BIG || obj

    perturb(obj:String, g:AnySeededRandomGen): AnySeededRandomGen =
        g.perturbed(|obj|).perturbed(obj.indices.
            map[\ZZ32\](fn i => obj[i].codePoint))
end

object genGenerator[\E\](genE:Gen[\E\]) extends GenGenerator[\E,Generator[\E\]\]
    getter asString(): String = "genGenerator(" genE ")"
    fromGenerator(obj:Generator[\E\]): Generator[\E\] = obj
end

object genMaybe[\T\](genT:Gen[\T\]) extends Gen[\Maybe[\T\]\]
    getter asString(): String = "genMaybe(" genT ")"

    generate(c:TestContext): Maybe[\T\] =
        case c.random(4) of
            0 => Nothing[\T\]
            else => Just[\T\](genT.generate(c.resized(c.size-1)))
        end

    perturb(_:Nothing[\T\], g:AnySeededRandomGen): AnySeededRandomGen =
        g.perturbed(1)
    perturb(obj:Just[\T\], g:AnySeededRandomGen): AnySeededRandomGen =
        genT.perturb(obj.get, g.perturbed(2))

    shrink(_:Nothing[\T\]): Generator[\Maybe[\T\]\] =
        Nothing[\Maybe[\T\]\]
    shrink(obj:Just[\T\]): Generator[\Maybe[\T\]\] =
        genT.shrink(obj.get).map[\Just[\T\]\](fn x => Just[\T\](x))
end

object genList[\E\](genE0:Gen[\E\]) extends GenGenerator[\E,List[\E\]\]
    getter asString(): String = "genList(" genE0 ")"

    genE: Gen[\E\] = genE0
    fromGenerator(obj:Generator[\E\]): List[\E\] = list obj

    perturb(obj:List[\E\], g:AnySeededRandomGen): AnySeededRandomGen =
        if obj.isEmpty then
            g.perturbed(1)
        else
            g': AnySeededRandomGen := g.perturbed(2)
            for i <- seq(obj) do g' := genE.perturb(i, g') end
            g'
        end
end

object genSet[\E\](genE0:Gen[\E\]) extends GenGenerator[\E,Set[\E\]\]
    getter asString(): String = "genSet(" genE0 ")"

    genE: Gen[\E\] = genE0
    fromGenerator(obj:Generator[\E\]): Set[\E\] = set obj

    perturb(obj:Set[\E\], g:AnySeededRandomGen): AnySeededRandomGen =
        if obj.isEmpty then
            g.perturbed(1)
        else
            g': AnySeededRandomGen := g.perturbed(2)
            for i <- seq(obj) do g' := genE.perturb(i, g') end
            g'
        end
end

object genMap[\K,V\](genK:Gen[\K\], genV:Gen[\V\]) extends GenGenerator[\(K,V),Map[\K,V\]\]
    getter asString(): String = "genMap(" genK "," genV ")"

    genE: Gen[\(K,V)\] = genTuple2(genK, genV)
    fromGenerator(obj:Generator[\(K,V)\]): Map[\K,V\] =
        (*) The parent generator may generate duplicate keys!
        (*)BIG UNION[(k,v) <- obj] singleton[\K,V\](k,v)
        obj.generate[\Map[\K,V\]\](
            object extends MonoidReduction[\Map[\K,V\]\]
                empty(): Map[\K,V\] = mapping[\K,V\]()
                join(a:Map[\K,V\], b:Map[\K,V\]): Map[\K,V\] = a UNION b
            end,
            singleton[\K,V\])

    perturb(obj:Map[\K,V\], g:AnySeededRandomGen): AnySeededRandomGen =
        if obj.isEmpty then
            g.perturbed(1)
        else
            g': AnySeededRandomGen := g.perturbed(2)
            for (k,v) <- seq(obj) do g' := genV.perturb(v, genK.perturb(k, g')) end
            g'
        end
end

(*) Mostly for the testing of subscripts. (XXX not tested)
object genRange[\I\](genI:Gen[\I\]) extends Gen[\Range[\I\]\]
    getter asString(): String = "genRange(" genI ")"

    generate(c:TestContext): Range[\I\] =
        case c.random(32) of
            0 => (:)
            1:2 => (:genI.generate(c))
            3:4 => (genI.generate(c):)
            else => do
                left = genI.generate(c)
                right = genI.generate(c)
                (left:right)
            end
        end

    perturb(obj:Range[\I\], g:AnySeededRandomGen): AnySeededRandomGen = do
        genMaybeI = genMaybe[\I\](genI)
        genI.generate(obj.stride,
                      genMaybeI.generate(obj.right, genMaybeI.generate(obj.left, g)))
    end
end

object genTuple2[\T1,T2\](genT1:Gen[\T1\], genT2:Gen[\T2\]) extends Gen[\(T1,T2)\]
    getter asString(): String = "genTuple2(" genT1 "," genT2 ")"

    generate(c:TestContext): (T1,T2) = do
        v1 = genT1.generate(c)
        v2 = genT2.generate(c)
        (v1, v2)
    end

    perturb(obj:(T1,T2), g:AnySeededRandomGen): AnySeededRandomGen = do
        (v1, v2) = obj
        g': AnySeededRandomGen := g.perturbed(2)
        g' := genT1.perturb(v1, g')
        g' := genT2.perturb(v2, g')
        g'
    end

    shrink(obj:(T1,T2)): Generator[\(T1,T2)\] = do
        (v1, v2) = obj
        ConcatGenerator(
            genT1.shrink(v1).map[\(T1,T2)\](fn x => (x,v2)),
            genT2.shrink(v2).map[\(T1,T2)\](fn x => (v1,x)))
    end
end

object genTuple3[\T1,T2,T3\](genT1:Gen[\T1\], genT2:Gen[\T2\], genT3:Gen[\T3\])
    extends Gen[\(T1,T2,T3)\]

    getter asString(): String = "genTuple3(" genT1 "," genT2 "," genT3 ")"

    generate(c:TestContext): (T1,T2,T3) = do
        v1 = genT1.generate(c)
        v2 = genT2.generate(c)
        v3 = genT3.generate(c)
        (v1, v2, v3)
    end

    perturb(obj:(T1,T2,T3), g:AnySeededRandomGen): AnySeededRandomGen = do
        (v1, v2, v3) = obj
        g': AnySeededRandomGen := g.perturbed(3)
        g' := genT1.perturb(v1, g')
        g' := genT2.perturb(v2, g')
        g' := genT3.perturb(v3, g')
        g'
    end

    shrink(obj:(T1,T2,T3)): Generator[\(T1,T2,T3)\] = do
        (v1, v2, v3) = obj
        ConcatGenerator(ConcatGenerator(
            genT1.shrink(v1).map[\(T1,T2,T3)\](fn x => (x,v2,v3)),
            genT2.shrink(v2).map[\(T1,T2,T3)\](fn x => (v1,x,v3))),
            genT3.shrink(v3).map[\(T1,T2,T3)\](fn x => (v1,v2,x)))
    end
end

object genTuple4[\T1,T2,T3,T4\](genT1:Gen[\T1\], genT2:Gen[\T2\], genT3:Gen[\T3\],
                                genT4:Gen[\T4\])
    extends Gen[\(T1,T2,T3,T4)\]

    getter asString(): String =
        "genTuple4(" genT1 "," genT2 "," genT3 "," genT4 ")"

    generate(c:TestContext): (T1,T2,T3,T4) = do
        v1 = genT1.generate(c)
        v2 = genT2.generate(c)
        v3 = genT3.generate(c)
        v4 = genT4.generate(c)
        (v1, v2, v3, v4)
    end

    perturb(obj:(T1,T2,T3,T4), g:AnySeededRandomGen): AnySeededRandomGen = do
        (v1, v2, v3, v4) = obj
        g': AnySeededRandomGen := g.perturbed(4)
        g' := genT1.perturb(v1, g')
        g' := genT2.perturb(v2, g')
        g' := genT3.perturb(v3, g')
        g' := genT4.perturb(v4, g')
        g'
    end

    shrink(obj:(T1,T2,T3,T4)): Generator[\(T1,T2,T3,T4)\] = do
        (v1, v2, v3, v4) = obj
        ConcatGenerator(ConcatGenerator(ConcatGenerator(
            genT1.shrink(v1).map[\(T1,T2,T3,T4)\](fn x => (x,v2,v3,v4)),
            genT2.shrink(v2).map[\(T1,T2,T3,T4)\](fn x => (v1,x,v3,v4))),
            genT3.shrink(v3).map[\(T1,T2,T3,T4)\](fn x => (v1,v2,x,v4))),
            genT4.shrink(v4).map[\(T1,T2,T3,T4)\](fn x => (v1,v2,v3,x)))
    end
end

object genTuple5[\T1,T2,T3,T4,T5\](genT1:Gen[\T1\], genT2:Gen[\T2\], genT3:Gen[\T3\],
                                   genT4:Gen[\T4\], genT5:Gen[\T5\])
    extends Gen[\(T1,T2,T3,T4,T5)\]

    getter asString(): String =
        "genTuple5(" genT1 "," genT2 "," genT3 "," genT4 "," genT5 ")"

    generate(c:TestContext): (T1,T2,T3,T4,T5) = do
        v1 = genT1.generate(c)
        v2 = genT2.generate(c)
        v3 = genT3.generate(c)
        v4 = genT4.generate(c)
        v5 = genT5.generate(c)
        (v1, v2, v3, v4, v5)
    end

    perturb(obj:(T1,T2,T3,T4,T5), g:AnySeededRandomGen): AnySeededRandomGen = do
        (v1, v2, v3, v4, v5) = obj
        g': AnySeededRandomGen := g.perturbed(5)
        g' := genT1.perturb(v1, g')
        g' := genT2.perturb(v2, g')
        g' := genT3.perturb(v3, g')
        g' := genT4.perturb(v4, g')
        g' := genT5.perturb(v5, g')
        g'
    end

    shrink(obj:(T1,T2,T3,T4,T5)): Generator[\(T1,T2,T3,T4,T5)\] = do
        (v1, v2, v3, v4, v5) = obj
        ConcatGenerator(ConcatGenerator(ConcatGenerator(ConcatGenerator(
            genT1.shrink(v1).map[\(T1,T2,T3,T4,T5)\](fn x => (x,v2,v3,v4,v5)),
            genT2.shrink(v2).map[\(T1,T2,T3,T4,T5)\](fn x => (v1,x,v3,v4,v5))),
            genT3.shrink(v3).map[\(T1,T2,T3,T4,T5)\](fn x => (v1,v2,x,v4,v5))),
            genT4.shrink(v4).map[\(T1,T2,T3,T4,T5)\](fn x => (v1,v2,v3,x,v5))),
            genT5.shrink(v5).map[\(T1,T2,T3,T4,T5)\](fn x => (v1,v2,v3,v4,x)))
    end
end

object genTuple6[\T1,T2,T3,T4,T5,T6\](genT1:Gen[\T1\], genT2:Gen[\T2\], genT3:Gen[\T3\],
                                      genT4:Gen[\T4\], genT5:Gen[\T5\], genT6:Gen[\T6\])
    extends Gen[\(T1,T2,T3,T4,T5,T6)\]

    getter asString(): String =
        "genTuple6(" genT1 "," genT2 "," genT3 "," genT4 "," genT5 "," genT6 ")"

    generate(c:TestContext): (T1,T2,T3,T4,T5,T6) = do
        v1 = genT1.generate(c)
        v2 = genT2.generate(c)
        v3 = genT3.generate(c)
        v4 = genT4.generate(c)
        v5 = genT5.generate(c)
        v6 = genT6.generate(c)
        (v1, v2, v3, v4, v5, v6)
    end

    perturb(obj:(T1,T2,T3,T4,T5,T6), g:AnySeededRandomGen): AnySeededRandomGen = do
        (v1, v2, v3, v4, v5, v6) = obj
        g': AnySeededRandomGen := g.perturbed(6)
        g' := genT1.perturb(v1, g')
        g' := genT2.perturb(v2, g')
        g' := genT3.perturb(v3, g')
        g' := genT4.perturb(v4, g')
        g' := genT5.perturb(v5, g')
        g' := genT6.perturb(v6, g')
        g'
    end

    shrink(obj:(T1,T2,T3,T4,T5,T6)): Generator[\(T1,T2,T3,T4,T5,T6)\] = do
        (v1, v2, v3, v4, v5, v6) = obj
        ConcatGenerator(ConcatGenerator(ConcatGenerator(ConcatGenerator(ConcatGenerator(
            genT1.shrink(v1).map[\(T1,T2,T3,T4,T5,T6)\](fn x => (x,v2,v3,v4,v5,v6)),
            genT2.shrink(v2).map[\(T1,T2,T3,T4,T5,T6)\](fn x => (v1,x,v3,v4,v5,v6))),
            genT3.shrink(v3).map[\(T1,T2,T3,T4,T5,T6)\](fn x => (v1,v2,x,v4,v5,v6))),
            genT4.shrink(v4).map[\(T1,T2,T3,T4,T5,T6)\](fn x => (v1,v2,v3,x,v5,v6))),
            genT5.shrink(v5).map[\(T1,T2,T3,T4,T5,T6)\](fn x => (v1,v2,v3,v4,x,v6))),
            genT6.shrink(v6).map[\(T1,T2,T3,T4,T5,T6)\](fn x => (v1,v2,v3,v4,v5,x)))
    end
end

object genArrow[\T,U\](genT:Gen[\T\], genU:Gen[\U\]) extends Gen[\T->U\]
    getter asString(): String = "genArrow(" genT "," genU ")"

    generate(c:TestContext): T->U = do
        g' = c.g.perturbed(0) (*) g' have to be independent to the future changes to c.
        fn (obj:T):U => genU.generate(TestContext(c.arbitrary, genT.perturb(obj, g'), c.size))
    end

    perturb(obj:T->U, g:AnySeededRandomGen): AnySeededRandomGen =
        (* We can use `defaultArbitrary` here because we already know the relevant
           generator, `genT`. *)
        genU.perturb(genT.generate(TestContext(defaultArbitrary, g)), g)
end

object genTestContext extends Gen[\TestContext\]
    getter asString(): String = "genTestContext"

    generate(c:TestContext): TestContext = do
        numTests = c.random(20,200)
        moreTests = c.random(50,500)
        size = c.random(500,2000)
        TestContext(c.arbitrary, c.g.perturbed(1), numTests, numTests + moreTests, size)
    end
end

(**********************************************************)
(* `Arbitrary` interface *)

(** A factory for `Gen[\T\]` instances. This is intended to allow users to
    extend a set of types testable easily: it will automatically handle
    types with static parameters (e.g. `Maybe[\E\]`) if possible. **)
trait Arbitrary excludes AnyGen
    (** Chooses an appropriate `Gen[\T\]` for given type parameter `T`. **)
    gen[\T\](): Gen[\T\]
end

private __genMatchMaybe[\E\](arb:Arbitrary, _:Maybe[\E\]->Maybe[\E\]): Gen[\Maybe[\E\]\] =
    genMaybe(arb.gen[\E\]())
private __genMatchList[\E\](arb:Arbitrary, _:List[\E\]->List[\E\]): Gen[\List[\E\]\] =
    genList(arb.gen[\E\]())
private __genMatchTuple2[\T1,T2\](arb:Arbitrary, _:(T1,T2)->(T1,T2)): Gen[\(T1,T2)\] =
    genTuple2(arb.gen[\T1\](), arb.gen[\T2\]())
private __genMatchTuple3[\T1,T2,T3\](arb:Arbitrary, _:(T1,T2,T3)->(T1,T2,T3)): Gen[\(T1,T2,T3)\] =
    genTuple3(arb.gen[\T1\](), arb.gen[\T2\](), arb.gen[\T3\]())
private __genMatchTuple4[\T1,T2,T3,T4\](arb:Arbitrary, _:(T1,T2,T3,T4)->(T1,T2,T3,T4)): Gen[\(T1,T2,T3,T4)\] =
    genTuple4(arb.gen[\T1\](), arb.gen[\T2\](), arb.gen[\T3\](), arb.gen[\T4\]())
private __genMatchElse[\E\](arb:Arbitrary, _:Set[\E\]->Set[\E\]): Gen[\Set[\E\]\] =
    genSet(arb.gen[\E\]())
private __genMatchElse[\K,V\](arb:Arbitrary, _:Map[\K,V\]->Map[\K,V\]): Gen[\Map[\K,V\]\] =
    genMap(arb.gen[\K\](), arb.gen[\V\]())
private __genMatchElse[\I\](arb:Arbitrary, _:Range[\I\]->Range[\I\]): Gen[\Range[\I\]\] =
    genRange(arb.gen[\I\]())
private __genMatchElse[\T,U\](arb:Arbitrary, _:(T->U)->(T->U)): Gen[\T->U\] =
    genArrow(arb.gen[\T\](), arb.gen[\U\]())

(** Default `Arbitrary` factory. Use this trait for a starting point. **)
trait DefaultArbitrary extends Arbitrary
    (* XXX should be usable with (self asif DefaultArbitrary).gen, but the current
       interpreter seems to reject this... *)
    gen0[\T\](arb:Arbitrary): Gen[\T\] = do
        (* Exact match first; see the rationale in `Gen` for details. *)
        f = fn (_:T):T => throw ForbiddenException
        typecase f of
            ()->() => genVoid
            Boolean->Boolean => genBoolean
            ZZ32->ZZ32 => genZZ32
            ZZ64->ZZ64 => genZZ64
            ZZ->ZZ => genZZ
            QQ->QQ => genQQ
            RR32->RR32 => genRR32 (*genRR32small*)
            RR64->RR64 => genRR64 (*genRR64small*)
            Char->Char => genChar
            String->String => genString
            (* Try covariant match then; we require this for every parametric types.
               Note that we still have to match exactly in the individual cases. *)
            else => typecase fn ():T => throw ForbiddenException of
                ()->AnyMaybe => __genMatchMaybe(arb, f)
                ()->AnyList => __genMatchList(arb, f)
                ()->(Any,Any) => __genMatchTuple2(arb, f)
                ()->(Any,Any,Any) => __genMatchTuple3(arb, f)
                ()->(Any,Any,Any,Any) => __genMatchTuple4(arb, f)
                else => __genMatchElse(arb, f)
            end
        end
    end

    gen[\T\](): Gen[\T\] = gen0[\T\](self)
end

(** An instance of `DefaultArbitrary`. Intended as a default argument to
    `check` function below. **)
object defaultArbitrary extends DefaultArbitrary
end

(**********************************************************)
(* `Testable` interface *)

(** Test Status. There are three statuses: passed (`TestPass`), failed
    (`TestFail`) and skipped (`TestSkip`). The skipped test is a test that
    passes due to the false assumption, so `check` will ignore that result
    and try again.

    Test statuses form three-valued logic, but we have different criteria
    from the traditional three-valued logic (in which the third value is
    "unknown"): the third logic value should encode a vacuous truth (say,
    `F IMPLIES T`) but it doesn't fit with the normal definition of the
    implication: `F IMPLIES T = (NOT F) OR T`. We may choose `NOT F` to be
    that third value but it will collide with the truthness of the third value.
    After the many futile attempts, we omitted `NOT` operator from our logic
    system at all. **)
trait TestStatus extends Equality[\TestStatus\] comprises { TestPass, TestFail, TestSkip }
    abstract getter asString(): String
    opr =(self, _:TestStatus): Boolean = false
    abstract opr AND(self, rhs:TestStatus): TestStatus
    abstract opr OR(self, rhs:TestStatus): TestStatus
end

object TestPass extends TestStatus
    getter asString(): String = "TestPass"
    opr =(self, _:TestPass): Boolean = true
    opr AND(self, rhs:TestStatus): TestStatus = rhs
    opr OR(self, rhs:TestStatus): TestStatus = self
end

object TestFail extends TestStatus
    getter asString(): String = "TestFail"
    opr =(self, _:TestFail): Boolean = true
    opr AND(self, rhs:TestStatus): TestStatus = self
    opr OR(self, rhs:TestStatus): TestStatus = self
    opr OR(self, rhs:TestPass): TestStatus = rhs
end

object TestSkip extends TestStatus
    getter asString(): String = "TestSkip"
    opr =(self, _:TestSkip): Boolean = true
    opr AND(self, rhs:TestStatus): TestStatus = self
    opr AND(self, rhs:TestFail): TestStatus = rhs
    opr OR(self, rhs:TestStatus): TestStatus = rhs
end

(** A test result returned by `Testable[\T\]` instances. **)
object TestResult(status:TestStatus, tags:List[\String\], collected:List[\Any\])
    (** Returns a copy of `TestResult` with a given tag. **)
    tagged(tag:String): TestResult = TestResult(status, tags.addRight(tag), collected)

    (** Returns a copy of `TestResult` with a given collected value. **)
    collect(obj:Any): TestResult = TestResult(status, tags, collected.addRight(obj))

    (** Collecting void has no effect. **)
    collect(_:()): TestResult = self
end

(** A test result initialized with a status only. **)
TestResult(status:TestStatus): TestResult =
    TestResult(status, emptyList[\String\](), emptyList[\Any\]())

(** A test result initialized with a Boolean status (`true` for pass, `false`
    for fail) only. **)
TestResult(ret:Boolean): TestResult =
    if ret then TestResult(TestPass) else TestResult(TestFail) end

(** A copy of test result from the other test result. (This function is
    provided for convenience.) **)
TestResult(result:TestResult): TestResult =
    TestResult(result.status, list result.tags, list result.collected)

(** A testable instance with arguments of type `P`. **)
trait Testable[\P\] excludes {String, AnyVector, Number, AnyMatrix}
    (** Runs a test with given arguments and returns a result. The test should
        be deterministic as much as possible: some routines like `shrink`, for
        example, rely on this behavior. **)
    abstract run(arg:P): TestResult

    (** `Testable[\P\]` can be also used as an arrow type `P->TestResult`. **)
    (* This has to be disabled, because it is ambiguous with String (Any,self)
       juxtapostion *)
    (*) opr juxtaposition(self, arg:P): TestResult = run(arg)
end

(** Represents a test that has been finished already and returns a fixed
    result. **)
object Tested(result:TestResult) extends Testable[\()\]
    run(_:()): TestResult = result
end
Tested(status:TestStatus): Tested = Tested(TestResult(status))
Tested(ret:Boolean): TestResult = Tested(TestResult(ret))

(** Encodes a test function (which can return a test result, status or Boolean
    flag, as like `TestResult` constructor).

    This is an internal representation: the public interface is `forAll`
    function. **)
private object Property[\P\](f:P->Any) extends Testable[\P\]
    run(arg:P): TestResult = do
        typecase f(arg) of
            ret:Boolean => TestResult(ret)
            ret:Testable[\()\] => ret.run()
            ret:TestResult => ret
        end
    end
end

(** Encodes an implication: `q` is tested if and only if `p` passes, and
    if `p` fails then the entire test is deemed skipped (i.e. it would pass
    but that's not what we want to test).

    This is an internal representation: the public interface is `==>`
    operator. **)
private object Implied(p:Testable[\()\], q:Testable[\()\]) extends Testable[\()\]
    run(_:()): TestResult = do
        presult = p.run()
        if presult.status = TestPass then
            qresult = q.run()
            TestResult(qresult.status, qresult.tags, presult.collected || qresult.collected)
        else
            TestResult(TestSkip, presult.tags, presult.collected)
        end
    end
end

(** Encodes a conjunction: the entire test passes if and only if both `p` and
    `q` pass. See `TestStatus` trait for the actual three-valued logic used.

    This is an internal representation: the public interface is `AND`
    operator. **)
private object Conjunction(p:Testable[\()\], q:Testable[\()\]) extends Testable[\()\]
    run(_:()): TestResult = do
        presult = p.run()
        qresult = q.run()
        tags = presult.tags || qresult.tags
        collected = presult.collected || qresult.collected
        TestResult(presult.status AND qresult.status, tags, collected)
    end
end

(** Encodes a disjunction: the entire test passes if and only if at least
    one of `p` and `q` pass. See `TestStatus` trait for the actual three-valued
    logic used.

    This is an internal representation: the public interface is `OR`
    operator. **)
private object Disjunction(p:Testable[\()\], q:Testable[\()\]) extends Testable[\()\]
    run(_:()): TestResult = do
        presult = p.run()
        qresult = q.run()
        tags = if presult.status = qresult.status = TestFail then presult.tags || qresult.tags else set[\String\]() end
        collected = presult.collected || qresult.collected
        TestResult(presult.status OR qresult.status, tags, collected)
    end
end

(** Appends a given tag if a base test has failed.

    This is an internal representation: the public interfaces are `|:` and `:|`
    operators. **)
private object Tagged(prop:Testable[\()\], tag:String) extends Testable[\()\]
    run(_:()): TestResult = do
        result = prop.run()
        if result.status = TestFail then result.tagged(tag) else result end
    end
end

(** Appends a given object to the collected test data.

    This is an internal representation: the public interfaces are `collect` and
    `classify` functions. **)
private object Collection(prop:Testable[\()\], obj:Any) extends Testable[\()\]
    run(_:()): TestResult = prop.run().collect(obj)
end

(* The public interfaces from here: (exists due to various overloading issues) *)

forAll[\P\](f:P->Any): Testable[\P\] = Property[\P\](f)

(* `cond ==> prop...` *)
opr ==>(p:Boolean, q:Boolean): Testable[\()\] = Implied(Tested(p), Tested(q))
opr ==>(p:Boolean, q:TestResult): Testable[\()\] = Implied(Tested(p), Tested(q))
opr ==>(p:Boolean, q:Testable[\()\]): Testable[\()\] = Implied(Tested(p), q)
opr ==>(p:TestResult, q:Boolean): Testable[\()\] = Implied(Tested(p), Tested(q))
opr ==>(p:TestResult, q:TestResult): Testable[\()\] = Implied(Tested(p), Tested(q))
opr ==>(p:TestResult, q:Testable[\()\]): Testable[\()\] = Implied(Tested(p), q)
opr ==>(p:Testable[\()\], q:Boolean): Testable[\()\] = Implied(p, Tested(q))
opr ==>(p:Testable[\()\], q:TestResult): Testable[\()\] = Implied(p, Tested(q))
opr ==>(p:Testable[\()\], q:Testable[\()\]): Testable[\()\] = Implied(p, q)

(* `"tag" |: prop...` or `prop... :| "tag"` *)
opr |(tag:String, p:()->Any): Testable[\()\] = Tagged(Property[\()\](p), tag)
opr |(tag:String, p:Testable[\()\]): Testable[\()\] = Tagged(p, tag)
(* (*) Not supported by Fortress yet
opr |(p:()->Any, tag:String): Testable[\()\] = Tagged(Property[\()\](p), tag)
opr |(p:Testable[\()\], tag:String): Testable[\()\] = Tagged(p, tag)
*)

(* `prop... AND prop...` *)
opr AND(p:Boolean, q:TestResult): Testable[\()\] = Conjunction(Tested(p), Tested(q))
opr AND(p:Boolean, q:Testable[\()\]): Testable[\()\] = Conjunction(Tested(p), q)
opr AND(p:TestResult, q:Boolean): Testable[\()\] = Conjunction(Tested(p), Tested(q))
opr AND(p:TestResult, q:TestResult): Testable[\()\] = Conjunction(Tested(p), Tested(q))
opr AND(p:TestResult, q:Testable[\()\]): Testable[\()\] = Conjunction(Tested(p), q)
opr AND(p:TestResult, q:()->Any): Testable[\()\] = Conjunction(Tested(p), Property[\()\](q))
opr AND(p:Testable[\()\], q:Boolean): Testable[\()\] = Conjunction(p, Tested(q))
opr AND(p:Testable[\()\], q:TestResult): Testable[\()\] = Conjunction(p, Tested(q))
opr AND(p:Testable[\()\], q:Testable[\()\]): Testable[\()\] = Conjunction(p, q)
opr AND(p:Testable[\()\], q:()->Any): Testable[\()\] = Conjunction(p, Property[\()\](q))

(* `prop... OR prop...` *)
opr OR(p:Boolean, q:TestResult): Testable[\()\] = Disjunction(Tested(p), Tested(q))
opr OR(p:Boolean, q:Testable[\()\]): Testable[\()\] = Disjunction(Tested(p), q)
opr OR(p:TestResult, q:Boolean): Testable[\()\] = Disjunction(Tested(p), Tested(q))
opr OR(p:TestResult, q:TestResult): Testable[\()\] = Disjunction(Tested(p), Tested(q))
opr OR(p:TestResult, q:Testable[\()\]): Testable[\()\] = Disjunction(Tested(p), q)
opr OR(p:TestResult, q:()->Any): Testable[\()\] = Disjunction(Tested(p), Property[\()\](q))
opr OR(p:Testable[\()\], q:Boolean): Testable[\()\] = Disjunction(p, Tested(q))
opr OR(p:Testable[\()\], q:TestResult): Testable[\()\] = Disjunction(p, Tested(q))
opr OR(p:Testable[\()\], q:Testable[\()\]): Testable[\()\] = Disjunction(p, q)
opr OR(p:Testable[\()\], q:()->Any): Testable[\()\] = Disjunction(p, Property[\()\](q))

trait PrefixJuxt excludes {Testable[\()\], AnyMatrix, AnyVector, AnyMultiplicativeRing, String}
    opr juxtaposition(self, prop:Boolean): Testable[\()\] = self Tested(prop)
    opr juxtaposition(self, prop:TestResult): Testable[\()\] = self Tested(prop)
    abstract opr juxtaposition(self, prop:Testable[\()\]): Testable[\()\]
    opr juxtaposition(self, obj:PrefixJuxt): PrefixJuxtList = PrefixJuxtList(self, obj)
end

object PrefixJuxtList(first:PrefixJuxt, second:PrefixJuxt) extends PrefixJuxt
    opr juxtaposition(self, prop:Testable[\()\]): Testable[\()\] = first (second prop)
end

(* `collect(obj) prop...` *)
object collect(obj:Any) extends PrefixJuxt
    opr juxtaposition(self, prop:Testable[\()\]): Testable[\()\] = Collection(prop, obj)
end

(* `classify(cond,obj) prop...` or `classify(cond,obj,obj) prop...` *)
object classify(cond:Boolean, trueobj:Any, falseobj:Any) extends PrefixJuxt
    opr juxtaposition(self, prop:Testable[\()\]): Testable[\()\] =
        Collection(prop, if cond then trueobj else falseobj end)
end
classify(cond:Boolean, trueobj:Any): classify = classify(cond, trueobj, ())

(**********************************************************)
(* Testing routines *)

(** Try to shrink a (failed) test instance in `n` tests. Returns a number of
    additional tests done (zero if it cannot be shrunk) and the resulting
    instance. **)
shrink[\P\](instance:P, t:Testable[\P\], g:Gen[\P\], n:ZZ32): (Boolean,ZZ32,P) = do
    (printing, done): (Boolean,Boolean) := (false, false)
    tested: ZZ32 := 0
    current: P := instance
    while NOT done AND tested < n do
        result = label shrinking
            for candidate <- g.shrink(current) do
                atomic tested += 1
                if t.run(candidate).status = TestFail then
                    exit with just candidate
                end
            end
            Nothing[\P\]
        end shrinking
        if instance' <- result then
            if NOT printing then
                print("Shrinking a failed instance.")
                printing := true
            end
            print(".")
            current := instance'
        else
            done := true
        end
    end
    if printing then println() end
    (done, tested, current)
end

(** Tests a property by running given test generator with given test generator
    and test context.

    It returns a `TestResult` with `TestPass` status when every tests are passed,
    even though it has to be properly pointed out that there are other possible
    bugs which haven't caught. It returns `TestFail` when one or more tests are
    failed, and `TestSkip` when it reached the maximum number of tests. **)
checkResult[\P\](t:Testable[\P\], g:Gen[\P\], c:TestContext): TestResult = do
    n = c.numTests
    m = c.maxTests

    (passed, skipped, failed): (ZZ32,ZZ32,ZZ32) := (0, 0, 0)
    freqmap: Map[\Any,ZZ32\] := {[\Any,ZZ32\]}
    failure = label checking
        while passed < n AND (passed + skipped + failed) < m do
            remaining = (n - passed) MIN (m - (passed + skipped + failed))
            (*) XXX we use the hard limit to avoid running too many tests in parallel!
            for _ <- 0#((remaining MAX 0) MIN 256) do
                instance = g.generate(c)
                result = t.run(instance)
                case result.status of
                    TestPass => do
                        atomic passed += 1
                        collected = quicksort(result.collected)
                        if NOT collected.isEmpty then
                            atomic freqmap := freqmap.update(collected, freqmap.member(collected, 0) + 1)
                        end
                    end
                    TestSkip => do
                        atomic skipped += 1
                    end
                    TestFail => do
                        atomic failed += 1
                        exit with just (instance, result)
                    end
                end
            end
        end
        Nothing[\(Any,TestResult)\]
    end checking

    if (instance, result) <- failure then
        remaining = m - (passed + skipped + failed)
        (shrinkdone, moretested, instance') = shrink(instance, t, g, remaining MAX 0)
        print("Failed in " (passed + failed) " test(s)")
        if moretested > 0 then
            if shrinkdone then
                print(" (and shrank in " moretested " test(s))")
            else
                print(" (and partially shrank in " moretested " test(s))")
            end
        end
        println(": " instance')
        if NOT result.tags.isEmpty then
            println("Tag(s) of failing properties:")
            for tag <- result.tags do println("    " tag) end
        end

        TestResult(TestFail)
    else
        limitreached = (passed + skipped + failed >= m)
        print("Passed " passed " test(s)")
        if skipped > 0 then
            print(" (and skipped " skipped " test(s))")
        end
        if limitreached then
            print(" but reached the maximum of " m " tests")
        end
        println(".")
        if NOT freqmap.isEmpty then
            println("Collected test data:")
            sortedfreqmap = quicksort(<| (freq,objs) | (objs,freq) <- freqmap |>)
            for (freq,objs) <- seq(sortedfreqmap.reverse) do
                formated = (BIG || [obj <- seq(objs)] ", " obj.asString)[2:]
                println("    " |\ 100 freq/n /| "%: " formated)
            end
        end

        if limitreached then
            TestResult(TestSkip)
        else
            TestResult(TestPass)
        end
    end
end

(** Same as `checkResult` but discards its result. Useful for actual testing. **)
check[\P\](t:Testable[\P\], g:Gen[\P\], c:TestContext): () =
    do _ = checkResult[\P\](t, g, c); () end

(** Same as above but creates a test generator using `Arbitrary` factory. **)
check[\P\](t:Testable[\P\], c:TestContext): () =
    check[\P\](t, c.gen[\P\](), c)
check[\P\](t:Testable[\P\], arb:Arbitrary, numTests:ZZ32): () =
    check[\P\](t, TestContext(arb, linearCongruential(), numTests))
check[\P\](t:Testable[\P\], arb:Arbitrary): () =
    check[\P\](t, TestContext(arb, linearCongruential()))

(** Same as above but uses `defaultArbitrary` factory. **)
check[\P\](t:Testable[\P\], numTests:ZZ32): () = check[\P\](t, defaultArbitrary, numTests)
check[\P\](t:Testable[\P\]): () = check[\P\](t, defaultArbitrary)

end
