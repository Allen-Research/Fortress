\section{Operators and Their Properties}
\seclabel{opr-properties}


For some types, such as the integers \EXP{\mathbb{Z}} or the rationals \EXP{\mathbb{Q}},
results are always exact, and algebraic properties can be expected to be obeyed exactly.
For other types, such as floating-point numbers, results are not always numerically
exact, and algebraic properties can be expected to be obeyed only approximately.
For example, given three floating-point values \VAR{a} and \VAR{b} and \VAR{c},
it may well be that \EXP{a+(b+c)} is not equal to \EXP{(a+b)+c}; but we would expect
their values to be reasonably close---unless, of course, overflow occurred in one
expression but not the other.

In order to address the difficulties of such approximate computation,
many of the traits described in this section come in two varieties:
approximate and exact.  The \EXP{+} operator on integers or
rationals is correctly described by the trait \TYP{Associative}, and
the \EXP{+} operator on floating-point numbers is correctly described
by the trait \TYP{ApproximatelyAssociative}.  An important distinction
is that the predicate used to test acceptability of exact algebraic
properties is \EXP{=}, which is required to be an equivalence relation
and therefore transitive, but a type-dependent binary predicate
(typically \EXP{\approx}) may be used to test acceptability of
approximate algebraic properties, and this predicate is required only
to be reflexive and symmetric.



%trait UnaryOperator[\T extends UnaryOperator[\T,ODOT\], opr ODOT\]
%    extends Any
%  abstract opr ODOT(self): T
%end
\begin{Fortress}
\(\KWD{trait}\:\TYP{UnaryOperator}\llbracket{}T \KWD{extends}\:\TYP{UnaryOperator}\llbracket{}T,\odot\rrbracket, \KWD{opr} \mathord{\odot}\rrbracket\)\\
{\tt~~~~}\pushtabs\=\+\(    \KWD{extends}\:\TYP{Any}\)\-\\\poptabs
{\tt~~}\pushtabs\=\+\(  \KWD{abstract}\;\;\KWD{opr} \mathord{\odot}(\KWD{self})\COLON T\)\-\\\poptabs
\(\KWD{end}\)
\end{Fortress}
\vskip-\lastskip
A \emph{unary operator} is a prefix operator that takes one argument and returns
a value of the same type.  Note that \EXP{\odot} is a static parameter,
used here as a ``variable'' name for an operator.


%trait BinaryOperator[\T extends BinaryOperator[\T,ODOT\], opr ODOT\]
%    extends Any
%  abstract opr ODOT(self, other: T): T
%end
\begin{Fortress}
\(\KWD{trait}\:\TYP{BinaryOperator}\llbracket{}T \KWD{extends}\:\TYP{BinaryOperator}\llbracket{}T,\odot\rrbracket, \KWD{opr} \mathord{\odot}\rrbracket\)\\
{\tt~~~~}\pushtabs\=\+\(    \KWD{extends}\:\TYP{Any}\)\-\\\poptabs
{\tt~~}\pushtabs\=\+\(  \KWD{abstract}\;\;\KWD{opr} \mathord{\odot}(\KWD{self}, \VAR{other}\COLON T)\COLON T\)\-\\\poptabs
\(\KWD{end}\)
\end{Fortress}
\vskip-\lastskip
A \emph{binary operator} is an infix operator that takes two arguments of the same type
and returns a value of that type.  Thus, for example,
any trait \VAR{T} that extends \EXP{\TYP{BinaryPredicate}\llbracket{}T,+\rrbracket}
necessarily has an infix method for the operator \EXP{+}, and that operator
takes two operands of type \VAR{T} and returns a value of type \VAR{T}.


%trait IdentityOperator[\T extends IdentityOperator[\T\]\]
%    extends { UnaryOperator[\T,IDENTITY\] }
%  property FORALL (a: T) (IDENTITY a) === a
%end
\begin{Fortress}
\(\KWD{trait}\:\TYP{IdentityOperator}\llbracket{}T \KWD{extends}\:\TYP{IdentityOperator}\llbracket{}T\rrbracket\rrbracket\)\\
{\tt~~~~}\pushtabs\=\+\(    \KWD{extends} \{\,\TYP{UnaryOperator}\llbracket{}T,\OPR{IDENTITY}\rrbracket\,\}\)\-\\\poptabs
{\tt~~}\pushtabs\=\+\(  \KWD{property} \forall (a\COLON T)\; (\OPR{IDENTITY}\:{a}) \sequiv a\)\-\\\poptabs
\(\KWD{end}\)
\end{Fortress}
\vskip-\lastskip
%% The trait \TYP{IdentityOperator} provides a definition of the unary \OPR{IDENTITY} operator, which simply returns its argument.
The trait \TYP{Object} extends \EXP{\TYP{IdentityOperator}\llbracket\TYP{Object}\rrbracket},
so the \OPR{IDENTITY} operator is defined for every type whatsoever.  (This operator  may not be terribly useful for
applications programming, but it has technical uses for specifying contracts and
algebraic properties in libraries.  It is used, for example, when defining the
trait \TYP{BooleanAlgebra} in terms of the trait \TYP{Ring}: because every value
is its own inverse with respect to the ``exclusive \scap{or}'' operator in a Boolean Algebra,
\OPR{IDENTITY} is the appropriate additive inverse operator for use with the trait \TYP{Ring}
in this connection.)


%trait ApproximatelyCommutative[\T extends ApproximatelyCommutative[\T,ODOT,APPROX\], opr ODOT, opr APPROX\]
%    extends { BinaryOperator[\T,ODOT\], Reflexive[\T,APPROX\], Symmetric[\T,APPROX\] }
%  property FORALL (a: T, b: T) (a ODOT b) :APPROX: (b ODOT a)
%end
\begin{Fortress}
\(\KWD{trait} \TYP{ApproximatelyCommutative}\llbracket{}T \KWD{extends} \TYP{ApproximatelyCommutative}\llbracket{}T,\odot,\approx\rrbracket, \KWD{opr} \mathord{\odot}, \KWD{opr} \mathord{\approx}\rrbracket\)\\
{\tt~~~~}\pushtabs\=\+\(    \KWD{extends} \{\,\TYP{BinaryOperator}\llbracket{}T,\odot\rrbracket, \TYP{Reflexive}\llbracket{}T,\approx\rrbracket, \TYP{Symmetric}\llbracket{}T,\approx\rrbracket\,\}\)\-\\\poptabs
{\tt~~}\pushtabs\=\+\(  \KWD{property} \forall (a\COLON T, b\COLON T)\; (a \odot b) \mathrel{\mathtt{:}}\approx\COLON (b \odot a)\)\-\\\poptabs
\(\KWD{end}\)
\end{Fortress}
\vskip-\lastskip
The trait \TYP{ApproximatelyCommutative} requires the operator \EXP{\odot} to be
\emph{approximately commutative}; that is, reversing the operands produces a result
that is considered to be ``close enough'' as determined by the specified \EXP{\approx} predicate.


%trait Commutative[\T extends Commutative[\T,ODOT\], opr ODOT\]
%    extends { ApproximatelyCommutative[\T,ODOT,=\], EquivalenceRelation[\T,=\] }
%end
\begin{Fortress}
\(\KWD{trait} \TYP{Commutative}\llbracket{}T \KWD{extends} \TYP{Commutative}\llbracket{}T,\odot\rrbracket, \KWD{opr} \mathord{\odot}\rrbracket\)\\
{\tt~~~~}\pushtabs\=\+\(    \KWD{extends} \{\,\TYP{ApproximatelyCommutative}\llbracket{}T,\odot,=\rrbracket, \TYP{EquivalenceRelation}\llbracket{}T,=\rrbracket\,\}\)\-\\\poptabs
\(\KWD{end}\)
\end{Fortress}
\vskip-\lastskip
The trait \TYP{Commutative} requires the operator \EXP{\odot} to be
\emph{commutative}; that is, reversing the operands produces an equal result.


%trait ApproximatelyAssociative[\T extends ApproximatelyAssociative[\T,ODOT,APPROX\], opr ODOT, opr APPROX\]
%    extends { BinaryOperator[\T,ODOT\], Reflexive[\T,APPROX\], Symmetric[\T,APPROX\] }
%  property FORALL (a: T, b: T, c: T) ((a ODOT b) ODOT c) :APPROX: (a ODOT (b ODOT c))
%end
\begin{Fortress}
\(\KWD{trait} \TYP{ApproximatelyAssociative}\llbracket{}T \KWD{extends} \TYP{ApproximatelyAssociative}\llbracket{}T,\odot,\approx\rrbracket, \KWD{opr} \mathord{\odot}, \KWD{opr} \mathord{\approx}\rrbracket\)\\
{\tt~~~~}\pushtabs\=\+\(    \KWD{extends} \{\,\TYP{BinaryOperator}\llbracket{}T,\odot\rrbracket, \TYP{Reflexive}\llbracket{}T,\approx\rrbracket, \TYP{Symmetric}\llbracket{}T,\approx\rrbracket\,\}\)\-\\\poptabs
{\tt~~}\pushtabs\=\+\(  \KWD{property} \forall (a\COLON T, b\COLON T, c\COLON T)\; ((a \odot b) \odot c) \mathrel{\mathtt{:}}\approx\COLON (a \odot (b \odot c))\)\-\\\poptabs
\(\KWD{end}\)
\end{Fortress}
\vskip-\lastskip
The trait \TYP{ApproximatelyAssociative} requires the operator \EXP{\odot} to be
\emph{approximately associative}; that is, the expressions \EXP{(a \odot b) \odot c}
and \EXP{a \odot (b \odot c)} always produce results that are ``close enough'' to each other
as determined by the specified \EXP{\approx} predicate.


%trait Associative[\T extends Associative[\T,ODOT\], opr ODOT\]
%    extends { ApproximatelyAssociative[\T,ODOT,=\], EquivalenceRelation[\T,=\] }
%end
\begin{Fortress}
\(\KWD{trait} \TYP{Associative}\llbracket{}T \KWD{extends} \TYP{Associative}\llbracket{}T,\odot\rrbracket, \KWD{opr} \mathord{\odot}\rrbracket\)\\
{\tt~~~~}\pushtabs\=\+\(    \KWD{extends} \{\,\TYP{ApproximatelyAssociative}\llbracket{}T,\odot,=\rrbracket, \TYP{EquivalenceRelation}\llbracket{}T,=\rrbracket\,\}\)\-\\\poptabs
\(\KWD{end}\)
\end{Fortress}
\vskip-\lastskip
The trait \TYP{Associative} requires the operator \EXP{\odot} to be
\emph{associative}; that is, the expressions \EXP{(a \odot b) \odot c}
and \EXP{a \odot (b \odot c)} always produce equal results.


%trait IdempotentBinaryOperator[\T extends IdempotentBinaryOperator[\T,ODOT\], opr ODOT\]
%    extends { BinaryOperator[\T,ODOT\], EquivalenceRelation[\T,=\] }
%  property FORALL (a: T) (a ODOT a) :=: a
%end
\begin{Fortress}
\(\KWD{trait} \TYP{IdempotentBinaryOperator}\llbracket{}T \KWD{extends} \TYP{IdempotentBinaryOperator}\llbracket{}T,\odot\rrbracket, \KWD{opr} \mathord{\odot}\rrbracket\)\\
{\tt~~~~}\pushtabs\=\+\(    \KWD{extends} \{\,\TYP{BinaryOperator}\llbracket{}T,\odot\rrbracket, \TYP{EquivalenceRelation}\llbracket{}T,=\rrbracket\,\}\)\-\\\poptabs
{\tt~~}\pushtabs\=\+\(  \KWD{property} \forall (a\COLON T)\; (a \odot a) \ASSIGN\COLON a\)\-\\\poptabs
\(\KWD{end}\)
\end{Fortress}
\vskip-\lastskip
An idempotent binary operator has the property that if its two arguments are the same
then the result is equal to each argument.  For example, \OPR{MAX} and \OPR{MIN} are
idempotent, as are \EXP{\wedge} and \EXP{\vee} applied to boolean arguments and
\EXP{\cap} and \EXP{\cup} applied to sets; but \EXP{+} applied
to integers is not idempotent because \EXP{1+1} does not produce \EXP{1},
and \EXP{\oplus} applied to boolean arguments is not idempotent because
\EXP{\VAR{true} \oplus \VAR{true}} produces \VAR{false}.  The property of idempotency
is sometimes of interest when performing reductions such as \EXP{\mathop{\OPR{MAX}}\limits_{i\leftarrow{}1\COLONOP{}n} a_i}.


%trait HasLeftIdentity[\T extends HasLeftIdentity[\T,ODOT\], opr ODOT\]
%    extends { BinaryOperator[\T,ODOT\], EquivalenceRelation[\T,=\] }
%  abstract isLeftIdentity(): Boolean
%  property FORALL (a: T, b: T) a.isLeftIdentity() IMPLIES: ((a ODOT b) = b)
%end
\begin{Fortress}
\(\KWD{trait}\:\TYP{HasLeftIdentity}\llbracket{}T \KWD{extends}\:\TYP{HasLeftIdentity}\llbracket{}T,\odot\rrbracket, \KWD{opr} \mathord{\odot}\rrbracket\)\\
{\tt~~~~}\pushtabs\=\+\(    \KWD{extends} \{\,\TYP{BinaryOperator}\llbracket{}T,\odot\rrbracket, \TYP{EquivalenceRelation}\llbracket{}T,=\rrbracket\,\}\)\-\\\poptabs
{\tt~~}\pushtabs\=\+\(  \KWD{abstract}\:\VAR{isLeftIdentity}()\COLON \TYP{Boolean}\)\\
\(  \KWD{property} \forall (a\COLON T, b\COLON T)\; a.\VAR{isLeftIdentity}() \rightarrow\COLON ((a \odot b) = b)\)\-\\\poptabs
\(\KWD{end}\)
\end{Fortress}
\vskip-\lastskip
A value \VAR{e} is a \emph{left identity} for
a binary operator \EXP{\odot} if the result of \EXP{\odot} always equals the right-hand operand
whenever \VAR{e} is the left-hand operand.
For example, \EXP{0} is a left identity for the \EXP{+} operator
on integers and the empty set is a left identity for the \EXP{\cup} operator on sets.


%trait HasRightIdentity[\T extends HasRightIdentity[\T,ODOT\], opr ODOT\]
%    extends { BinaryOperator[\T,ODOT\], EquivalenceRelation[\T,=\] }
%  abstract isRightIdentity(): Boolean
%  property FORALL (a: T, b: T) b.isRightIdentity() IMPLIES: ((a ODOT b) = a)
%end
\begin{Fortress}
\(\KWD{trait}\:\TYP{HasRightIdentity}\llbracket{}T \KWD{extends}\:\TYP{HasRightIdentity}\llbracket{}T,\odot\rrbracket, \KWD{opr} \mathord{\odot}\rrbracket\)\\
{\tt~~~~}\pushtabs\=\+\(    \KWD{extends} \{\,\TYP{BinaryOperator}\llbracket{}T,\odot\rrbracket, \TYP{EquivalenceRelation}\llbracket{}T,=\rrbracket\,\}\)\-\\\poptabs
{\tt~~}\pushtabs\=\+\(  \KWD{abstract}\:\VAR{isRightIdentity}()\COLON \TYP{Boolean}\)\\
\(  \KWD{property} \forall (a\COLON T, b\COLON T)\; b.\VAR{isRightIdentity}() \rightarrow\COLON ((a \odot b) = a)\)\-\\\poptabs
\(\KWD{end}\)
\end{Fortress}
\vskip-\lastskip
A value \VAR{e} is a \emph{right identity} for
a binary operator \EXP{\odot} if the result of \EXP{\odot} always equals the right-hand operand
whenever \VAR{e} is the left-hand operand.
For example, \EXP{0} is a right identity (as well as a left identity) for the \EXP{+} operator
on integers and the empty set is a right identity (as well as a left identity) for the \EXP{\cup} operator on sets.
By way of contrast, \EXP{1} is a right identity for division of rationals but not a left identity.


%value object Identity[\opr ODOT\] end
%
%trait HasIdentity[\T extends HasIdentity[\T,ODOT\], opr ODOT\]
%    extends { HasLeftIdentity[\T,ODOT\], HasRightIdentity[\T,ODOT\] }
%    where { T coerces Identity[\ODOT\] }
%  property FORALL (a: T) (a ODOT Identity[\ODOT\]) = a
%  property FORALL (a: T) (Identity[\ODOT\] ODOT a) = a
%  property FORALL (a: T) a.isLeftIdentity() <-> (a = Identity[\ODOT\])
%  property FORALL (a: T) a.isRightIdentity() <-> (a = Identity[\ODOT\])
%end
\begin{Fortress}
\(\KWD{value}\;\;\KWD{object}\:\TYP{Identity}\llbracket\KWD{opr} \mathord{\odot}\rrbracket \KWD{end}\)\\[4pt]
\(\KWD{trait}\:\TYP{HasIdentity}\llbracket{}T \KWD{extends}\:\TYP{HasIdentity}\llbracket{}T,\odot\rrbracket, \KWD{opr} \mathord{\odot}\rrbracket\)\\
{\tt~~~~}\pushtabs\=\+\(    \KWD{extends} \{\,\TYP{HasLeftIdentity}\llbracket{}T,\odot\rrbracket, \TYP{HasRightIdentity}\llbracket{}T,\odot\rrbracket\,\}\)\\
\(    \KWD{where} \{\,T \KWD{coerces}\:\TYP{Identity}\llbracket\odot\rrbracket\,\}\)\-\\\poptabs
{\tt~~}\pushtabs\=\+\(  \KWD{property} \forall (a\COLON T)\; (a \odot\:\TYP{Identity}\llbracket\odot\rrbracket) = a\)\\
\(  \KWD{property} \forall (a\COLON T)\; (\TYP{Identity}\llbracket\odot\rrbracket \odot\:{a}) = a\)\\
\(  \KWD{property} \forall (a\COLON T)\; a.\VAR{isLeftIdentity}() \leftrightarrow (a = \TYP{Identity}\llbracket\odot\rrbracket)\)\\
\(  \KWD{property} \forall (a\COLON T)\; a.\VAR{isRightIdentity}() \leftrightarrow (a = \TYP{Identity}\llbracket\odot\rrbracket)\)\-\\\poptabs
\(\KWD{end}\)
\end{Fortress}
\vskip-\lastskip
If the same value is both a left identity and a right identity for \EXP{\odot},
then it may be called simply an \emph{identity}---in fact, \emph{the} identity,
for it is unique and may be obtained by coercing the object
named \EXP{\TYP{Identity}\llbracket\odot\rrbracket} to type \VAR{T}.


%trait ApproximatelyHasInverses[\T extends ApproximatelyHasInverses[\T,ODOT,OSLASH,APPROX\],
%                                opr ODOT, opr OSLASH, opr APPROX\]
%    extends { HasIdentity[\T,ODOT\], UnaryOperator[\T,OSLASH\], BinaryOperator[\T,OSLASH\] }
%    where { T coerces Identity[\ODOT\] }
%  property FORALL (a: T) (a ODOT (OSLASH a)) :APPROX: Identity[\ODOT\]
%  property FORALL (a: T) ((OSLASH a) ODOT a) :APPROX: Identity[\ODOT\]
%  property FORALL (a: T, b: T) (a OSLASH b) :APPROX: (a ODOT (OSLASH b))
%end
\begin{Fortress}
\(\KWD{trait}\:\TYP{ApproximatelyHasInverses}\llbracket\,\null\)\pushtabs\=\+\(T \KWD{extends}\:\TYP{ApproximatelyHasInverses}\llbracket{}T,\odot,\oslash,\approx\rrbracket,\)\\
\(                                \KWD{opr} \mathord{\odot}, \KWD{opr} \mathord{\oslash}, \KWD{opr} \mathord{\approx}\rrbracket\)\-\\\poptabs
{\tt~~~~}\pushtabs\=\+\(    \KWD{extends} \{\,\TYP{HasIdentity}\llbracket{}T,\odot\rrbracket, \TYP{UnaryOperator}\llbracket{}T,\oslash\rrbracket, \TYP{BinaryOperator}\llbracket{}T,\oslash\rrbracket\,\}\)\\
\(    \KWD{where} \{\,T \KWD{coerces}\:\TYP{Identity}\llbracket\odot\rrbracket\,\}\)\-\\\poptabs
{\tt~~}\pushtabs\=\+\(  \KWD{property} \forall (a\COLON T)\; (a \odot (\oslash a)) \mathrel{\mathtt{:}}\approx\COLON \TYP{Identity}\llbracket\odot\rrbracket\)\\
\(  \KWD{property} \forall (a\COLON T)\; ((\oslash a) \odot a) \mathrel{\mathtt{:}}\approx\COLON \TYP{Identity}\llbracket\odot\rrbracket\)\\
\(  \KWD{property} \forall (a\COLON T, b\COLON T)\; (a \oslash b) \mathrel{\mathtt{:}}\approx\COLON (a \odot (\oslash b))\)\-\\\poptabs
\(\KWD{end}\)
\end{Fortress}
\vskip-\lastskip
A set of values with a binary operator \EXP{\odot} has \emph{approximate inverses} if and only if
the operator has an identity and for every value \VAR{a} there is another value \EXP{a'}
such that the result of applying \EXP{\odot} to \VAR{a} and \EXP{a'} (in either order) is ``close enough''
to the identity.
The unary operator \EXP{\oslash} returns the approximate inverse of its argument;
as a notational convenience, it may also be used as a binary operator.


%trait HasInverses[\T extends HasInverses[\T,ODOT,OSLASH\], opr ODOT, opr OSLASH\]
%    extends { ApproximatelyHasInverses[\T,ODOT,OSLASH,=\] }
%    where { T coerces Identity[\ODOT\] }
%end
\begin{Fortress}
\(\KWD{trait}\:\TYP{HasInverses}\llbracket{}T \KWD{extends}\:\TYP{HasInverses}\llbracket{}T,\odot,\oslash\rrbracket, \KWD{opr} \mathord{\odot}, \KWD{opr} \mathord{\oslash}\rrbracket\)\\
{\tt~~~~}\pushtabs\=\+\(    \KWD{extends} \{\,\TYP{ApproximatelyHasInverses}\llbracket{}T,\odot,\oslash,=\rrbracket\,\}\)\\
\(    \KWD{where} \{\,T \KWD{coerces}\:\TYP{Identity}\llbracket\odot\rrbracket\,\}\)\-\\\poptabs
\(\KWD{end}\)
\end{Fortress}
\vskip-\lastskip
A set of values with a binary operator \EXP{\odot} has \emph{inverses} if and only if
the operator has an identity and for every value \VAR{a} there is another value \EXP{a'}
such that the result of applying \EXP{\odot} to \VAR{a} and \EXP{a'} (in either order) equals the identity.
The unary operator \EXP{\oslash} returns the inverse of its argument;
as a notational convenience, it may also be used as a binary operator.
A standard example is the operator \EXP{+} on integers; the identity is \EXP{0},
and the unary operator \EXP{-} returns the additive inverse of its argument,
such that \EXP{a+(-a)=0} and \EXP{(-a)+a=0}.  Moreover, \EXP{-} may be used
as a binary operator: \EXP{a-b} means \EXP{a+(-b)}.


%value object Operator[\opr ODOT\] end
%
%trait HasLeftZeroes[\T extends HasLeftZeroes[\T,ODOT\], opr ODOT\]
%    extends { BinaryOperator[\T,ODOT\], EquivalenceRelation[\T,=\] }
%  abstract isLeftZero(_: Operator[\ODOT\]): Boolean
%  property FORALL (a: T, b: T) a.isLeftZero(Operator[\ODOT\]) IMPLIES: ((a ODOT b) = a)
%end
\begin{Fortress}
\(\KWD{value}\;\;\KWD{object}\:\TYP{Operator}\llbracket\KWD{opr} \mathord{\odot}\rrbracket \KWD{end}\)\\[4pt]
\(\KWD{trait}\:\TYP{HasLeftZeroes}\llbracket{}T \KWD{extends}\:\TYP{HasLeftZeroes}\llbracket{}T,\odot\rrbracket, \KWD{opr} \mathord{\odot}\rrbracket\)\\
{\tt~~~~}\pushtabs\=\+\(    \KWD{extends} \{\,\TYP{BinaryOperator}\llbracket{}T,\odot\rrbracket, \TYP{EquivalenceRelation}\llbracket{}T,=\rrbracket\,\}\)\-\\\poptabs
{\tt~~}\pushtabs\=\+\(  \KWD{abstract}\:\VAR{isLeftZero}(\_\COLON \TYP{Operator}\llbracket\odot\rrbracket)\COLON \TYP{Boolean}\)\\
\(  \KWD{property} \forall (a\COLON T, b\COLON T)\; a.\VAR{isLeftZero}(\TYP{Operator}\llbracket\odot\rrbracket) \rightarrow\COLON ((a \odot b) = a)\)\-\\\poptabs
\(\KWD{end}\)
\end{Fortress}
\vskip-\lastskip
A value \VAR{e} is a \emph{left zero} for
a binary operator \EXP{\odot} if the result of \EXP{\odot} always equals \VAR{e} whenever \VAR{e} is the left-hand operand.
For example, \EXP{-\infty} is a left zero for the \OPR{MIN} operator
on floating-point values, and \EXP{\mathtt{7FFFFFFF}_{16}} is a left zero
for the \OPR{MAX} operator on values of type \EXP{\mathbb{Z}32}.
The purpose of this trait is to specify a method that says whether a given
element is a left zero for \EXP{\odot}.


%trait HasRightZeroes[\T extends HasRightZeroes[\T,ODOT\], opr ODOT\]
%    extends { BinaryOperator[\T,ODOT\], EquivalenceRelation[\T,=\] }
%  abstract isRightZero(_: Operator[\ODOT\]): Boolean
%  property FORALL (a: T, b: T) b.isRightZero(Operator[\ODOT\]) IMPLIES: ((a ODOT b) = b)
%end
\begin{Fortress}
\(\KWD{trait}\:\TYP{HasRightZeroes}\llbracket{}T \KWD{extends}\:\TYP{HasRightZeroes}\llbracket{}T,\odot\rrbracket, \KWD{opr} \mathord{\odot}\rrbracket\)\\
{\tt~~~~}\pushtabs\=\+\(    \KWD{extends} \{\,\TYP{BinaryOperator}\llbracket{}T,\odot\rrbracket, \TYP{EquivalenceRelation}\llbracket{}T,=\rrbracket\,\}\)\-\\\poptabs
{\tt~~}\pushtabs\=\+\(  \KWD{abstract}\:\VAR{isRightZero}(\_\COLON \TYP{Operator}\llbracket\odot\rrbracket)\COLON \TYP{Boolean}\)\\
\(  \KWD{property} \forall (a\COLON T, b\COLON T)\; b.\VAR{isRightZero}(\TYP{Operator}\llbracket\odot\rrbracket) \rightarrow\COLON ((a \odot b) = b)\)\-\\\poptabs
\(\KWD{end}\)
\end{Fortress}
\vskip-\lastskip
A value \VAR{e} is a \emph{right zero} for a binary operator
\EXP{\odot} if the result of \EXP{\odot} always equals \VAR{e} whenever \VAR{e}
is the right-hand operand.  For example, \EXP{-\infty} is a right zero
(as well as a left zero) for the \OPR{MIN} operator on
floating-point values, and \EXP{\mathtt{7FFFFFFF}_{16}} is a right zero
(as well as a left zero) for the \OPR{MAX} operator on
values of type \EXP{\mathbb{Z}32}.  By way of contrast, \EXP{0} is a left zero
for the arithmetic shift operator on integers, but is not a right zero.
The purpose of this trait is to specify a method that says whether a given
element is a right zero for \EXP{\odot}.



%trait ApproximatelyLeftDistributive[\T extends ApproximatelyLeftDistributive[\T,OTIMES,OPLUS,APPROX\],
%                                     opr OTIMES, opr OPLUS, opr APPROX\]
%    extends { BinaryOperator[\T,OTIMES\], BinaryOperator[\T,OPLUS\], Reflexive[\T,APPROX\], Symmetric[\T,APPROX\] }
%  property FORALL (a: T, b: T, c: T) (a OTIMES (b OPLUS c)) :APPROX: ((a OTIMES b) OPLUS (a OTIMES c))
%end
\begin{Fortress}
\(\KWD{trait} \TYP{ApproximatelyLeftDistributive}\llbracket\null\)\pushtabs\=\+\(T \KWD{extends} \TYP{ApproximatelyLeftDistributive}\llbracket{}T,\otimes,\oplus,\approx\rrbracket,\)\\
\(                                     \KWD{opr} \mathord{\otimes}, \KWD{opr} \mathord{\oplus}, \KWD{opr} \mathord{\approx}\rrbracket\)\-\\\poptabs
{\tt~~~~}\pushtabs\=\+\(    \KWD{extends} \{\,\TYP{BinaryOperator}\llbracket{}T,\otimes\rrbracket, \TYP{BinaryOperator}\llbracket{}T,\oplus\rrbracket, \TYP{Reflexive}\llbracket{}T,\approx\rrbracket, \TYP{Symmetric}\llbracket{}T,\approx\rrbracket\,\}\)\-\\\poptabs
{\tt~~}\pushtabs\=\+\(  \KWD{property} \forall (a\COLON T, b\COLON T, c\COLON T)\; (a \otimes (b \oplus c)) \mathrel{\mathtt{:}}\approx\COLON ((a \otimes b) \oplus (a \otimes c))\)\-\\\poptabs
\(\KWD{end}\)
\end{Fortress}
\vskip-\lastskip
The trait \TYP{ApproximatelyLeftDistributive} requires the operator \EXP{\otimes} to be
\emph{approximately left distributive} over the operator \EXP{\oplus}; that is, the expressions \EXP{a \otimes (b \oplus c)}
and \EXP{(a \otimes b) \oplus (a \otimes c)} always produce results that are ``close enough'' to each other
as determined by the specified \EXP{\approx} predicate.


%trait LeftDistributive[\T extends LeftDistributive[\T,OTIMES,OPLUS\], opr OTIMES, opr OPLUS\]
%    extends { ApproximatelyLeftDistributive[\T,OTIMES,OPLUS,=\], EquivalenceRelation[\T,=\] }
%end
\begin{Fortress}
\(\KWD{trait} \TYP{LeftDistributive}\llbracket{}T \KWD{extends} \TYP{LeftDistributive}\llbracket{}T,\otimes,\oplus\rrbracket, \KWD{opr} \mathord{\otimes}, \KWD{opr} \mathord{\oplus}\rrbracket\)\\
{\tt~~~~}\pushtabs\=\+\(    \KWD{extends} \{\,\TYP{ApproximatelyLeftDistributive}\llbracket{}T,\otimes,\oplus,=\rrbracket, \TYP{EquivalenceRelation}\llbracket{}T,=\rrbracket\,\}\)\-\\\poptabs
\(\KWD{end}\)
\end{Fortress}
\vskip-\lastskip
The trait \TYP{LeftDistributive} requires the operator \EXP{\otimes} to be
\emph{left distributive} over the operator \EXP{\oplus}; that is, the expressions \EXP{a \otimes (b \oplus c)}
and \EXP{(a \otimes b) \oplus (a \otimes c)} always produce equal results.


%trait ApproximatelyRightDistributive[\T extends ApproximatelyRightDistributive[\T,OTIMES,OPLUS,APPROX\],
%                                      opr OTIMES, opr OPLUS, opr APPROX\]
%    extends { BinaryOperator[\T,OTIMES\], BinaryOperator[\T,OPLUS\], Reflexive[\T,APPROX\], Symmetric[\T,APPROX\] }
%  property FORALL (a: T, b: T, c: T) ((a OPLUS b) OTIMES c) :APPROX: ((a OTIMES c) OPLUS (b OTIMES c))
%end
\begin{Fortress}
\(\KWD{trait} \TYP{ApproximatelyRightDistributive}\llbracket\null\)\pushtabs\=\+\(T \KWD{extends} \TYP{ApproximatelyRightDistributive}\llbracket{}T,\otimes,\oplus,\approx\rrbracket,\)\\
\(                                      \KWD{opr} \mathord{\otimes}, \KWD{opr} \mathord{\oplus}, \KWD{opr} \mathord{\approx}\rrbracket\)\-\\\poptabs
{\tt~~~~}\pushtabs\=\+\(    \KWD{extends} \{\,\TYP{BinaryOperator}\llbracket{}T,\otimes\rrbracket, \TYP{BinaryOperator}\llbracket{}T,\oplus\rrbracket, \TYP{Reflexive}\llbracket{}T,\approx\rrbracket, \TYP{Symmetric}\llbracket{}T,\approx\rrbracket\,\}\)\-\\\poptabs
{\tt~~}\pushtabs\=\+\(  \KWD{property} \forall (a\COLON T, b\COLON T, c\COLON T)\; ((a \oplus b) \otimes c) \mathrel{\mathtt{:}}\approx\COLON ((a \otimes c) \oplus (b \otimes c))\)\-\\\poptabs
\(\KWD{end}\)
\end{Fortress}
\vskip-\lastskip
The trait \TYP{ApproximatelyRightDistributive} requires the operator \EXP{\otimes} to be
\emph{approximately right distributive} over the operator \EXP{\oplus}; that is, the expressions \EXP{(a \oplus b) \otimes c}
and \EXP{(a \otimes c) \oplus (b \otimes c)} always produce results that are ``close enough'' to each other
as determined by the specified \EXP{\approx} predicate.


%trait RightDistributive[\T extends RightDistributive[\T,OTIMES,OPLUS\], opr OTIMES, opr OPLUS\]
%    extends { ApproximatelyRightDistributive[\T,OTIMES,OPLUS,=\], EquivalenceRelation[\T,=\] }
%end
\begin{Fortress}
\(\KWD{trait} \TYP{RightDistributive}\llbracket{}T \KWD{extends} \TYP{RightDistributive}\llbracket{}T,\otimes,\oplus\rrbracket, \KWD{opr} \mathord{\otimes}, \KWD{opr} \mathord{\oplus}\rrbracket\)\\
{\tt~~~~}\pushtabs\=\+\(    \KWD{extends} \{\,\TYP{ApproximatelyRightDistributive}\llbracket{}T,\otimes,\oplus,=\rrbracket, \TYP{EquivalenceRelation}\llbracket{}T,=\rrbracket\,\}\)\-\\\poptabs
\(\KWD{end}\)
\end{Fortress}
\vskip-\lastskip
The trait \TYP{RightDistributive} requires the operator \EXP{\otimes} to be
\emph{right distributive} over the operator \EXP{\oplus}; that is, the expressions \EXP{(a \oplus b) \otimes c}
and \EXP{(a \otimes c) \oplus (b \otimes c)} always produce equal results.


%trait ApproximatelyDistributive[\T extends ApproximatelyDistributive[\T,OTIMES,OPLUS,APPROX\],
%                                 opr OTIMES, opr OPLUS, opr APPROX\]
%    extends { ApproximatelyLeftDistributive[\T,OTIMES,OPLUS,APPROX\],
%              ApproximatelyRightDistributive[\T,OTIMES,OPLUS,APPROX\] }
%end
\begin{Fortress}
\(\KWD{trait} \TYP{ApproximatelyDistributive}\llbracket\null\)\pushtabs\=\+\(T \KWD{extends} \TYP{ApproximatelyDistributive}\llbracket{}T,\otimes,\oplus,\approx\rrbracket,\)\\
\(                                 \KWD{opr} \mathord{\otimes}, \KWD{opr} \mathord{\oplus}, \KWD{opr} \mathord{\approx}\rrbracket\)\-\\\poptabs
{\tt~~~~}\pushtabs\=\+\(    \KWD{extends} \{\,\null\)\pushtabs\=\+\(\TYP{ApproximatelyLeftDistributive}\llbracket{}T,\otimes,\oplus,\approx\rrbracket,\)\\
\(              \TYP{ApproximatelyRightDistributive}\llbracket{}T,\otimes,\oplus,\approx\rrbracket\,\}\)\-\-\\\poptabs\poptabs
\(\KWD{end}\)
\end{Fortress}
\vskip-\lastskip
The trait \TYP{ApproximatelyDistributive} requires the operator \EXP{\otimes} to be
both approximately left distributive and approximately right distributive over the operator \EXP{\oplus}.


%trait Distributive[\T extends Distributive[\T,OTIMES,OPLUS\], opr OTIMES, opr OPLUS\]
%    extends { ApproximatelyDistributive[\T,OTIMES,OPLUS,=\], LeftDistributive[\T,OTIMES,OPLUS\], RightDistributive[\T,OTIMES,OPLUS\] }
%end
\begin{Fortress}
\(\KWD{trait} \TYP{Distributive}\llbracket{}T \KWD{extends} \TYP{Distributive}\llbracket{}T,\otimes,\oplus\rrbracket, \KWD{opr} \mathord{\otimes}, \KWD{opr} \mathord{\oplus}\rrbracket\)\\
{\tt~~~~}\pushtabs\=\+\(    \KWD{extends} \{\,\TYP{ApproximatelyDistributive}\llbracket{}T,\otimes,\oplus,=\rrbracket, \TYP{LeftDistributive}\llbracket{}T,\otimes,\oplus\rrbracket, \TYP{RightDistributive}\llbracket{}T,\otimes,\oplus\rrbracket\,\}\)\-\\\poptabs
\(\KWD{end}\)
\end{Fortress}
\vskip-\lastskip
The trait \TYP{Distributive} requires the operator \EXP{\otimes} to be
both left distributive and right distributive over the operator \EXP{\oplus}.


%trait AbsorptionLaws[\T extends AbsorptionLaws[\T,SQCAP,SQCUP\], opr SQCAP, opr SQCUP\]
%    extends { BinaryOperator[\T,SQCAP\], BinaryOperator[\T,SQCUP\], EquivalenceRelation[\T,=\] }
%  property FORALL (a: T, b: T) a SQCUP (a SQCAP b) = a = a SQCAP (a SQCUP b)
%end
\begin{Fortress}
\(\KWD{trait}\:\TYP{AbsorptionLaws}\llbracket{}T \KWD{extends}\:\TYP{AbsorptionLaws}\llbracket{}T,\sqcap,\sqcup\rrbracket, \KWD{opr} \mathord{\sqcap}, \KWD{opr} \mathord{\sqcup}\rrbracket\)\\
{\tt~~~~}\pushtabs\=\+\(    \KWD{extends} \{\,\TYP{BinaryOperator}\llbracket{}T,\sqcap\rrbracket, \TYP{BinaryOperator}\llbracket{}T,\sqcup\rrbracket, \TYP{EquivalenceRelation}\llbracket{}T,=\rrbracket\,\}\)\-\\\poptabs
{\tt~~}\pushtabs\=\+\(  \KWD{property} \forall (a\COLON T, b\COLON T)\; a \sqcup (a \sqcap b) = a = a \sqcap (a \sqcup b)\)\-\\\poptabs
\(\KWD{end}\)
\end{Fortress}
\vskip-\lastskip
The \emph{absorption laws} specify certain relationships between two operators \EXP{\sqcap} and \EXP{\sqcup}.
These laws are one of the defining properties of a lattice.


%value object Zero[\opr OTIMES\] end
%
%trait ApproximateZeroAnnihilation[\T extends ApproximateZeroAnnihilation[\T,OTIMES,APPROX\],
%                                   opr OTIMES, opr APPROX\]
%    extends { BinaryOperator[\T,OTIMES\], Reflexive[\T,APPROX\], Symmetric[\T,APPROX\] }
%    where { T coerces Zero[\OTIMES\] }
%  property FORALL (a: T) (Zero[\OTIMES\] OTIMES a) :APPROX: Zero[\OTIMES\]
%  property FORALL (a: T) (a OTIMES Zero[\OTIMES\]) :APPROX: Zero[\OTIMES\]
%end
\begin{Fortress}
\(\KWD{value}\;\;\KWD{object}\:\TYP{Zero}\llbracket\KWD{opr} \mathord{\otimes}\rrbracket \KWD{end}\)\\[4pt]
\(\KWD{trait}\:\TYP{ApproximateZeroAnnihilation}\llbracket\,\null\)\pushtabs\=\+\(T \KWD{extends}\:\TYP{ApproximateZeroAnnihilation}\llbracket{}T,\otimes,\approx\rrbracket,\)\\
\(                                   \KWD{opr} \mathord{\otimes}, \KWD{opr} \mathord{\approx}\rrbracket\)\-\\\poptabs
{\tt~~~~}\pushtabs\=\+\(    \KWD{extends} \{\,\TYP{BinaryOperator}\llbracket{}T,\otimes\rrbracket, \TYP{Reflexive}\llbracket{}T,\approx\rrbracket, \TYP{Symmetric}\llbracket{}T,\approx\rrbracket\,\}\)\\
\(    \KWD{where} \{\,T \KWD{coerces}\:\TYP{Zero}\llbracket\otimes\rrbracket\,\}\)\-\\\poptabs
{\tt~~}\pushtabs\=\+\(  \KWD{property} \forall (a\COLON T)\; (\TYP{Zero}\llbracket\otimes\rrbracket \otimes a) \mathrel{\mathtt{:}}\approx\COLON \TYP{Zero}\llbracket\otimes\rrbracket\)\\
\(  \KWD{property} \forall (a\COLON T)\; (a \otimes \TYP{Zero}\llbracket\otimes\rrbracket) \mathrel{\mathtt{:}}\approx\COLON \TYP{Zero}\llbracket\otimes\rrbracket\)\-\\\poptabs
\(\KWD{end}\)
\end{Fortress}
\vskip-\lastskip
An operator \EXP{\otimes} obeys \emph{approximate zero annihilation} if and only if there is an element
(call it \VAR{z}) that when used as either operand of \EXP{\otimes} causes the result to be
``close enough'' to \VAR{z} as determined by the specified \EXP{\approx} predicate.
This zero element may be obtained by coercing the object
named \EXP{\TYP{Zero}\llbracket\otimes\rrbracket} to type \VAR{T}.



%trait ZeroAnnihilation[\T extends ZeroAnnihilation[\T,OTIMES\], opr OTIMES\]
%    extends { ApproximateZeroAnnihilation[\T,OTIMES,=\], EquivalenceRelation[\T,=\],
%              HasLeftZeroes[\T,OTIMES\], HasRightZeroes[\T,OTIMES\] }
%    where { T coerces Zero[\OTIMES\] }
%end
\begin{Fortress}
\(\KWD{trait}\:\TYP{ZeroAnnihilation}\llbracket{}T \KWD{extends}\:\TYP{ZeroAnnihilation}\llbracket{}T,\otimes\rrbracket, \KWD{opr} \mathord{\otimes}\rrbracket\)\\
{\tt~~~~}\pushtabs\=\+\(    \KWD{extends} \{\, \null\)\pushtabs\=\+\(\TYP{ApproximateZeroAnnihilation}\llbracket{}T,\otimes,=\rrbracket, \TYP{EquivalenceRelation}\llbracket{}T,=\rrbracket,\)\\
\(              \TYP{HasLeftZeroes}\llbracket{}T,\otimes\rrbracket, \TYP{HasRightZeroes}\llbracket{}T,\otimes\rrbracket\,\}\)\-\\\poptabs
\(    \KWD{where} \{\,T \KWD{coerces}\:\TYP{Zero}\llbracket\otimes\rrbracket\,\}\)\-\\\poptabs
\(\KWD{end}\)
\end{Fortress}
\vskip-\lastskip
An operator \EXP{\otimes} obeys \emph{zero annihilation} if and only if there is an element
(call it \VAR{z}) that when used as either operand of \EXP{\otimes} causes the result to equal \VAR{z}.
This element is both a left zero and a right zero for \EXP{\otimes}.


%trait NoApproximateZeroDivisors[\T extends NoApproximateZeroDivisors[\T,OTIMES,APPROX\], opr OTIMES, opr APPROX\]
%    extends { BinaryOperator[\T,OTIMES\], Reflexive[\T,APPROX\], Symmetric[\T,APPROX\] }
%    where { T coerces Zero[\OTIMES\] }
%  property FORALL (a: T, b: T) (a OTIMES b :APPROX: Zero[\OTIMES\]) IMPLIES (a APPROX Zero[\OTIMES\] OR b APPROX Zero[\OTIMES\])
%end
\begin{Fortress}
\(\KWD{trait}\:\TYP{NoApproximateZeroDivisors}\llbracket{}T \KWD{extends}\:\TYP{NoApproximateZeroDivisors}\llbracket{}T,\otimes,\approx\rrbracket, \KWD{opr} \mathord{\otimes}, \KWD{opr} \mathord{\approx}\rrbracket\)\\
{\tt~~~~}\pushtabs\=\+\(    \KWD{extends} \{\,\TYP{BinaryOperator}\llbracket{}T,\otimes\rrbracket, \TYP{Reflexive}\llbracket{}T,\approx\rrbracket, \TYP{Symmetric}\llbracket{}T,\approx\rrbracket\,\}\)\\
\(    \KWD{where} \{\,T \KWD{coerces}\:\TYP{Zero}\llbracket\otimes\rrbracket\,\}\)\-\\\poptabs
{\tt~~}\pushtabs\=\+\(  \KWD{property} \forall (a\COLON T, b\COLON T)\; (a \otimes b \mathrel{\mathtt{:}}\approx\COLON \TYP{Zero}\llbracket\otimes\rrbracket) \rightarrow (a \approx \TYP{Zero}\llbracket\otimes\rrbracket \vee b \approx \TYP{Zero}\llbracket\otimes\rrbracket)\)\-\\\poptabs
\(\KWD{end}\)
\end{Fortress}
\vskip-\lastskip
An operator \EXP{\otimes} has \emph{no approximate zero divisors} if and only if,
for every pair of elements \VAR{a} and \VAR{b}, if \EXP{a \otimes b} is approximately zero
then at least one of \VAR{a} and \VAR{b} is approximately zero.  (Great care
is needed in the definition of ``approximately'' for this to work out correctly
in practice.)



%trait NoZeroDivisors[\T extends NoZeroDivisors[\T,OTIMES\], opr OTIMES\]
%    extends { NoApproximateZeroDivisors[\T,OTIMES,=\], EquivalenceRelation[\T,=\] }
%    where { T coerces Zero[\OTIMES\] }
%  property FORALL (a: T, b: T) (a OTIMES b = Zero[\OTIMES\]) IMPLIES (a = Zero[\OTIMES\] OR b = Zero[\OTIMES\])
%end
\begin{Fortress}
\(\KWD{trait}\:\TYP{NoZeroDivisors}\llbracket{}T \KWD{extends}\:\TYP{NoZeroDivisors}\llbracket{}T,\otimes\rrbracket, \KWD{opr} \mathord{\otimes}\rrbracket\)\\
{\tt~~~~}\pushtabs\=\+\(    \KWD{extends} \{\,\TYP{NoApproximateZeroDivisors}\llbracket{}T,\otimes,=\rrbracket, \TYP{EquivalenceRelation}\llbracket{}T,=\rrbracket\,\}\)\\
\(    \KWD{where} \{\,T \KWD{coerces}\:\TYP{Zero}\llbracket\otimes\rrbracket\,\}\)\-\\\poptabs
{\tt~~}\pushtabs\=\+\(  \KWD{property} \forall (a\COLON T, b\COLON T)\; (a \otimes b = \TYP{Zero}\llbracket\otimes\rrbracket) \rightarrow (a = \TYP{Zero}\llbracket\otimes\rrbracket \vee b = \TYP{Zero}\llbracket\otimes\rrbracket)\)\-\\\poptabs
\(\KWD{end}\)
\end{Fortress}
\vskip-\lastskip
An operator \EXP{\otimes} has \emph{no zero divisors} if and only if,
for every pair of elements \VAR{a} and \VAR{b}, if \EXP{a \otimes b} is zero
then at least one of \VAR{a} and \VAR{b} is zero (put conversely,
if \VAR{a} and \VAR{b} are both nonzero then \EXP{a \otimes b} must be nonzero).



%trait UnaryOperatorSubstitutionLaws[\T extends UnaryOperatorSubstitutionLaws[\T,ODOT,EQ\],
%                                     opr ODOT, opr SIMEQ\]
%    extends { UnaryOperator[\T,ODOT\], BinaryPredicate[\T,SIMEQ\] }
%  property FORALL (a: T, a': T) (a SIMEQ a') IMPLIES: (ODOT a) SIMEQ (ODOT a')
%end
\begin{Fortress}
\(\KWD{trait} \TYP{UnaryOperatorSubstitutionLaws}\llbracket\null\)\pushtabs\=\+\(T \KWD{extends} \TYP{UnaryOperatorSubstitutionLaws}\llbracket{}T,\odot,=\rrbracket,\)\\
\(                                     \KWD{opr} \mathord{\odot}, \KWD{opr} \mathord{\simeq}\rrbracket\)\-\\\poptabs
{\tt~~~~}\pushtabs\=\+\(    \KWD{extends} \{\,\TYP{UnaryOperator}\llbracket{}T,\odot\rrbracket, \TYP{BinaryPredicate}\llbracket{}T,\simeq\rrbracket\,\}\)\-\\\poptabs
{\tt~~}\pushtabs\=\+\(  \KWD{property} \forall (a\COLON T, a'\COLON T)\; (a \simeq a') \rightarrow\COLON (\odot a) \simeq (\odot a')\)\-\\\poptabs
\(\KWD{end}\)
\end{Fortress}
\vskip-\lastskip
This peculiarly spiffy trait states that the unary operator \EXP{\odot} is consistent under substitutions
described by the relation \EXP{\simeq} (which is typically, but not always, an equivalence relation);
that is, the result produced by \EXP{\odot} is unchanged if its
argument is replaced by some other value that is equivalent.


%trait BinaryOperatorSubstitutionLaws[\T extends BinaryOperatorSubstitutionLaws[\T,ODOT,EQ\],
%                                      opr ODOT, opr SIMEQ\]
%    extends { BinaryOperator[\T,ODOT\], BinaryPredicate[\T,SIMEQ\] }
%  property FORALL (a: T, a': T) (a SIMEQ a') IMPLIES: FORALL (b: T) (a ODOT b) SIMEQ (a' ODOT b)
%  property FORALL (b: T, b': T) (b SIMEQ b') IMPLIES: FORALL (a: T) (a ODOT b) SIMEQ (a ODOT b')
%end
\begin{Fortress}
\(\KWD{trait} \TYP{BinaryOperatorSubstitutionLaws}\llbracket\null\)\pushtabs\=\+\(T \KWD{extends} \TYP{BinaryOperatorSubstitutionLaws}\llbracket{}T,\odot,=\rrbracket,\)\\
\(                                      \KWD{opr} \mathord{\odot}, \KWD{opr} \mathord{\simeq}\rrbracket\)\-\\\poptabs
{\tt~~~~}\pushtabs\=\+\(    \KWD{extends} \{\,\TYP{BinaryOperator}\llbracket{}T,\odot\rrbracket, \TYP{BinaryPredicate}\llbracket{}T,\simeq\rrbracket\,\}\)\-\\\poptabs
{\tt~~}\pushtabs\=\+\(  \KWD{property} \forall (a\COLON T, a'\COLON T)\; (a \simeq a') \rightarrow\COLON \forall (b\COLON T)\; (a \odot b) \simeq (a' \odot b)\)\\
\(  \KWD{property} \forall (b\COLON T, b'\COLON T)\; (b \simeq b') \rightarrow\COLON \forall (a\COLON T)\; (a \odot b) \simeq (a \odot b')\)\-\\\poptabs
\(\KWD{end}\)
\end{Fortress}
\vskip-\lastskip
This equally spiffy trait states that the binary operator \EXP{\odot} is consistent under substitutions
described by the relation \EXP{\simeq} (which is typically, but not always, an equivalence relation);
that is, the result produced by \EXP{\odot} is unchanged if either
argument is replaced by some other value that is equivalent.  (It is
then easy to prove that the result is unchanged even when \emph{both}
arguments are replaced by equivalent values.)



\section{Lattices}
\seclabel{opr-lattices}

%% trait Semilattice[\T extends Semilattice[\T,SQCAP\], opr SQCAP\]
%%     extends { Commutative[\T,SQCAP\], Associative[\T,SQCAP\], IdempotentBinaryOperator[\T,SQCAP\] }
%% end
\begin{Fortress}
\(\KWD{trait}\:\TYP{Semilattice}\llbracket{}T \KWD{extends}\:\TYP{Semilattice}\llbracket{}T,\sqcap\rrbracket, \KWD{opr} \mathord{\sqcap}\rrbracket\)\\
{\tt~~~~}\pushtabs\=\+\(    \KWD{extends} \{\,\TYP{Commutative}\llbracket{}T,\sqcap\rrbracket, \TYP{Associative}\llbracket{}T,\sqcap\rrbracket, \TYP{IdempotentBinaryOperator}\llbracket{}T,\sqcap\rrbracket\,\}\)\-\\\poptabs
\(\KWD{end}\)
\end{Fortress}
\vskip-\lastskip
A \emph{semilattice} is a set of values with an operator \EXP{\sqcap} that is commutative, associative, and idempotent.
Examples of such operators are \EXP{\wedge}, \EXP{\vee}, \EXP{\cap}, \EXP{\cup}, \OPR{MAX}, \OPR{MIN}, \OPR{GCD}, and \OPR{LCM}.


%% trait BoundedSemilattice[\T extends BoundedSemilattice[\T,SQCAP\], opr SQCAP\]
%%     extends { Semilattice[\T,SQCAP\], CommutativeMonoid[\T,SQCAP\] }
%%     where { T coerces Identity[\SQCAP\] }
%% end
\begin{Fortress}
\(\KWD{trait}\:\TYP{BoundedSemilattice}\llbracket{}T \KWD{extends}\:\TYP{BoundedSemilattice}\llbracket{}T,\sqcap\rrbracket, \KWD{opr} \mathord{\sqcap}\rrbracket\)\\
{\tt~~~~}\pushtabs\=\+\(    \KWD{extends} \{\,\TYP{Semilattice}\llbracket{}T,\sqcap\rrbracket, \TYP{CommutativeMonoid}\llbracket{}T,\sqcap\rrbracket\,\}\)\\
\(    \KWD{where} \{\,T \KWD{coerces}\:\TYP{Identity}\llbracket\sqcap\rrbracket\,\}\)\-\\\poptabs
\(\KWD{end}\)
\end{Fortress}
\vskip-\lastskip
A \emph{bounded semilattice} is a semilattice for which the operator \EXP{\sqcap} has an identity.
For example, the boolean value \VAR{true} is the identity for \EXP{\wedge} and the empty set is the identity for \EXP{\cup}.


%% trait Lattice[\T extends Lattice[\T,SQCAP,SQCUP\], opr SQCAP, opr SQCUP\]
%%     extends { Semilattice[\T,SQCAP\], Semilattice[\T,SQCUP\], AbsorptionLaws[\T,SQCAP,SQCUP\] }
%% end
\begin{Fortress}
\(\KWD{trait}\:\TYP{Lattice}\llbracket{}T \KWD{extends}\:\TYP{Lattice}\llbracket{}T,\sqcap,\sqcup\rrbracket, \KWD{opr} \mathord{\sqcap}, \KWD{opr} \mathord{\sqcup}\rrbracket\)\\
{\tt~~~~}\pushtabs\=\+\(    \KWD{extends} \{\,\TYP{Semilattice}\llbracket{}T,\sqcap\rrbracket, \TYP{Semilattice}\llbracket{}T,\sqcup\rrbracket, \TYP{AbsorptionLaws}\llbracket{}T,\sqcap,\sqcup\rrbracket\,\}\)\-\\\poptabs
\(\KWD{end}\)
\end{Fortress}
\vskip-\lastskip
A \emph{lattice} is a pair of semilattices that share the same set of values
and whose operators together obey the absorption laws.  One operator
(here, by convention, \EXP{\sqcap}) is called the \emph{meet} operator
and the other (here, by convention, \EXP{\sqcup}) is called the \emph{join}
operator.


%% trait MeetBoundedLattice[\T extends MeetBoundedLattice[\T,SQCAP,SQCUP\], opr SQCAP, opr SQCUP\]
%%     extends { Lattice[\T,SQCAP,SQCUP\], BoundedSemilattice[\T,SQCAP\] }
%%     where { T coerces Identity[\SQCAP\] }
%% end
\begin{Fortress}
\(\KWD{trait}\:\TYP{MeetBoundedLattice}\llbracket{}T \KWD{extends}\:\TYP{MeetBoundedLattice}\llbracket{}T,\sqcap,\sqcup\rrbracket, \KWD{opr} \mathord{\sqcap}, \KWD{opr} \mathord{\sqcup}\rrbracket\)\\
{\tt~~~~}\pushtabs\=\+\(    \KWD{extends} \{\,\TYP{Lattice}\llbracket{}T,\sqcap,\sqcup\rrbracket, \TYP{BoundedSemilattice}\llbracket{}T,\sqcap\rrbracket\,\}\)\\
\(    \KWD{where} \{\,T \KWD{coerces}\:\TYP{Identity}\llbracket\sqcap\rrbracket\,\}\)\-\\\poptabs
\(\KWD{end}\)
\end{Fortress}
\vskip-\lastskip
If the semilattice associated with the meet operator of a lattice is bounded,
then the lattice is a \emph{meet-bounded lattice}.


%% trait JoinBoundedLattice[\T extends JoinBoundedLattice[\T,SQCAP,SQCUP\], opr SQCAP, opr SQCUP\]
%%     extends { Lattice[\T,SQCAP,SQCUP\], BoundedSemilattice[\T,SQCUP\]}
%%     where { T coerces Identity[\SQCUP\] }
%% end
\begin{Fortress}
\(\KWD{trait}\:\TYP{JoinBoundedLattice}\llbracket{}T \KWD{extends}\:\TYP{JoinBoundedLattice}\llbracket{}T,\sqcap,\sqcup\rrbracket, \KWD{opr} \mathord{\sqcap}, \KWD{opr} \mathord{\sqcup}\rrbracket\)\\
{\tt~~~~}\pushtabs\=\+\(    \KWD{extends} \{\,\TYP{Lattice}\llbracket{}T,\sqcap,\sqcup\rrbracket, \TYP{BoundedSemilattice}\llbracket{}T,\sqcup\rrbracket\}\)\\
\(    \KWD{where} \{\,T \KWD{coerces}\:\TYP{Identity}\llbracket\sqcup\rrbracket\,\}\)\-\\\poptabs
\(\KWD{end}\)
\end{Fortress}
\vskip-\lastskip
If the semilattice associated with the join operator of a lattice is bounded,
then the lattice is a \emph{join-bounded lattice}.


%% trait BoundedLattice[\T extends BoundedLattice[\T,SQCAP,SQCUP\], opr SQCAP, opr SQCUP\]
%%     extends { MeetBoundedLattice[\T,SQCAP,SQCUP\], JoinBoundedLattice[\T,SQCAP,SQCUP\]}
%%     where { T coerces Identity[\SQCAP\], T coerces Identity[\SQCUP\] }
%% end
\begin{Fortress}
\(\KWD{trait}\:\TYP{BoundedLattice}\llbracket{}T \KWD{extends}\:\TYP{BoundedLattice}\llbracket{}T,\sqcap,\sqcup\rrbracket, \KWD{opr} \mathord{\sqcap}, \KWD{opr} \mathord{\sqcup}\rrbracket\)\\
{\tt~~~~}\pushtabs\=\+\(    \KWD{extends} \{\,\TYP{MeetBoundedLattice}\llbracket{}T,\sqcap,\sqcup\rrbracket, \TYP{JoinBoundedLattice}\llbracket{}T,\sqcap,\sqcup\rrbracket\}\)\\
\(    \KWD{where} \{\,T \KWD{coerces}\:\TYP{Identity}\llbracket\sqcap\rrbracket, T \KWD{coerces}\:\TYP{Identity}\llbracket\sqcup\rrbracket\,\}\)\-\\\poptabs
\(\KWD{end}\)
\end{Fortress}
\vskip-\lastskip
If a lattice is both meet-bounded and join-bounded, then we simply say that the lattice is \emph{bounded}.



%% trait PartialOrderAndLattice[\T extends PartialOrderLattice[\T,PRECEQ,SQCAP,SQCUP\],
%%                               opr PRECEQ, opr SQCAP, opr SQCUP\]
%%     extends { PartialOrder[\T,PRECEQ\], Lattice[\T,SQCAP,SQCUP\] }
%%   property FORALL (a: T, b: T) (a PRECEQ b) IFF (a SQCAP b = a)
%%   property FORALL (a: T, b: T) (a PRECEQ b) IFF (a SQCUP b = b)
%% end
\begin{Fortress}
\(\KWD{trait}\:\TYP{PartialOrderAndLattice}\llbracket\,\null\)\pushtabs\=\+\(T \KWD{extends}\:\TYP{PartialOrderLattice}\llbracket{}T,\preccurlyeq,\sqcap,\sqcup\rrbracket,\)\\
\(                              \KWD{opr} \mathord{\preccurlyeq}, \KWD{opr} \mathord{\sqcap}, \KWD{opr} \mathord{\sqcup}\rrbracket\)\-\\\poptabs
{\tt~~~~}\pushtabs\=\+\(    \KWD{extends} \{\,\TYP{PartialOrder}\llbracket{}T,\preccurlyeq\rrbracket, \TYP{Lattice}\llbracket{}T,\sqcap,\sqcup\rrbracket\,\}\)\-\\\poptabs
{\tt~~}\pushtabs\=\+\(  \KWD{property} \forall (a\COLON T, b\COLON T)\; (a \preccurlyeq b) \leftrightarrow (a \sqcap b = a)\)\\
\(  \KWD{property} \forall (a\COLON T, b\COLON T)\; (a \preccurlyeq b) \leftrightarrow (a \sqcup b = b)\)\-\\\poptabs
\(\KWD{end}\)
\end{Fortress}
\vskip-\lastskip
Every lattice defines a partial order, and every partial order defines a lattice.
This trait specifies that the type \VAR{T} provides the necessary operators to be regarded
as both a partial order and a lattice, states the properties that should relate
the partial-order behavior to the lattice behavior.  As an example, if the set of values
is the integers \EXP{\mathbb{Z}}, the partial order operator is \OPR{LEQ}, and the lattice operators
are \OPR{MIN} and \OPR{MAX}, then the requirements are that \EXP{a \OPR{LEQ}\:b} if and only if \EXP{a = a \OPR{MIN}\:b},
and that \EXP{a \OPR{LEQ}\:b} if and only if \EXP{b = a \OPR{MAX} b}.


%% trait PartialOrderAndMeetBoundedLattice[\T extends PartialOrderAndMeetBoundedLattice[\T,PRECEQ,SQCAP,SQCUP\],
%%                                          opr PRECEQ, opr SQCAP, opr SQCUP\]
%%     extends { PartialOrderAndLattice[\T,PRECEQ,SQCAP,SQCUP\],
%%               MeetBoundedLattice[\T,SQCAP,SQCUP\],
%%               HasMinimalElement[\T,PRECEQ\] }
%%     where { T coerces Identity[\SQCAP\], T coerces MaximalElement[\PRECEQ\] }
%%   property coerce_[\T\](Identity[\SQCAP\]) = coerce_[\T\](MaximalElement[\PRECEQ\])
%% end
\begin{Fortress}
\(\KWD{trait}\:\TYP{PartialOrderAndMeetBoundedLattice}\llbracket\,\null\)\pushtabs\=\+\(T \KWD{extends}\:\TYP{PartialOrderAndMeetBoundedLattice}\llbracket{}T,\preccurlyeq,\sqcap,\sqcup\rrbracket,\)\\
\(                                         \KWD{opr} \mathord{\preccurlyeq}, \KWD{opr} \mathord{\sqcap}, \KWD{opr} \mathord{\sqcup}\rrbracket\)\-\\\poptabs
{\tt~~~~}\pushtabs\=\+\(    \KWD{extends} \{\, \null\)\pushtabs\=\+\(\TYP{PartialOrderAndLattice}\llbracket{}T,\preccurlyeq,\sqcap,\sqcup\rrbracket,\)\\
\(              \TYP{MeetBoundedLattice}\llbracket{}T,\sqcap,\sqcup\rrbracket,\)\\
\(              \TYP{HasMinimalElement}\llbracket{}T,\preccurlyeq\rrbracket\,\}\)\-\\\poptabs
\(    \KWD{where} \{\,T \KWD{coerces}\:\TYP{Identity}\llbracket\sqcap\rrbracket, T \KWD{coerces}\:\TYP{MaximalElement}\llbracket\preccurlyeq\rrbracket\,\}\)\-\\\poptabs
{\tt~~}\pushtabs\=\+\(  \KWD{property}\:\mathrm{coerce}\llbracket{}T\rrbracket(\TYP{Identity}\llbracket\sqcap\rrbracket) = \mathrm{coerce}\llbracket{}T\rrbracket(\TYP{MaximalElement}\llbracket\preccurlyeq\rrbracket)\)\-\\\poptabs
\(\KWD{end}\)
\end{Fortress}
\vskip-\lastskip
The partial order associated with a meet-bounded lattice should have a maximal element,
which is the identity of the meet operator.


%% trait PartialOrderAndJoinBoundedLattice[\T extends PartialOrderAndJoinBoundedLattice[\T,PRECEQ,SQCAP,SQCUP\],
%%                                          opr PRECEQ, opr SQCAP, opr SQCUP\]
%%     extends { PartialOrderAndLattice[\T,PRECEQ,SQCAP,SQCUP\],
%%               JoinBoundedLattice[\T,SQCAP,SQCUP\],
%%               HasMaximalElement[\T,PRECEQ\] }
%%     where { T coerces Identity[\SQCUP\], T coerces MinimalElement[\PRECEQ\] }
%%   property coerce_[\T\](Identity[\SQCUP\]) = coerce_[\T\](MinimalElement[\PRECEQ\])
%% end
\begin{Fortress}
\(\KWD{trait}\:\TYP{PartialOrderAndJoinBoundedLattice}\llbracket\,\null\)\pushtabs\=\+\(T \KWD{extends}\:\TYP{PartialOrderAndJoinBoundedLattice}\llbracket{}T,\preccurlyeq,\sqcap,\sqcup\rrbracket,\)\\
\(                                         \KWD{opr} \mathord{\preccurlyeq}, \KWD{opr} \mathord{\sqcap}, \KWD{opr} \mathord{\sqcup}\rrbracket\)\-\\\poptabs
{\tt~~~~}\pushtabs\=\+\(    \KWD{extends} \{\, \null\)\pushtabs\=\+\(\TYP{PartialOrderAndLattice}\llbracket{}T,\preccurlyeq,\sqcap,\sqcup\rrbracket,\)\\
\(              \TYP{JoinBoundedLattice}\llbracket{}T,\sqcap,\sqcup\rrbracket,\)\\
\(              \TYP{HasMaximalElement}\llbracket{}T,\preccurlyeq\rrbracket\,\}\)\-\\\poptabs
\(    \KWD{where} \{\,T \KWD{coerces}\:\TYP{Identity}\llbracket\sqcup\rrbracket, T \KWD{coerces}\:\TYP{MinimalElement}\llbracket\preccurlyeq\rrbracket\,\}\)\-\\\poptabs
{\tt~~}\pushtabs\=\+\(  \KWD{property}\:\mathrm{coerce}\llbracket{}T\rrbracket(\TYP{Identity}\llbracket\sqcup\rrbracket) = \mathrm{coerce}\llbracket{}T\rrbracket(\TYP{MinimalElement}\llbracket\preccurlyeq\rrbracket)\)\-\\\poptabs
\(\KWD{end}\)
\end{Fortress}
\vskip-\lastskip
The partial order associated with a join-bounded lattice should have a minimal element,
which is the identity of the join operator.


%% trait PartialOrderAndBoundedLattice[\T extends PartialOrderAndBoundedLattice[\T,PRECEQ,SQCAP,SQCUP\],
%%                                      opr PRECEQ, opr SQCAP, opr SQCUP\]
%%     extends { PartialOrderAndMeetBoundedLattice[\T,PRECEQ,SQCAP,SQCUP\],
%%               PartialOrderAndJoinBoundedLattice[\T,PRECEQ,SQCAP,SQCUP\] }
%% end
\begin{Fortress}
\(\KWD{trait}\:\TYP{PartialOrderAndBoundedLattice}\llbracket\,\null\)\pushtabs\=\+\(T \KWD{extends}\:\TYP{PartialOrderAndBoundedLattice}\llbracket{}T,\preccurlyeq,\sqcap,\sqcup\rrbracket,\)\\
\(                                     \KWD{opr} \mathord{\preccurlyeq}, \KWD{opr} \mathord{\sqcap}, \KWD{opr} \mathord{\sqcup}\rrbracket\)\-\\\poptabs
{\tt~~~~}\pushtabs\=\+\(    \KWD{extends} \{\, \null\)\pushtabs\=\+\(\TYP{PartialOrderAndMeetBoundedLattice}\llbracket{}T,\preccurlyeq,\sqcap,\sqcup\rrbracket,\)\\
\(              \TYP{PartialOrderAndJoinBoundedLattice}\llbracket{}T,\preccurlyeq,\sqcap,\sqcup\rrbracket\,\}\)\-\-\\\poptabs\poptabs
\(\KWD{end}\)
\end{Fortress}
\vskip-\lastskip
The partial order associated with a bounded lattice should have both a minimal element
and a maximal element.



\section{Monoids, Groups, Rings, and Fields}
\seclabel{monoids-groups-rings-fields}

%trait ApproximateMonoid[\T extends ApproximateMonoid[\T,ODOT,APPROX\], opr ODOT, opr APPROX\]
%    extends { ApproximatelyAssociative[\T,ODOT,APPROX\], HasIdentity[\T,ODOT\] }
%    where { T coerces Identity[\ODOT\] }
%end
\begin{Fortress}
\(\KWD{trait}\:\TYP{ApproximateMonoid}\llbracket{}T \KWD{extends}\:\TYP{ApproximateMonoid}\llbracket{}T,\odot,\approx\rrbracket, \KWD{opr} \mathord{\odot}, \KWD{opr} \mathord{\approx}\rrbracket\)\\
{\tt~~~~}\pushtabs\=\+\(    \KWD{extends} \{\,\TYP{ApproximatelyAssociative}\llbracket{}T,\odot,\approx\rrbracket, \TYP{HasIdentity}\llbracket{}T,\odot\rrbracket\,\}\)\\
\(    \KWD{where} \{\,T \KWD{coerces}\:\TYP{Identity}\llbracket\odot\rrbracket\,\}\)\-\\\poptabs
\(\KWD{end}\)
\end{Fortress}
\vskip-\lastskip
An \emph{approximate monoid} is a set of values with an approximately associative binary operator \EXP{\odot}
that has an identity.
For example, floating-point multiplication has identity \EXP{1} and is approximately associative.


%trait Monoid[\T extends Monoid[\T,ODOT\], opr ODOT\]
%    extends { ApproximateMonoid[\T,ODOT,=\], Associative[\T,ODOT\] }
%    where { T coerces Identity[\ODOT\] }
%end
\begin{Fortress}
\(\KWD{trait}\:\TYP{Monoid}\llbracket{}T \KWD{extends}\:\TYP{Monoid}\llbracket{}T,\odot\rrbracket, \KWD{opr} \mathord{\odot}\rrbracket\)\\
{\tt~~~~}\pushtabs\=\+\(    \KWD{extends} \{\,\TYP{ApproximateMonoid}\llbracket{}T,\odot,=\rrbracket, \TYP{Associative}\llbracket{}T,\odot\rrbracket\,\}\)\\
\(    \KWD{where} \{\,T \KWD{coerces}\:\TYP{Identity}\llbracket\odot\rrbracket\,\}\)\-\\\poptabs
\(\KWD{end}\)
\end{Fortress}
\vskip-\lastskip
A \emph{monoid} is a set of values with an associative binary operator \EXP{\odot}
that has an identity.
For example, trait \TYP{String} extends \EXP{\TYP{Monoid}\llbracket\TYP{String},\|\rrbracket}
where \EXP{\|} is the string concatenation operator.  Note that string concatenation
is associative but not commutative and that the empty string is the identity for string concatenation,
so coercing \EXP{\TYP{Identity}\llbracket\,\|\,\rrbracket} to type \TYP{String} produces the
empty string.


%trait ApproximateCommutativeMonoid[\T extends ApproximateCommutativeMonoid[\T,OPLUS,APPROX\],
%                                    opr OPLUS, opr APPROX\]
%    extends { ApproximateMonoid[\T,OPLUS,APPROX\], ApproximatelyCommutative[\T,OPLUS,APPROX\] }
%    where { T coerces Identity[\OPLUS\] }
%end
\begin{Fortress}
\(\KWD{trait}\:\TYP{ApproximateCommutativeMonoid}\llbracket\,\null\)\pushtabs\=\+\(T \KWD{extends}\:\TYP{ApproximateCommutativeMonoid}\llbracket{}T,\oplus,\approx\rrbracket,\)\\
\(                                    \KWD{opr} \mathord{\oplus}, \KWD{opr} \mathord{\approx}\rrbracket\)\-\\\poptabs
{\tt~~~~}\pushtabs\=\+\(    \KWD{extends} \{\,\TYP{ApproximateMonoid}\llbracket{}T,\oplus,\approx\rrbracket, \TYP{ApproximatelyCommutative}\llbracket{}T,\oplus,\approx\rrbracket\,\}\)\\
\(    \KWD{where} \{\,T \KWD{coerces}\:\TYP{Identity}\llbracket\oplus\rrbracket\,\}\)\-\\\poptabs
\(\KWD{end}\)
\end{Fortress}
\vskip-\lastskip
An \emph{approximate commutative monoid} is an approximate monoid whose binary operator is also approximately commutative.
For example, floating-point multiplication has identity \EXP{1} and is approximately associative and also
approximately (indeed, exactly) commutative.


%trait CommutativeMonoid[\T extends CommutativeMonoid[\T,OPLUS\], opr OPLUS\]
%    extends { ApproximateCommutativeMonoid[\T,OPLUS,=\], Monoid[\T,OPLUS\], Commutative[\T,OPLUS\] }
%    where { T coerces Identity[\OPLUS\] }
%end
\begin{Fortress}
\(\KWD{trait}\:\TYP{CommutativeMonoid}\llbracket{}T \KWD{extends}\:\TYP{CommutativeMonoid}\llbracket{}T,\oplus\rrbracket, \KWD{opr} \mathord{\oplus}\rrbracket\)\\
{\tt~~~~}\pushtabs\=\+\(    \KWD{extends} \{\,\TYP{ApproximateCommutativeMonoid}\llbracket{}T,\oplus,=\rrbracket, \TYP{Monoid}\llbracket{}T,\oplus\rrbracket, \TYP{Commutative}\llbracket{}T,\oplus\rrbracket\,\}\)\\
\(    \KWD{where} \{\,T \KWD{coerces}\:\TYP{Identity}\llbracket\oplus\rrbracket\,\}\)\-\\\poptabs
\(\KWD{end}\)
\end{Fortress}
\vskip-\lastskip
A \emph{commutative monoid} is a monoid whose binary operator is also commutative.
For example, the operator \EXP{\wedge} on boolean values is associative and commutative and has identity \VAR{true};
likewise, the operator \EXP{\vee} on boolean values is associative and commutative and has identity \VAR{false}.


%trait ApproximateGroup[\T extends ApproximateGroup[\T,ODOT,OSLASH,APPROX\], opr ODOT, opr OSLASH, opr APPROX\]
%    extends { ApproximateMonoid[\T,ODOT,APPROX\], ApproximatelyHasInverses[\T,ODOT,OSLASH,APPROX\] }
%    where { T coerces Identity[\ODOT\] }
%end
\begin{Fortress}
\(\KWD{trait}\:\TYP{ApproximateGroup}\llbracket{}T \KWD{extends}\:\TYP{ApproximateGroup}\llbracket{}T,\odot,\oslash,\approx\rrbracket, \KWD{opr} \mathord{\odot}, \KWD{opr} \mathord{\oslash}, \KWD{opr} \mathord{\approx}\rrbracket\)\\
{\tt~~~~}\pushtabs\=\+\(    \KWD{extends} \{\,\TYP{ApproximateMonoid}\llbracket{}T,\odot,\approx\rrbracket, \TYP{ApproximatelyHasInverses}\llbracket{}T,\odot,\oslash,\approx\rrbracket\,\}\)\\
\(    \KWD{where} \{\,T \KWD{coerces}\:\TYP{Identity}\llbracket\odot\rrbracket\,\}\)\-\\\poptabs
\(\KWD{end}\)
\end{Fortress}
\vskip-\lastskip
An \emph{approximate group} is an approximate monoid that has approximate inverses.
For example, a floating-point representation of quaternions with multiplication
as the binary operator would form an approximate group.


%trait Group[\T extends Group[\T,ODOT,OSLASH\], opr ODOT, opr OSLASH\]
%    extends { ApproximateGroup[\T,ODOT,OSLASH,=\], Monoid[\T,ODOT\], HasInverses[\T,ODOT,OSLASH\] }
%    where { T coerces Identity[\ODOT\] }
%end
\begin{Fortress}
\(\KWD{trait}\:\TYP{Group}\llbracket{}T \KWD{extends}\:\TYP{Group}\llbracket{}T,\odot,\oslash\rrbracket, \KWD{opr} \mathord{\odot}, \KWD{opr} \mathord{\oslash}\rrbracket\)\\
{\tt~~~~}\pushtabs\=\+\(    \KWD{extends} \{\,\TYP{ApproximateGroup}\llbracket{}T,\odot,\oslash,=\rrbracket, \TYP{Monoid}\llbracket{}T,\odot\rrbracket, \TYP{HasInverses}\llbracket{}T,\odot,\oslash\rrbracket\,\}\)\\
\(    \KWD{where} \{\,T \KWD{coerces}\:\TYP{Identity}\llbracket\odot\rrbracket\,\}\)\-\\\poptabs
\(\KWD{end}\)
\end{Fortress}
\vskip-\lastskip
A \emph{group} is monoid that has inverses.


%trait ApproximateAbelianGroup[\T extends ApproximateAbelianGroup[\T,OPLUS,OMINUS,APPROX\],
%                               opr OPLUS, opr OMINUS, opr APPROX\]
%    extends { ApproximateGroup[\T,OPLUS,OMINUS,APPROX\],
%              ApproximateCommutativeMonoid[\T,OPLUS,APPROX\] }
%    where { T coerces Identity[\OPLUS\] }
%end
\begin{Fortress}
\(\KWD{trait}\:\TYP{ApproximateAbelianGroup}\llbracket\,\null\)\pushtabs\=\+\(T \KWD{extends}\:\TYP{ApproximateAbelianGroup}\llbracket{}T,\oplus,\ominus,\approx\rrbracket,\)\\
\(                               \KWD{opr} \mathord{\oplus}, \KWD{opr} \mathord{\ominus}, \KWD{opr} \mathord{\approx}\rrbracket\)\-\\\poptabs
{\tt~~~~}\pushtabs\=\+\(    \KWD{extends} \{\, \null\)\pushtabs\=\+\(\TYP{ApproximateGroup}\llbracket{}T,\oplus,\ominus,\approx\rrbracket,\)\\
\(              \TYP{ApproximateCommutativeMonoid}\llbracket{}T,\oplus,\approx\rrbracket\,\}\)\-\\\poptabs
\(    \KWD{where} \{\,T \KWD{coerces}\:\TYP{Identity}\llbracket\oplus\rrbracket\,\}\)\-\\\poptabs
\(\KWD{end}\)
\end{Fortress}
\vskip-\lastskip
An \emph{approximate Abelian group} is an approximate group whose binary operator is also approximately commutative.


%trait AbelianGroup[\T extends AbelianGroup[\T,OPLUS,OMINUS\], opr OPLUS, opr OMINUS\]
%    extends { ApproximateAbelianGroup[\T,OPLUS,OMINUS,=\],
%              Group[\T,OPLUS,OMINUS\], CommutativeMonoid[\T,OPLUS\] }
%    where { T coerces Identity[\OPLUS\] }
%end
\begin{Fortress}
\(\KWD{trait}\:\TYP{AbelianGroup}\llbracket{}T \KWD{extends}\:\TYP{AbelianGroup}\llbracket{}T,\oplus,\ominus\rrbracket, \KWD{opr} \mathord{\oplus}, \KWD{opr} \mathord{\ominus}\rrbracket\)\\
{\tt~~~~}\pushtabs\=\+\(    \KWD{extends} \{\, \null\)\pushtabs\=\+\(\TYP{ApproximateAbelianGroup}\llbracket{}T,\oplus,\ominus,=\rrbracket,\)\\
\(              \TYP{Group}\llbracket{}T,\oplus,\ominus\rrbracket, \TYP{CommutativeMonoid}\llbracket{}T,\oplus\rrbracket\,\}\)\-\\\poptabs
\(    \KWD{where} \{\,T \KWD{coerces}\:\TYP{Identity}\llbracket\oplus\rrbracket\,\}\)\-\\\poptabs
\(\KWD{end}\)
\end{Fortress}
\vskip-\lastskip
An \emph{Abelian group} is group whose binary operator is also commutative.
(The term ``Abelian'' is traditionally used instead of ``commutative'' when
discussing groups, in tribute to mathematician Niels Henrik Abel.)
For example, the integers with the binary addition operator \EXP{+},
unary negation operator \EXP{-}, and identity \EXP{0} form an Abelian group.
As another example, the boolean values with the binary exclusive \scap{or} operator \EXP{\oplus} and
unary negation operator \OPR{IDENTITY} form an Abelian group; the value \VAR{false} is the identity
for \EXP{\oplus}.


%trait ApproximateSemiRing[\T extends ApproximateSemiRing[\T,OPLUS,OTIMES,APPROX\],
%                           opr OPLUS, opr OTIMES, opr APPROX\]
%    extends { ApproximateCommutativeMonoid[\T,OPLUS,APPROX\],
%              ApproximateMonoid[\T,OTIMES,APPROX\],
%              ApproximatelyDistributive[\T,OTIMES,OPLUS,APPROX\],
%              ApproximateZeroAnnihilation[\T,OTIMES,APPROX\] }
%    where { T coerces Identity[\OPLUS\], T coerces Identity[\OTIMES\], T coerces Zero[\OTIMES\] }
%  property coerce_[\T\](Zero[\OTIMES\]) APPROX coerce_[\T\](Identity[\OPLUS\])
%end
\begin{Fortress}
\(\KWD{trait}\:\TYP{ApproximateSemiRing}\llbracket\,\null\)\pushtabs\=\+\(T \KWD{extends}\:\TYP{ApproximateSemiRing}\llbracket{}T,\oplus,\otimes,\approx\rrbracket,\)\\
\(                           \KWD{opr} \mathord{\oplus}, \KWD{opr} \mathord{\otimes}, \KWD{opr} \mathord{\approx}\rrbracket\)\-\\\poptabs
{\tt~~~~}\pushtabs\=\+\(    \KWD{extends} \{\, \null\)\pushtabs\=\+\(\TYP{ApproximateCommutativeMonoid}\llbracket{}T,\oplus,\approx\rrbracket,\)\\
\(              \TYP{ApproximateMonoid}\llbracket{}T,\otimes,\approx\rrbracket,\)\\
\(              \TYP{ApproximatelyDistributive}\llbracket{}T,\otimes,\oplus,\approx\rrbracket,\)\\
\(              \TYP{ApproximateZeroAnnihilation}\llbracket{}T,\otimes,\approx\rrbracket\,\}\)\-\\\poptabs
\(    \KWD{where} \{\,T \KWD{coerces}\:\TYP{Identity}\llbracket\oplus\rrbracket, T \KWD{coerces}\:\TYP{Identity}\llbracket\otimes\rrbracket, T \KWD{coerces}\:\TYP{Zero}\llbracket\otimes\rrbracket\,\}\)\-\\\poptabs
{\tt~~}\pushtabs\=\+\(  \KWD{property}\:\mathrm{coerce}\llbracket{}T\rrbracket(\TYP{Zero}\llbracket\otimes\rrbracket) \approx \mathrm{coerce}\llbracket{}T\rrbracket(\TYP{Identity}\llbracket\oplus\rrbracket)\)\-\\\poptabs
\(\KWD{end}\)
\end{Fortress}
\vskip-\lastskip
An \emph{approximate semiring} is a set of values that has two binary operators \EXP{\oplus} and \EXP{\otimes},
such that (a) the values form an approximate commutative monoid with \EXP{\oplus};
(b) the values form an approximate monoid with \EXP{\otimes};
(c) \EXP{\otimes} is approximately distributive over \EXP{\oplus}; and
(d) \EXP{\otimes} obeys approximate zero annihilation, where the zero
for \EXP{\otimes} is the same as the identity for \EXP{\oplus}.


%trait SemiRing[\T extends SemiRing[\T,OPLUS,OTIMES\], opr OPLUS, opr OTIMES\]
%    extends { ApproximateSemiRing[\T,OPLUS,OTIMES,=\],
%              CommutativeMonoid[\T,OPLUS\],
%              Monoid[\T,OTIMES\],
%              Distributive[\T,OTIMES,OPLUS\],
%              ZeroAnnihilation[\T,OTIMES\] }
%    where { T coerces Identity[\OPLUS\], T coerces Identity[\OTIMES\], T coerces Zero[\OTIMES\] }
%end
\begin{Fortress}
\(\KWD{trait}\:\TYP{SemiRing}\llbracket{}T \KWD{extends}\:\TYP{SemiRing}\llbracket{}T,\oplus,\otimes\rrbracket, \KWD{opr} \mathord{\oplus}, \KWD{opr} \mathord{\otimes}\rrbracket\)\\
{\tt~~~~}\pushtabs\=\+\(    \KWD{extends} \{\, \null\)\pushtabs\=\+\(\TYP{ApproximateSemiRing}\llbracket{}T,\oplus,\otimes,=\rrbracket,\)\\
\(              \TYP{CommutativeMonoid}\llbracket{}T,\oplus\rrbracket,\)\\
\(              \TYP{Monoid}\llbracket{}T,\otimes\rrbracket,\)\\
\(              \TYP{Distributive}\llbracket{}T,\otimes,\oplus\rrbracket,\)\\
\(              \TYP{ZeroAnnihilation}\llbracket{}T,\otimes\rrbracket\,\}\)\-\\\poptabs
\(    \KWD{where} \{\,T \KWD{coerces}\:\TYP{Identity}\llbracket\oplus\rrbracket, T \KWD{coerces}\:\TYP{Identity}\llbracket\otimes\rrbracket, T \KWD{coerces}\:\TYP{Zero}\llbracket\otimes\rrbracket\,\}\)\-\\\poptabs
\(\KWD{end}\)
\end{Fortress}
\vskip-\lastskip
A \emph{semiring} is a set of values that has two binary operators \EXP{\oplus} and \EXP{\otimes},
such that (a) the values form a commutative monoid with \EXP{\oplus};
(b) the values form a monoid with \EXP{\otimes};
(c) \EXP{\otimes} is distributive over \EXP{\oplus}; and
(d) \EXP{\otimes} obeys zero annihilation, where the zero
for \EXP{\otimes} is the same as the identity for \EXP{\oplus}.


%trait ApproximateRing[\T extends ApproximateRing[\T,OPLUS,OMINUS,OTIMES,APPROX\],
%                       opr OPLUS, opr OMINUS, opr OTIMES, opr APPROX\]
%    extends { ApproximateAbelianGroup[\T,OPLUS,OMINUS,APPROX\],
%              ApproximateSemiRing[\T,OPLUS,OTIMES,APPROX\] }
%    where { T coerces Identity[\OPLUS\], T coerces Identity[\OTIMES\], T coerces Zero[\OTIMES\] }
%end
\begin{Fortress}
\(\KWD{trait}\:\TYP{ApproximateRing}\llbracket\,\null\)\pushtabs\=\+\(T \KWD{extends}\:\TYP{ApproximateRing}\llbracket{}T,\oplus,\ominus,\otimes,\approx\rrbracket,\)\\
\(                       \KWD{opr} \mathord{\oplus}, \KWD{opr} \mathord{\ominus}, \KWD{opr} \mathord{\otimes}, \KWD{opr} \mathord{\approx}\rrbracket\)\-\\\poptabs
{\tt~~~~}\pushtabs\=\+\(    \KWD{extends} \{\, \null\)\pushtabs\=\+\(\TYP{ApproximateAbelianGroup}\llbracket{}T,\oplus,\ominus,\approx\rrbracket,\)\\
\(              \TYP{ApproximateSemiRing}\llbracket{}T,\oplus,\otimes,\approx\rrbracket\,\}\)\-\\\poptabs
\(    \KWD{where} \{\,T \KWD{coerces}\:\TYP{Identity}\llbracket\oplus\rrbracket, T \KWD{coerces}\:\TYP{Identity}\llbracket\otimes\rrbracket, T \KWD{coerces}\:\TYP{Zero}\llbracket\otimes\rrbracket\,\}\)\-\\\poptabs
\(\KWD{end}\)
\end{Fortress}
\vskip-\lastskip
An \emph{approximate ring} is an approximate semiring that also has
a unary operator \EXP{\ominus} that returns inverses for the \EXP{\oplus} operator
so that the values form an approximate group with \EXP{\oplus} and \EXP{\ominus}.


%trait Ring[\T extends Ring[\T,OPLUS,OMINUS,OTIMES\], opr OPLUS, opr OMINUS, opr OTIMES\]
%    extends { ApproximateRing[\T,OPLUS,OMINUS,OTIMES,=\],
%              AbelianGroup[\T,OPLUS,OMINUS\],
%              SemiRing[\T,OPLUS,OTIMES\] }
%    where { T coerces Identity[\OPLUS\], T coerces Identity[\OTIMES\], T coerces Zero[\OTIMES\] }
%end
\begin{Fortress}
\(\KWD{trait}\:\TYP{Ring}\llbracket{}T \KWD{extends}\:\TYP{Ring}\llbracket{}T,\oplus,\ominus,\otimes\rrbracket, \KWD{opr} \mathord{\oplus}, \KWD{opr} \mathord{\ominus}, \KWD{opr} \mathord{\otimes}\rrbracket\)\\
{\tt~~~~}\pushtabs\=\+\(    \KWD{extends} \{\, \null\)\pushtabs\=\+\(\TYP{ApproximateRing}\llbracket{}T,\oplus,\ominus,\otimes,=\rrbracket,\)\\
\(              \TYP{AbelianGroup}\llbracket{}T,\oplus,\ominus\rrbracket,\)\\
\(              \TYP{SemiRing}\llbracket{}T,\oplus,\otimes\rrbracket\,\}\)\-\\\poptabs
\(    \KWD{where} \{\,T \KWD{coerces}\:\TYP{Identity}\llbracket\oplus\rrbracket, T \KWD{coerces}\:\TYP{Identity}\llbracket\otimes\rrbracket, T \KWD{coerces}\:\TYP{Zero}\llbracket\otimes\rrbracket\,\}\)\-\\\poptabs
\(\KWD{end}\)
\end{Fortress}
\vskip-\lastskip
A \emph{ring} is a semiring that also has
a unary operator \EXP{\ominus} that returns inverses for the \EXP{\oplus} operator
so that the values form a group with \EXP{\oplus} and \EXP{\ominus}.


%trait ApproximateCommutativeRing[\T extends ApproximateCommutativeRing[\T,OPLUS,OMINUS,OTIMES,APPROX\],
%                                  opr OPLUS, opr OMINUS, opr OTIMES, opr APPROX\]
%    extends { ApproximateRing[\T,OPLUS,OMINUS,OTIMES,APPROX\],
%              ApproximateCommutativeMonoid[\T,OTIMES,APPROX\] }
%    where { T coerces Identity[\OPLUS\], T coerces Identity[\OTIMES\], T coerces Zero[\OTIMES\] }
%end
\begin{Fortress}
\(\KWD{trait}\:\TYP{ApproximateCommutativeRing}\llbracket\,\null\)\pushtabs\=\+\(T \KWD{extends}\:\TYP{ApproximateCommutativeRing}\llbracket{}T,\oplus,\ominus,\otimes,\approx\rrbracket,\)\\
\(                                  \KWD{opr} \mathord{\oplus}, \KWD{opr} \mathord{\ominus}, \KWD{opr} \mathord{\otimes}, \KWD{opr} \mathord{\approx}\rrbracket\)\-\\\poptabs
{\tt~~~~}\pushtabs\=\+\(    \KWD{extends} \{\, \null\)\pushtabs\=\+\(\TYP{ApproximateRing}\llbracket{}T,\oplus,\ominus,\otimes,\approx\rrbracket,\)\\
\(              \TYP{ApproximateCommutativeMonoid}\llbracket{}T,\otimes,\approx\rrbracket\,\}\)\-\\\poptabs
\(    \KWD{where} \{\,T \KWD{coerces}\:\TYP{Identity}\llbracket\oplus\rrbracket, T \KWD{coerces}\:\TYP{Identity}\llbracket\otimes\rrbracket, T \KWD{coerces}\:\TYP{Zero}\llbracket\otimes\rrbracket\,\}\)\-\\\poptabs
\(\KWD{end}\)
\end{Fortress}
\vskip-\lastskip
An \emph{approximate commutative ring} is an approximate ring for which the
binary operator \EXP{\otimes} is also approximately commutative.


%trait CommutativeRing[\T extends CommutativeRing[\T,OPLUS,OMINUS,OTIMES\],
%                       opr OPLUS, opr OMINUS, opr OTIMES\]
%    extends { ApproximateCommutativeRing[\T,OPLUS,OMINUS,OTIMES,=\],
%              Ring[\T,OPLUS,OMINUS,OTIMES\],
%              CommutativeMonoid[\T,OTIMES\] }
%    where { T coerces Identity[\OPLUS\], T coerces Identity[\OTIMES\], T coerces Zero[\OTIMES\] }
%end
\begin{Fortress}
\(\KWD{trait}\:\TYP{CommutativeRing}\llbracket\,\null\)\pushtabs\=\+\(T \KWD{extends}\:\TYP{CommutativeRing}\llbracket{}T,\oplus,\ominus,\otimes\rrbracket,\)\\
\(                       \KWD{opr} \mathord{\oplus}, \KWD{opr} \mathord{\ominus}, \KWD{opr} \mathord{\otimes}\rrbracket\)\-\\\poptabs
{\tt~~~~}\pushtabs\=\+\(    \KWD{extends} \{\, \null\)\pushtabs\=\+\(\TYP{ApproximateCommutativeRing}\llbracket{}T,\oplus,\ominus,\otimes,=\rrbracket,\)\\
\(              \TYP{Ring}\llbracket{}T,\oplus,\ominus,\otimes\rrbracket,\)\\
\(              \TYP{CommutativeMonoid}\llbracket{}T,\otimes\rrbracket\,\}\)\-\\\poptabs
\(    \KWD{where} \{\,T \KWD{coerces}\:\TYP{Identity}\llbracket\oplus\rrbracket, T \KWD{coerces}\:\TYP{Identity}\llbracket\otimes\rrbracket, T \KWD{coerces}\:\TYP{Zero}\llbracket\otimes\rrbracket\,\}\)\-\\\poptabs
\(\KWD{end}\)
\end{Fortress}
\vskip-\lastskip
A \emph{commutative ring} is a ring for which the binary operator \EXP{\otimes} is also commutative.


%trait ApproximateMathematicalDomain[\T extends ApproximateRing[\T,OPLUS,OMINUS,OTIMES,APPROX\],
%                                     opr OPLUS, opr OMINUS, opr OTIMES, opr APPROX\]
%    extends { ApproximateRing[\T,OPLUS,OMINUS,OTIMES,APPROX\],
%              NoApproximateZeroDivisors[\T,OTIMES,APPROX\] }
%    where { T coerces Identity[\OPLUS\], T coerces Identity[\OTIMES\], T coerces Zero[\OTIMES\] }
%end
\begin{Fortress}
\(\KWD{trait}\:\TYP{ApproximateMathematicalDomain}\llbracket\,\null\)\pushtabs\=\+\(T \KWD{extends}\:\TYP{ApproximateRing}\llbracket{}T,\oplus,\ominus,\otimes,\approx\rrbracket,\)\\
\(                                     \KWD{opr} \mathord{\oplus}, \KWD{opr} \mathord{\ominus}, \KWD{opr} \mathord{\otimes}, \KWD{opr} \mathord{\approx}\rrbracket\)\-\\\poptabs
{\tt~~~~}\pushtabs\=\+\(    \KWD{extends} \{\, \null\)\pushtabs\=\+\(\TYP{ApproximateRing}\llbracket{}T,\oplus,\ominus,\otimes,\approx\rrbracket,\)\\
\(              \TYP{NoApproximateZeroDivisors}\llbracket{}T,\otimes,\approx\rrbracket\,\}\)\-\\\poptabs
\(    \KWD{where} \{\,T \KWD{coerces}\:\TYP{Identity}\llbracket\oplus\rrbracket, T \KWD{coerces}\:\TYP{Identity}\llbracket\otimes\rrbracket, T \KWD{coerces}\:\TYP{Zero}\llbracket\otimes\rrbracket\,\}\)\-\\\poptabs
\(\KWD{end}\)
\end{Fortress}
\vskip-\lastskip
An \emph{approximate mathematical domain} is an approximate ring that has
no approximate zero divisors.


%trait MathematicalDomain[\T extends Ring[\T,OPLUS,OMINUS,OTIMES\],
%                          opr OPLUS, opr OMINUS, opr OTIMES\]
%    extends { ApproximateMathematicalDomain[\T,OPLUS,OMINUS,OTIMES,=\],
%              Ring[\T,OPLUS,OMINUS,OTIMES\],
%              NoZeroDivisors[\T,OTIMES\] }
%    where { T coerces Identity[\OPLUS\], T coerces Identity[\OTIMES\], T coerces Zero[\OTIMES\] }
%end
\begin{Fortress}
\(\KWD{trait}\:\TYP{MathematicalDomain}\llbracket\,\null\)\pushtabs\=\+\(T \KWD{extends}\:\TYP{Ring}\llbracket{}T,\oplus,\ominus,\otimes\rrbracket,\)\\
\(                          \KWD{opr} \mathord{\oplus}, \KWD{opr} \mathord{\ominus}, \KWD{opr} \mathord{\otimes}\rrbracket\)\-\\\poptabs
{\tt~~~~}\pushtabs\=\+\(    \KWD{extends} \{\, \null\)\pushtabs\=\+\(\TYP{ApproximateMathematicalDomain}\llbracket{}T,\oplus,\ominus,\otimes,=\rrbracket,\)\\
\(              \TYP{Ring}\llbracket{}T,\oplus,\ominus,\otimes\rrbracket,\)\\
\(              \TYP{NoZeroDivisors}\llbracket{}T,\otimes\rrbracket\,\}\)\-\\\poptabs
\(    \KWD{where} \{\,T \KWD{coerces}\:\TYP{Identity}\llbracket\oplus\rrbracket, T \KWD{coerces}\:\TYP{Identity}\llbracket\otimes\rrbracket, T \KWD{coerces}\:\TYP{Zero}\llbracket\otimes\rrbracket\,\}\)\-\\\poptabs
\(\KWD{end}\)
\end{Fortress}
\vskip-\lastskip
A \emph{mathematical domain} is a ring that has no zero divisors.  (In mathematics,
this is called simply a \emph{domain}.  In Fortress, the term ``mathematical domain''
is used instead to avoid consuming this word for a concept that
admittedly is used rarely in programming when compared with other
common single words such as``ring'' and ``field.'')


%trait ApproximateIntegralDomain[\T extends ApproximateRing[\T,OPLUS,OMINUS,OTIMES,APPROX\],
%                                 opr OPLUS, opr OMINUS, opr OTIMES, opr APPROX\]
%    extends { ApproximateMathematicalDomain[\T,OPLUS,OMINUS,OTIMES,APPROX\],
%              ApproximateCommutativeRing[\T,OPLUS,OMINUS,OTIMES,APPROX\] }
%    where { T coerces Identity[\OPLUS\], T coerces Identity[\OTIMES\], T coerces Zero[\OTIMES\] }
%end
\begin{Fortress}
\(\KWD{trait}\:\TYP{ApproximateIntegralDomain}\llbracket\,\null\)\pushtabs\=\+\(T \KWD{extends}\:\TYP{ApproximateRing}\llbracket{}T,\oplus,\ominus,\otimes,\approx\rrbracket,\)\\
\(                                 \KWD{opr} \mathord{\oplus}, \KWD{opr} \mathord{\ominus}, \KWD{opr} \mathord{\otimes}, \KWD{opr} \mathord{\approx}\rrbracket\)\-\\\poptabs
{\tt~~~~}\pushtabs\=\+\(    \KWD{extends} \{\, \null\)\pushtabs\=\+\(\TYP{ApproximateMathematicalDomain}\llbracket{}T,\oplus,\ominus,\otimes,\approx\rrbracket,\)\\
\(              \TYP{ApproximateCommutativeRing}\llbracket{}T,\oplus,\ominus,\otimes,\approx\rrbracket\,\}\)\-\\\poptabs
\(    \KWD{where} \{\,T \KWD{coerces}\:\TYP{Identity}\llbracket\oplus\rrbracket, T \KWD{coerces}\:\TYP{Identity}\llbracket\otimes\rrbracket, T \KWD{coerces}\:\TYP{Zero}\llbracket\otimes\rrbracket\,\}\)\-\\\poptabs
\(\KWD{end}\)
\end{Fortress}
\vskip-\lastskip
An \emph{approximate integral domain} is an approximate mathematical domain
for which the binary operator \EXP{\otimes} is also approximately commutative.


%trait IntegralDomain[\T extends Ring[\T,OPLUS,OMINUS,OTIMES\],
%                      opr OPLUS, opr OMINUS, opr OTIMES\]
%    extends { ApproximateIntegralDomain[\T,OPLUS,OMINUS,OTIMES,=\],
%              MathematicalDomain[\T,OPLUS,OMINUS,OTIMES\],
%              CommutativeRing[\T,OPLUS,OMINUS,OTIMES\] }
%    where { T coerces Identity[\OPLUS\], T coerces Identity[\OTIMES\], T coerces Zero[\OTIMES\] }
%end
\begin{Fortress}
\(\KWD{trait}\:\TYP{IntegralDomain}\llbracket\,\null\)\pushtabs\=\+\(T \KWD{extends}\:\TYP{Ring}\llbracket{}T,\oplus,\ominus,\otimes\rrbracket,\)\\
\(                      \KWD{opr} \mathord{\oplus}, \KWD{opr} \mathord{\ominus}, \KWD{opr} \mathord{\otimes}\rrbracket\)\-\\\poptabs
{\tt~~~~}\pushtabs\=\+\(    \KWD{extends} \{\, \null\)\pushtabs\=\+\(\TYP{ApproximateIntegralDomain}\llbracket{}T,\oplus,\ominus,\otimes,=\rrbracket,\)\\
\(              \TYP{MathematicalDomain}\llbracket{}T,\oplus,\ominus,\otimes\rrbracket,\)\\
\(              \TYP{CommutativeRing}\llbracket{}T,\oplus,\ominus,\otimes\rrbracket\,\}\)\-\\\poptabs
\(    \KWD{where} \{\,T \KWD{coerces}\:\TYP{Identity}\llbracket\oplus\rrbracket, T \KWD{coerces}\:\TYP{Identity}\llbracket\otimes\rrbracket, T \KWD{coerces}\:\TYP{Zero}\llbracket\otimes\rrbracket\,\}\)\-\\\poptabs
\(\KWD{end}\)
\end{Fortress}
\vskip-\lastskip
An \emph{integral domain} is a mathematical domain
for which the binary operator \EXP{\otimes} is also commutative.


%trait ApproximateDivisionRing[\T extends ApproximateDivisionRing[\T,U,OPLUS,OMINUS,OTIMES,OSLASH,APPROX\],
%                               U extends T,
%                               opr OPLUS, opr OMINUS, opr OTIMES, opr OSLASH, opr APPROX\]
%    extends { ApproximateMathematicalDomain[\T,OPLUS,OMINUS,OTIMES,APPROX\],
%              ApproximateGroup[\U,OTIMES,OSLASH,APPROX\] }
%    where { T coerces Identity[\OPLUS\], T coerces Identity[\OTIMES\], T coerces Zero[\OTIMES\] }
%  property NOT instanceOf[\U\](coerce_[\T\](Zero[\OPLUS\]))
%  property FORALL (a: T) a NE Zero[\OPLUS\] IMPLIES instanceOf[\U\](a)
%end
\begin{Fortress}
\(\KWD{trait}\:\TYP{ApproximateDivisionRing}\llbracket\,\null\)\pushtabs\=\+\(T \KWD{extends}\:\TYP{ApproximateDivisionRing}\llbracket{}T,U,\oplus,\ominus,\otimes,\oslash,\approx\rrbracket,\)\\
\(                               U \KWD{extends}\:T,\)\\
\(                               \KWD{opr} \mathord{\oplus}, \KWD{opr} \mathord{\ominus}, \KWD{opr} \mathord{\otimes}, \KWD{opr} \mathord{\oslash}, \KWD{opr} \mathord{\approx}\rrbracket\)\-\\\poptabs
{\tt~~~~}\pushtabs\=\+\(    \KWD{extends} \{\, \null\)\pushtabs\=\+\(\TYP{ApproximateMathematicalDomain}\llbracket{}T,\oplus,\ominus,\otimes,\approx\rrbracket,\)\\
\(              \TYP{ApproximateGroup}\llbracket{}U,\otimes,\oslash,\approx\rrbracket\,\}\)\-\\\poptabs
\(    \KWD{where} \{\,T \KWD{coerces}\:\TYP{Identity}\llbracket\oplus\rrbracket, T \KWD{coerces}\:\TYP{Identity}\llbracket\otimes\rrbracket, T \KWD{coerces}\:\TYP{Zero}\llbracket\otimes\rrbracket\,\}\)\-\\\poptabs
{\tt~~}\pushtabs\=\+\(  \KWD{property} \neg \VAR{instanceOf}\llbracket{}U\rrbracket(\mathrm{coerce}\llbracket{}T\rrbracket(\TYP{Zero}\llbracket\oplus\rrbracket))\)\\
\(  \KWD{property} \forall (a\COLON T)\; a \neq \TYP{Zero}\llbracket\oplus\rrbracket \rightarrow \VAR{instanceOf}\llbracket{}U\rrbracket(a)\)\-\\\poptabs
\(\KWD{end}\)
\end{Fortress}
\vskip-\lastskip
An \emph{approximate division ring} is an approximate ring for which the
binary operator \EXP{\otimes} also has approximate inverses, so that
the values other than the zero of \EXP{\otimes} form an approximate group with \EXP{\otimes} and \EXP{\oslash}.
An approximate division ring is in fact also an approximate mathematical domain.


%trait DivisionRing[\T extends DivisionRing[\T,U,OPLUS,OMINUS,OTIMES,OSLASH\],
%                    U extends T,
%                    opr OPLUS, opr OMINUS, opr OTIMES, opr OSLASH\]
%    extends { ApproximateDivisionRing[\T,U,OPLUS,OMINUS,OTIMES,OSLASH,=\],
%              MathematicalDomain[\T,OPLUS,OMINUS,OTIMES,APPROX\],
%              Group[\U,OTIMES,OSLASH\] }
%    where { T coerces Identity[\OPLUS\], T coerces Identity[\OTIMES\], T coerces Zero[\OTIMES\] }
%end
\begin{Fortress}
\(\KWD{trait}\:\TYP{DivisionRing}\llbracket\,\null\)\pushtabs\=\+\(T \KWD{extends}\:\TYP{DivisionRing}\llbracket{}T,U,\oplus,\ominus,\otimes,\oslash\rrbracket,\)\\
\(                    U \KWD{extends}\:T,\)\\
\(                    \KWD{opr} \mathord{\oplus}, \KWD{opr} \mathord{\ominus}, \KWD{opr} \mathord{\otimes}, \KWD{opr} \mathord{\oslash}\rrbracket\)\-\\\poptabs
{\tt~~~~}\pushtabs\=\+\(    \KWD{extends} \{\, \null\)\pushtabs\=\+\(\TYP{ApproximateDivisionRing}\llbracket{}T,U,\oplus,\ominus,\otimes,\oslash,=\rrbracket,\)\\
\(              \TYP{MathematicalDomain}\llbracket{}T,\oplus,\ominus,\otimes,\approx\rrbracket,\)\\
\(              \TYP{Group}\llbracket{}U,\otimes,\oslash\rrbracket\,\}\)\-\\\poptabs
\(    \KWD{where} \{\,T \KWD{coerces}\:\TYP{Identity}\llbracket\oplus\rrbracket, T \KWD{coerces}\:\TYP{Identity}\llbracket\otimes\rrbracket, T \KWD{coerces}\:\TYP{Zero}\llbracket\otimes\rrbracket\,\}\)\-\\\poptabs
\(\KWD{end}\)
\end{Fortress}
\vskip-\lastskip
A \emph{division ring} is a ring for which the
binary operator \EXP{\otimes} also has inverses, so that
the values other than the zero of \EXP{\otimes} form a group with \EXP{\otimes} and \EXP{\oslash}.
A division ring is in fact also a mathematical domain.


%trait ApproximateField[\T extends ApproximateField[\T,U,OPLUS,OMINUS,OTIMES,OSLASH,APPROX\],
%                        U extends T,
%                        opr OPLUS, opr OMINUS, opr OTIMES, opr OSLASH, opr APPROX\]
%    extends { ApproximateIntegralDomain[\T,OPLUS,OMINUS,OTIMES,APPROX\],
%              ApproximateDivisionRing[\T,U,OPLUS,OMINUS,OTIMES,OSLASH,APPROX\],
%              ApproximateAbelianGroup[\T,OTIMES,OSLASH,APPROX\] }
%    where { T coerces Identity[\OPLUS\], T coerces Identity[\OTIMES\], T coerces Zero[\OTIMES\] }
%end
\begin{Fortress}
\(\KWD{trait}\:\TYP{ApproximateField}\llbracket\,\null\)\pushtabs\=\+\(T \KWD{extends}\:\TYP{ApproximateField}\llbracket{}T,U,\oplus,\ominus,\otimes,\oslash,\approx\rrbracket,\)\\
\(                        U \KWD{extends}\:T,\)\\
\(                        \KWD{opr} \mathord{\oplus}, \KWD{opr} \mathord{\ominus}, \KWD{opr} \mathord{\otimes}, \KWD{opr} \mathord{\oslash}, \KWD{opr} \mathord{\approx}\rrbracket\)\-\\\poptabs
{\tt~~~~}\pushtabs\=\+\(    \KWD{extends} \{\, \null\)\pushtabs\=\+\(\TYP{ApproximateIntegralDomain}\llbracket{}T,\oplus,\ominus,\otimes,\approx\rrbracket,\)\\
\(              \TYP{ApproximateDivisionRing}\llbracket{}T,U,\oplus,\ominus,\otimes,\oslash,\approx\rrbracket,\)\\
\(              \TYP{ApproximateAbelianGroup}\llbracket{}T,\otimes,\oslash,\approx\rrbracket\,\}\)\-\\\poptabs
\(    \KWD{where} \{\,T \KWD{coerces}\:\TYP{Identity}\llbracket\oplus\rrbracket, T \KWD{coerces}\:\TYP{Identity}\llbracket\otimes\rrbracket, T \KWD{coerces}\:\TYP{Zero}\llbracket\otimes\rrbracket\,\}\)\-\\\poptabs
\(\KWD{end}\)
\end{Fortress}
\vskip-\lastskip
An \emph{approximate field} is an approximately commutative ring that is also an
approximate division ring: the binary operator \EXP{\otimes} is approximately
commutative and also has approximate inverses, so that the values other than
the zero of \EXP{\otimes} form an approximate Abelian group with \EXP{\otimes} and \EXP{\oslash}.
An approximate field is in fact also an approximate integral domain.


%trait Field[\T extends Field[\T,U,OPLUS,OMINUS,OTIMES,OSLASH\], U extends T, opr OPLUS, opr OMINUS, opr OTIMES, opr OSLASH\]
%    extends { ApproximateField[\T,U,OPLUS,OMINUS,OTIMES,OSLASH,=\],
%              IntegralDomain[\T,OPLUS,OMINUS,OTIMES\],
%              DivisionRing[\T,U,OPLUS,OMINUS,OTIMES,OSLASH\],
%              AbelianGroup[\U,OTIMES,OSLASH\] }
%    where { T coerces Identity[\OPLUS\], T coerces Identity[\OTIMES\], T coerces Zero[\OTIMES\] }
%end
\begin{Fortress}
\(\KWD{trait}\:\TYP{Field}\llbracket{}T \KWD{extends}\:\TYP{Field}\llbracket{}T,U,\oplus,\ominus,\otimes,\oslash\rrbracket, U \KWD{extends}\:T, \KWD{opr} \mathord{\oplus}, \KWD{opr} \mathord{\ominus}, \KWD{opr} \mathord{\otimes}, \KWD{opr} \mathord{\oslash}\rrbracket\)\\
{\tt~~~~}\pushtabs\=\+\(    \KWD{extends} \{\, \null\)\pushtabs\=\+\(\TYP{ApproximateField}\llbracket{}T,U,\oplus,\ominus,\otimes,\oslash,=\rrbracket,\)\\
\(              \TYP{IntegralDomain}\llbracket{}T,\oplus,\ominus,\otimes\rrbracket,\)\\
\(              \TYP{DivisionRing}\llbracket{}T,U,\oplus,\ominus,\otimes,\oslash\rrbracket,\)\\
\(              \TYP{AbelianGroup}\llbracket{}U,\otimes,\oslash\rrbracket\,\}\)\-\\\poptabs
\(    \KWD{where} \{\,T \KWD{coerces}\:\TYP{Identity}\llbracket\oplus\rrbracket, T \KWD{coerces}\:\TYP{Identity}\llbracket\otimes\rrbracket, T \KWD{coerces}\:\TYP{Zero}\llbracket\otimes\rrbracket\,\}\)\-\\\poptabs
\(\KWD{end}\)
\end{Fortress}
\vskip-\lastskip
A \emph{field} is a commutative ring that is also a division ring: the binary
operator \EXP{\otimes} is commutative and also has inverses, so that the values
other than the zero of \EXP{\otimes} form an Abelian group with \EXP{\otimes} and \EXP{\oslash}.
A field is in fact also an integral domain.


\section{Boolean Algebras}


%value object ComplementBound[\opr ODOT\] end
%
%trait HasComplements[\T extends HasComplements[\T,ODOT,SIM\], opr ODOT, opr SIM\]
%    extends { BinaryOperator[\T,ODOT\], UnaryOperator[\T,SIM\], EquivalenceRelation[\T,=\] }
%    where { T coerces ComplementBound[\ODOT\] }
%  property FORALL (a: T) (a ODOT (SIM a)) :=: ComplementBound[\ODOT\]
%end
\begin{Fortress}
\(\KWD{value}\;\;\KWD{object}\:\TYP{ComplementBound}\llbracket\KWD{opr} \mathord{\odot}\rrbracket \KWD{end}\)\\[4pt]
\(\KWD{trait}\:\TYP{HasComplements}\llbracket{}T \KWD{extends}\:\TYP{HasComplements}\llbracket{}T,\odot,\sim\rrbracket, \KWD{opr} \mathord{\odot}, \KWD{opr} \mathord{\sim}\rrbracket\)\\
{\tt~~~~}\pushtabs\=\+\(    \KWD{extends} \{\,\TYP{BinaryOperator}\llbracket{}T,\odot\rrbracket, \TYP{UnaryOperator}\llbracket{}T,\sim\rrbracket, \TYP{EquivalenceRelation}\llbracket{}T,=\rrbracket\,\}\)\\
\(    \KWD{where} \{\,T \KWD{coerces}\:\TYP{ComplementBound}\llbracket\odot\rrbracket\,\}\)\-\\\poptabs
{\tt~~}\pushtabs\=\+\(  \KWD{property} \forall (a\COLON T)\; (a \odot (\sim\:{a})) \CONDEQ\:\TYP{ComplementBound}\llbracket\odot\rrbracket\)\-\\\poptabs
\(\KWD{end}\)
\end{Fortress}
\vskip-\lastskip
A set of values with a binary operator \EXP{\odot} has \emph{complements} if and only if
there is a specific value \VAR{e} such that for every value \VAR{a} there is another value \EXP{a'}
such that the result of applying \EXP{\odot} to \VAR{a} and \EXP{a'} (in either order) equals the specified value \VAR{e}.
This value may be obtained by coercing the object named \EXP{\TYP{ComplementBound}\llbracket\odot\rrbracket} to type \VAR{T}.
The unary operator \EXP{\sim} returns the complement of its argument with respect to the operator \EXP{\odot}.

Note that the trait \TYP{HasComplements} is similar to the trait \TYP{HasInverses},
but \TYP{HasComplements} does not require that that specified element be an identity
of the binary operator.


%trait DeMorgan[\T extends DeMorgan[\T,CURLYAND,CURLYOR,SIM\], opr CURLYAND, opr CURLYOR, opr SIM\]
%    extends { BinaryOperator[\T,CURLYAND\], BinaryOperator[\T,CURLYOR\],
%              UnaryOperator[\T,SIM\], EquivalenceRelation[\T,=\] }
%  property FORALL (a: T, b: T) (SIM (a CURLYOR b)) :=: ((SIM a) CURLYAND (SIM b))
%end
\begin{Fortress}
\(\KWD{trait} \TYP{DeMorgan}\llbracket{}T \KWD{extends} \TYP{DeMorgan}\llbracket{}T,\curlywedge,\curlyvee,\sim\rrbracket, \KWD{opr} \mathord{\curlywedge}, \KWD{opr} \mathord{\curlyvee}, \KWD{opr} \mathord{\sim}\rrbracket\)\\
{\tt~~~~}\pushtabs\=\+\(    \KWD{extends} \{\,\null\)\pushtabs\=\+\(\TYP{BinaryOperator}\llbracket{}T,\curlywedge\rrbracket, \TYP{BinaryOperator}\llbracket{}T,\curlyvee\rrbracket,\)\\
\(              \TYP{UnaryOperator}\llbracket{}T,\sim\rrbracket, \TYP{EquivalenceRelation}\llbracket{}T,=\rrbracket\,\}\)\-\-\\\poptabs\poptabs
{\tt~~}\pushtabs\=\+\(  \KWD{property} \forall (a\COLON T, b\COLON T)\; (\sim (a \curlyvee b)) \ASSIGN\COLON ((\sim a) \curlywedge (\sim b))\)\-\\\poptabs
\(\KWD{end}\)
\end{Fortress}
\vskip-\lastskip
This trait expresses De Morgan's law for two binary operators \EXP{\curlywedge} and \EXP{\curlyvee}
and a unary operator \EXP{\sim}: the expressions \EXP{\sim (a \curlyvee b)} and \EXP{(\sim a) \curlywedge (\sim b)}
produce equal results.


%trait BooleanAlgebra[\T extends BooleanAlgebra[\T,CURLYAND,CURLYOR,SIM,XOR\], opr CURLYAND, opr CURLYOR, opr SIM, opr XOR\]
%    extends { Commutative[\T,CURLYAND\], Associative[\T,CURLYAND\],
%              Commutative[\T,CURLYOR\], Associative[\T,CURLYOR\],
%              IdempotentBinaryOperator[\T,CURLYAND\],
%              IdempotentBinaryOperator[\T,CURLYOR\],
%              HasIdentity[\T,CURLYAND\], HasIdentity[\T,CURLYOR\],
%              HasComplements[\T,CURLYOR,SIM\], HasComplements[\T,CURLYAND,SIM\],
%              Distributive[\T,CURLYAND,CURLYOR\], Distributive[\T,CURLYOR,CURLYAND\],
%              DeMorgan[\T,CURLYAND,CURLYOR,SIM\], DeMorgan[\T,CURLYOR,CURLYAND,SIM\],
%              BoundedLattice[\T,CURLYAND,CURLYOR\], Ring[\T,XOR,IDENTITY,CURLYAND\] }
%    where { T coerces Identity[\CURLYAND\], T coerces ComplementBound[\CURLYAND\],
%            T coerces Identity[\CURLYOR\], T coerces ComplementBound[\CURLYOR\],
%            T coerces Identity[\XOR\], T coerces Zero[\CURLYAND\] }
%  property FORALL (a: T) (SIM (SIM a)) :=: a
%  property FORALL (a: T, b: T) a XOR b = (a CURLYAND (SIM b)) CURLYOR ((SIM a) CURLYAND b))
%  property coerce_[\T\](Identity[\XOR\]) = coerce_[\T\](Identity[\CURLYOR\])
%  property coerce_[\T\](ComplementBound[\CURLYAND\]) = coerce_[\T\](Identity[\CURLYOR\])
%  property coerce_[\T\](ComplementBound[\CURLYOR\]) = coerce_[\T\](Identity[\CURLYAND\])
%end
\begin{Fortress}
\(\KWD{trait}\:\TYP{BooleanAlgebra}\llbracket{}T \KWD{extends}\:\TYP{BooleanAlgebra}\llbracket{}T,\curlywedge,\curlyvee,\sim,\xor\rrbracket, \KWD{opr} \mathord{\curlywedge}, \KWD{opr} \mathord{\curlyvee}, \KWD{opr} \mathord{\sim}, \KWD{opr} \mathord{\xor}\rrbracket\)\\
{\tt~~~~}\pushtabs\=\+\(    \KWD{extends} \{\, \null\)\pushtabs\=\+\(\TYP{Commutative}\llbracket{}T,\curlywedge\rrbracket, \TYP{Associative}\llbracket{}T,\curlywedge\rrbracket,\)\\
\(              \TYP{Commutative}\llbracket{}T,\curlyvee\rrbracket, \TYP{Associative}\llbracket{}T,\curlyvee\rrbracket,\)\\
\(              \TYP{IdempotentBinaryOperator}\llbracket{}T,\curlywedge\rrbracket,\)\\
\(              \TYP{IdempotentBinaryOperator}\llbracket{}T,\curlyvee\rrbracket,\)\\
\(              \TYP{HasIdentity}\llbracket{}T,\curlywedge\rrbracket, \TYP{HasIdentity}\llbracket{}T,\curlyvee\rrbracket,\)\\
\(              \TYP{HasComplements}\llbracket{}T,\curlyvee,\sim\rrbracket, \TYP{HasComplements}\llbracket{}T,\curlywedge,\sim\rrbracket,\)\\
\(              \TYP{Distributive}\llbracket{}T,\curlywedge,\curlyvee\rrbracket, \TYP{Distributive}\llbracket{}T,\curlyvee,\curlywedge\rrbracket,\)\\
\(              \TYP{DeMorgan}\llbracket{}T,\curlywedge,\curlyvee,\sim\rrbracket, \TYP{DeMorgan}\llbracket{}T,\curlyvee,\curlywedge,\sim\rrbracket,\)\\
\(              \TYP{BoundedLattice}\llbracket{}T,\curlywedge,\curlyvee\rrbracket, \TYP{Ring}\llbracket{}T,\xor,\OPR{IDENTITY},\curlywedge\rrbracket\,\}\)\-\\\poptabs
\(    \KWD{where} \{\, \null\)\pushtabs\=\+\(T \KWD{coerces}\:\TYP{Identity}\llbracket\curlywedge\rrbracket, T \KWD{coerces}\:\TYP{ComplementBound}\llbracket\curlywedge\rrbracket,\)\\
\(            T \KWD{coerces}\:\TYP{Identity}\llbracket\curlyvee\rrbracket, T \KWD{coerces}\:\TYP{ComplementBound}\llbracket\curlyvee\rrbracket,\)\\
\(            T \KWD{coerces}\:\TYP{Identity}\llbracket\xor\rrbracket, T \KWD{coerces}\:\TYP{Zero}\llbracket\curlywedge\rrbracket\,\}\)\-\-\\\poptabs\poptabs
{\tt~~}\pushtabs\=\+\(  \KWD{property} \forall (a\COLON T)\; (\sim (\sim a)) \CONDEQ a\)\\
\(  \KWD{property} \forall (a\COLON T, b\COLON T)\; a \xor b = (a \curlywedge (\sim b)) \curlyvee ((\sim a) \curlywedge b))\)\\
\(  \KWD{property}\:\mathrm{coerce}\llbracket{}T\rrbracket(\TYP{Identity}\llbracket\xor\rrbracket) = \mathrm{coerce}\llbracket{}T\rrbracket(\TYP{Identity}\llbracket\curlyvee\rrbracket)\)\\
\(  \KWD{property}\:\mathrm{coerce}\llbracket{}T\rrbracket(\TYP{ComplementBound}\llbracket\curlywedge\rrbracket) = \mathrm{coerce}\llbracket{}T\rrbracket(\TYP{Identity}\llbracket\curlyvee\rrbracket)\)\\
\(  \KWD{property}\:\mathrm{coerce}\llbracket{}T\rrbracket(\TYP{ComplementBound}\llbracket\curlyvee\rrbracket) = \mathrm{coerce}\llbracket{}T\rrbracket(\TYP{Identity}\llbracket\curlywedge\rrbracket)\)\-\\\poptabs
\(\KWD{end}\)
\end{Fortress}
\vskip-\lastskip
A \emph{boolean algebra} is an algebraic structure consisting of a set of values,
three binary operators \EXP{\curlywedge}, \EXP{\curlyvee}, and \EXP{\xor},
and a unary operator \EXP{\sim}, such that the operators obey a number of specific properties:
\begin{itemize}
\item \EXP{\curlywedge} is commutative, associative, and idempotent, and has a unique identity
\item \EXP{\curlyvee} is commutative, associative, and idempotent, and has a unique identity
\item \EXP{\curlywedge} has complements with respect to \EXP{\sim}
\item \EXP{\curlyvee} has complements with respect to \EXP{\sim}
\item \EXP{\curlywedge} and \EXP{\curlyvee} distribute over each other
\item De Morgan's law applies to \EXP{\curlywedge}, \EXP{\curlyvee}, and \EXP{\sim},
and also to \EXP{\curlyvee}, \EXP{\curlywedge}, and \EXP{\sim}
\item The values form a bounded lattice with \EXP{\curlywedge} as the meet operator and \EXP{\curlyvee} as the join operator.
\item The values form a ring with \EXP{\xor} as the addition operator,
\OPR{IDENTITY} as the additive inverse operator, and \EXP{\curlywedge} as the
multiplication operator
\end{itemize}

The type \TYP{Boolean} is the most familiar example of a boolean algebra.
The power set of a set (that is, the set of all subsets of the set) also
forms a boolean algebra with operators \EXP{\cap}, \EXP{\cup}, set complement,
and symmetric set difference; the empty set is the identity for \EXP{\cup}, and the original set is
the identity for \EXP{\cap}.
