%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%   Copyright 2009, Oracle and/or its affiliates.
%   All rights reserved.
%
%
%   Use is subject to license terms.
%
%   This distribution may include materials developed by third parties.
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Memory Sequences and Binary Words}
\chaplabel{lib:binary}

These are the lowest-level data structures in Fortress, upon which
all others are built.  Even such conceptually ``primitive'' data
types as \EXP{\mathbb{Z}} and \EXP{\mathbb{Z}32} and \EXP{\mathbb{R}64}
are defined in terms of memory sequences and binary words.

Consider, for example, the types \EXP{\TYP{BinaryWord}\llbracket{}6\rrbracket},
\EXP{\mathbb{Z}64}, and \EXP{\mathbb{N}64}.  All three may be regarded
as 64-bit data objects.  However, \EXP{\mathbb{Z}64} causes the operator
\EXP{<} to compare 64-bit words as two's-complement signed integers,
\EXP{\mathbb{N}64} causes the operator \EXP{<}
to compare 64-bit words as unsigned integers,
and \EXP{\TYP{BinaryWord}\llbracket{}6\rrbracket} does not support
the operator \EXP{<} at all---instead it has two methods named \VAR{signedLT}
and \VAR{unsignedLT} (which are, of course, conveniently used to implement the
operator \EXP{<} for \EXP{\mathbb{Z}64} and \EXP{\mathbb{N}64}).
Moreover, \EXP{\mathbb{Z}64} and \EXP{\mathbb{N}64} support units and dimensions,
but \TYP{BinaryWord} values do not.  The parameterized type \TYP{BinaryWord} provides methods that are
only a modest abstraction of operations supported by typical hardware instruction sets
and serves as the lowest-level substrate that allows types such as \EXP{\mathbb{Z}64}
to be defined by libraries coded entirely in Fortress.

Similarly, the parameterized traits \TYP{LinearSequence} and \TYP{HeapSequence}
describe the lowest-level data structures that are array-like or vector-like,
capable of little more than one-dimensional indexing.  They serve as the
lowest-level substrate that allows the complete distributed and multi-dimensional
array types to be defined by libraries coded entirely in Fortress.

For convenience, we use the term \emph{binary linear sequence} to refer to
a linear sequence of binary words, and the term \emph{binary heap sequence}
to refer to a heap sequence of binary words.

%% type BinaryLinearSequence[\nat b,nat n\] = LinearSequence[\BinaryWord[\b\],n\]
%% type BinaryHeapSequence[\nat b\] = HeapSequence[\BinaryWord[\b\]\]
\begin{Fortress}
\(\KWD{type} \TYP{BinaryLinearSequence}\llbracket\KWD{nat} b,\KWD{nat} n\rrbracket = \TYP{LinearSequence}\llbracket\TYP{BinaryWord}\llbracket{}b\rrbracket,n\rrbracket\)\\
\(\KWD{type} \TYP{BinaryHeapSequence}\llbracket\KWD{nat} b\rrbracket = \TYP{HeapSequence}\llbracket\TYP{BinaryWord}\llbracket{}b\rrbracket\rrbracket\)
\end{Fortress}

Most operations on binary words do not depend on \emph{endianness},
that is, in which order the bits are numbered.  For operations
that do depend on endianness, the parameterized trait \TYP{BinaryEndianWord}
is provided.

It is also sometimes desirable to perform endianness-dependent operations on a linear sequence
of binary words.  For this purpose the specialized parameterized traits
\TYP{BinaryLinearEndianSequence} and \TYP{BinaryEndianLinearEndianSequence}
are provided; the former has \TYP{BinaryWord} values as elements,
and the latter has \TYP{BinaryEndianWord} values as elements.


\Trait{Fortress.Core.LinearSequence}
\seclabel{lib:LinearSequence}

A value of type \EXP{\TYP{LinearSequence}\llbracket{}T,n\rrbracket}
is a sequence of \VAR{n} things of type \VAR{T}, where \VAR{n} may be any natural number.
Note that its length is statically fixed and may be described by a static expression.
The general intent is that such a sequence will reside in
a contiguous region of memory, typically belonging to a single processor
or processor node, and that any element (indicated by an integer index)
may be fetched or updated quickly by that processor or processor node.

If \VAR{T} is not a value type, then \EXP{\TYP{LinearSequence}\llbracket{}T,n\rrbracket} describes a
sequence of references, and a variable of type \EXP{\TYP{LinearSequence}\llbracket{}T,n\rrbracket} occupies
an amount of storage equal to \VAR{n} times the amount of storage required to hold
a reference.  If \VAR{T} is a value type, then \EXP{\TYP{LinearSequence}\llbracket{}T,n\rrbracket}
describes a sequence of ``unboxed'' values,
and a variable of type \EXP{\TYP{LinearSequence}\llbracket{}T,n\rrbracket} occupies an amount of storage equal
to \VAR{n} times the amount of storage required to hold one value of type \VAR{T}.

Linear sequences, unlike arrays, are not too fancy. The main
things you can do with linear sequences are subscripting and subscripted assignment,
as well as assignment of entire sequences.  They also support
the concatenation operator \EXP{\|}.  For example:
%%   x: LinearSequence[\Thread,3\]
%%   y: LinearSequence[\Thread,6\]
%%   z: LinearSequence[\Thread,5\] = x || y[3#2]
\begin{Fortress}
{\tt~~}\pushtabs\=\+\(  x\COLON \TYP{LinearSequence}\llbracket\TYP{Thread},3\rrbracket \)\\
\(  y\COLON \TYP{LinearSequence}\llbracket\TYP{Thread},6\rrbracket\)\\
\(  z\COLON \TYP{LinearSequence}\llbracket\TYP{Thread},5\rrbracket = x \| y[3\mathinner{\hbox{\tt\char'43}}2]\)\-\\\poptabs
\end{Fortress}
Note in this example that the lengths are statically checkable.  The range
\EXP{3\mathinner{\hbox{\tt\char'43}}2} is a range of constant size 2,
so \EXP{y[3\mathinner{\hbox{\tt\char'43}}2]}
is known to be of type \EXP{\TYP{LinearSequence}\llbracket\TYP{Thread},2\rrbracket}.
Indeed, only ranges of static size with element type \TYP{IndexInt} may be used to subscript a linear sequence.

%% value trait LinearSequence[\T extends Any, nat n\] comprises { ... }
%%   coerce[\nat b,bool bigEndianSequence\]
%%      (x: BinaryLinearEndianSequence[\b,n,bigEndianSequence\])
%%     where { T extends BinaryWord[\b\] }
%%   coerce[\nat b,bool bigEndianBytes,bool bigEndianBits,bool bigEndianSequence\]
%%      (x: BinaryEndianLinearEndianSequence[\b,bigEndianBytes,bigEndianBits,
%%                                            n,bigEndianSequence\])
%%     where { T extends BinaryEndianWord[\b,bigEndianBytes,bigEndianBits\] }
%%   coerce[\nat b,bool bigEndianBytes,bool bigEndianBits,bool bigEndianSequence\]
%%      (x: BinaryEndianLinearEndianSequence[\b,bigEndianBytes,bigEndianBits,
%%                                            n,bigEndianSequence\])
%%     where { T extends BinaryWord[\b\] }
%%   opr [j: IndexInt]: T throws { IndexOutOfBounds }
%%   opr [\nat k\] [j: IntegerStatic[\k\]]: T where { k < n }
%%   opr [\nat m\] [r: RangeOfStaticSize[\IndexInt,m\]]: LinearSequence[\T,m\]
%%     throws { IndexOutOfBounds } where { m <= n }
%%   opr [\int a,nat m,int c\] [r: StaticRange[\a,m,c\]]: LinearSequence[\T,m\]
%%     where { 0 <= a < n, 0 <= a + m DOT c< n }
%%   opr [j: IndexInt] := (v: T): LinearSequence[\T,n\] throws { IndexOutOfBounds }
%%   opr [\nat k\] [j: IntegerStatic[\k\]] := (v: T): LinearSequence[\T,n\] where { k < n }
%%   opr [\nat m\] [r: RangeOfStaticSize[\IndexInt,m\]] := (v: LinearSequence[\T,m\]):
%%      LinearSequence[\T,n\]
%%     throws { IndexOutOfBounds } where { m <= n }
%%   opr [\int a,nat m,int c\] [r: StaticRange[\a,m,c\]] := (v: LinearSequence[\T,m\]):
%%      LinearSequence[\T,n\]
%%     where { 0 <= a < n, 0 <= a + m DOT c < n }
%%   update(j: IndexInt, v: T): LinearSequence[\T,n\] throws { IndexOutOfBounds }
%%   update[\nat k\](j: IntegerStatic[\k\], v: T): LinearSequence[\T,n\] where { k < n }
%%   update[\nat m\](r: RangeOfStaticSize[\IndexInt,m\], v: LinearSequence[\T,m\]):
%%      LinearSequence[\T,n\]
%%     throws { IndexOutOfBounds } where { m <= n }
%%   update[\int a,nat m,int c\](r: StaticRange[\a,m,c\], v: LinearSequence[\T,m\]):
%%      LinearSequence[\T,n\]
%%     where { 0 <= a < n, 0 <= a + m DOT c < n }
%%   opr || [\nat m\](self, other: LinearSequence[\T,m\]): LinearSequence[\T,n+m\]
%%   getter reverse(): LinearSequence[\T,n\]
%%   getter littleEndian[\nat b\](): BinaryLinearEndianSequence[\b,n,false\]
%%     where { T extends BinaryWord[\b\] }
%%   getter bigEndian[\nat b\](): BinaryLinearEndianSequence[\b,n,true\]
%%     where { T extends BinaryWord[\b\] }
%%   getter littleEndian[\nat b,bool bigEndianBytes,bool bigEndianBits\]():
%%      BinaryEndianLinearEndianSequence[\b,bigEndianBytes,bigEndianBits,n,false\]
%%     where { T extends BinaryEndianWord[\b,bigEndianBytes,bigEndianBits\] }
%%   getter bigEndian[\nat b,bool bigEndianBytes,bool bigEndianBits\]():
%%      BinaryEndianLinearEndianSequence[\b,bigEndianBytes,bigEndianBits,n,true\]
%%     where { T extends BinaryEndianWord[\b,bigEndianBytes,bigEndianBits\] }
%% end
\begin{Fortress}
\(\KWD{value}\;\;\KWD{trait} \TYP{LinearSequence}\llbracket{}T \KWD{extends} \TYP{Any}, \KWD{nat} n\rrbracket \KWD{comprises} \{\,\ldots\,\}\)\\
{\tt~~}\pushtabs\=\+\(  \KWD{coerce}\llbracket\KWD{nat} b,\KWD{bool} \VAR{bigEndianSequence}\rrbracket\)\\
{\tt~~~}\pushtabs\=\+\(     (x\COLON \TYP{BinaryLinearEndianSequence}\llbracket{}b,n,\VAR{bigEndianSequence}\rrbracket)\)\-\\\poptabs
{\tt~~}\pushtabs\=\+\(    \KWD{where} \{\,T \KWD{extends} \TYP{BinaryWord}\llbracket{}b\rrbracket\,\}\)\-\\\poptabs
\(  \KWD{coerce}\llbracket\KWD{nat} b,\KWD{bool} \VAR{bigEndianBytes},\KWD{bool} \VAR{bigEndianBits},\KWD{bool} \VAR{bigEndianSequence}\rrbracket\)\\
{\tt~~~}\pushtabs\=\+\(     (x\COLON \TYP{BinaryEndianLinearEndianSequence}\llbracket\null\)\pushtabs\=\+\(b,\VAR{bigEndianBytes},\VAR{bigEndianBits},\)\\
\(                                           n,\VAR{bigEndianSequence}\rrbracket)\)\-\-\\\poptabs\poptabs
{\tt~~}\pushtabs\=\+\(    \KWD{where} \{\,T \KWD{extends} \TYP{BinaryEndianWord}\llbracket{}b,\VAR{bigEndianBytes},\VAR{bigEndianBits}\rrbracket\,\}\)\-\\\poptabs
\(  \KWD{coerce}\llbracket\KWD{nat} b,\KWD{bool} \VAR{bigEndianBytes},\KWD{bool} \VAR{bigEndianBits},\KWD{bool} \VAR{bigEndianSequence}\rrbracket\)\\
{\tt~~~}\pushtabs\=\+\(     (x\COLON \TYP{BinaryEndianLinearEndianSequence}\llbracket\null\)\pushtabs\=\+\(b,\VAR{bigEndianBytes},\VAR{bigEndianBits},\)\\
\(                                           n,\VAR{bigEndianSequence}\rrbracket)\)\-\-\\\poptabs\poptabs
{\tt~~}\pushtabs\=\+\(    \KWD{where} \{\,T \KWD{extends} \TYP{BinaryWord}\llbracket{}b\rrbracket\,\}\)\-\\\poptabs
\(  \KWD{opr} [j\COLON \TYP{IndexInt}]\COLON T \KWD{throws} \{\,\TYP{IndexOutOfBounds}\,\}\)\\
\(  \KWD{opr} \llbracket\KWD{nat} k\rrbracket [j\COLON \TYP{IntegerStatic}\llbracket{}k\rrbracket]\COLON T \KWD{where} \{\,k < n\,\}\)\\
\(  \KWD{opr} \llbracket\KWD{nat} m\rrbracket [r\COLON \TYP{RangeOfStaticSize}\llbracket\TYP{IndexInt},m\rrbracket]\COLON \TYP{LinearSequence}\llbracket{}T,m\rrbracket\)\\
{\tt~~}\pushtabs\=\+\(    \KWD{throws} \{\,\TYP{IndexOutOfBounds}\,\} \KWD{where} \{\,m \leq n\,\}\)\-\\\poptabs
\(  \KWD{opr} \llbracket\KWD{int} a,\KWD{nat} m,\KWD{int} c\rrbracket [r\COLON \TYP{StaticRange}\llbracket{}a,m,c\rrbracket]\COLON \TYP{LinearSequence}\llbracket{}T,m\rrbracket\)\\
{\tt~~}\pushtabs\=\+\(    \KWD{where} \{\,0 \leq a < n, 0 \leq a + m \cdot c< n\,\}\)\-\\\poptabs
\(  \KWD{opr} [j\COLON \TYP{IndexInt}] \ASSIGN (v\COLON T)\COLON \TYP{LinearSequence}\llbracket{}T,n\rrbracket \KWD{throws} \{\,\TYP{IndexOutOfBounds}\,\}\)\\
\(  \KWD{opr} \llbracket\KWD{nat} k\rrbracket [j\COLON \TYP{IntegerStatic}\llbracket{}k\rrbracket] \ASSIGN (v\COLON T)\COLON \TYP{LinearSequence}\llbracket{}T,n\rrbracket \KWD{where} \{\,k < n\,\}\)\\
\(  \KWD{opr} \llbracket\KWD{nat} m\rrbracket [r\COLON \TYP{RangeOfStaticSize}\llbracket\TYP{IndexInt},m\rrbracket] \ASSIGN (v\COLON \TYP{LinearSequence}\llbracket{}T,m\rrbracket)\COLON \)\\
{\tt~~~}\pushtabs\=\+\(     \TYP{LinearSequence}\llbracket{}T,n\rrbracket\)\-\\\poptabs
{\tt~~}\pushtabs\=\+\(    \KWD{throws} \{\,\TYP{IndexOutOfBounds}\,\} \KWD{where} \{\,m \leq n\,\}\)\-\\\poptabs
\(  \KWD{opr} \llbracket\KWD{int} a,\KWD{nat} m,\KWD{int} c\rrbracket [r\COLON \TYP{StaticRange}\llbracket{}a,m,c\rrbracket] \ASSIGN (v\COLON \TYP{LinearSequence}\llbracket{}T,m\rrbracket)\COLON \)\\
{\tt~~~}\pushtabs\=\+\(     \TYP{LinearSequence}\llbracket{}T,n\rrbracket\)\-\\\poptabs
{\tt~~}\pushtabs\=\+\(    \KWD{where} \{\,0 \leq a < n, 0 \leq a + m \cdot c < n\,\}\)\-\\\poptabs
\(  \VAR{update}(j\COLON \TYP{IndexInt}, v\COLON T)\COLON \TYP{LinearSequence}\llbracket{}T,n\rrbracket \KWD{throws} \{\,\TYP{IndexOutOfBounds}\,\}\)\\
\(  \VAR{update}\llbracket\KWD{nat} k\rrbracket(j\COLON \TYP{IntegerStatic}\llbracket{}k\rrbracket, v\COLON T)\COLON \TYP{LinearSequence}\llbracket{}T,n\rrbracket \KWD{where} \{\,k < n\,\}\)\\
\(  \VAR{update}\llbracket\KWD{nat} m\rrbracket(r\COLON \TYP{RangeOfStaticSize}\llbracket\TYP{IndexInt},m\rrbracket, v\COLON \TYP{LinearSequence}\llbracket{}T,m\rrbracket)\COLON \)\\
{\tt~~~}\pushtabs\=\+\(     \TYP{LinearSequence}\llbracket{}T,n\rrbracket\)\-\\\poptabs
{\tt~~}\pushtabs\=\+\(    \KWD{throws} \{\,\TYP{IndexOutOfBounds}\,\} \KWD{where} \{\,m \leq n\,\}\)\-\\\poptabs
\(  \VAR{update}\llbracket\KWD{int} a,\KWD{nat} m,\KWD{int} c\rrbracket(r\COLON \TYP{StaticRange}\llbracket{}a,m,c\rrbracket, v\COLON \TYP{LinearSequence}\llbracket{}T,m\rrbracket)\COLON \)\\
{\tt~~~}\pushtabs\=\+\(     \TYP{LinearSequence}\llbracket{}T,n\rrbracket\)\-\\\poptabs
{\tt~~}\pushtabs\=\+\(    \KWD{where} \{\,0 \leq a < n, 0 \leq a + m \cdot c < n\,\}\)\-\\\poptabs
\(  \KWD{opr}\,\|\,\llbracket\KWD{nat} m\rrbracket(\KWD{self}, \VAR{other}\COLON \TYP{LinearSequence}\llbracket{}T,m\rrbracket)\COLON \TYP{LinearSequence}\llbracket{}T,n+m\rrbracket\)\\
\(  \KWD{getter} \VAR{reverse}()\COLON \TYP{LinearSequence}\llbracket{}T,n\rrbracket\)\\
\(  \KWD{getter} \VAR{littleEndian}\llbracket\KWD{nat} b\rrbracket()\COLON \TYP{BinaryLinearEndianSequence}\llbracket{}b,n,\VAR{false}\rrbracket\)\\
{\tt~~}\pushtabs\=\+\(    \KWD{where} \{\,T \KWD{extends} \TYP{BinaryWord}\llbracket{}b\rrbracket\,\}\)\-\\\poptabs
\(  \KWD{getter} \VAR{bigEndian}\llbracket\KWD{nat} b\rrbracket()\COLON \TYP{BinaryLinearEndianSequence}\llbracket{}b,n,\VAR{true}\rrbracket\)\\
{\tt~~}\pushtabs\=\+\(    \KWD{where} \{\,T \KWD{extends} \TYP{BinaryWord}\llbracket{}b\rrbracket\,\}\)\-\\\poptabs
\(  \KWD{getter} \VAR{littleEndian}\llbracket\KWD{nat} b,\KWD{bool} \VAR{bigEndianBytes},\KWD{bool} \VAR{bigEndianBits}\rrbracket()\COLON \)\\
{\tt~~~}\pushtabs\=\+\(     \TYP{BinaryEndianLinearEndianSequence}\llbracket{}b,\VAR{bigEndianBytes},\VAR{bigEndianBits},n,\VAR{false}\rrbracket\)\-\\\poptabs
{\tt~~}\pushtabs\=\+\(    \KWD{where} \{\,T \KWD{extends} \TYP{BinaryEndianWord}\llbracket{}b,\VAR{bigEndianBytes},\VAR{bigEndianBits}\rrbracket\,\}\)\-\\\poptabs
\(  \KWD{getter} \VAR{bigEndian}\llbracket\KWD{nat} b,\KWD{bool} \VAR{bigEndianBytes},\KWD{bool} \VAR{bigEndianBits}\rrbracket()\COLON \)\\
{\tt~~~}\pushtabs\=\+\(     \TYP{BinaryEndianLinearEndianSequence}\llbracket{}b,\VAR{bigEndianBytes},\VAR{bigEndianBits},n,\VAR{true}\rrbracket\)\-\\\poptabs
{\tt~~}\pushtabs\=\+\(    \KWD{where} \{\,T \KWD{extends} \TYP{BinaryEndianWord}\llbracket{}b,\VAR{bigEndianBytes},\VAR{bigEndianBits}\rrbracket\,\}\)\-\-\\\poptabs\poptabs
\(\KWD{end}\)
\end{Fortress}


%%   coerce[\nat b,bool bigEndianSequence\]
%%      (x: BinaryLinearEndianSequence[\b,n,bigEndianSequence\])
%%     where { T extends BinaryWord[\b\] }
%%   coerce[\nat b,bool bigEndianBytes,bool bigEndianBits,bool bigEndianSequence\]
%%      (x: BinaryEndianLinearEndianSequence[\b,bigEndianBytes,bigEndianBits,
%%                                            n,bigEndianSequence\])
%%     where { T extends BinaryEndianWord[\b,bigEndianBytes,bigEndianBits\] }
\Method{\EXP{\KWD{coerce}\llbracket\KWD{nat} b,\KWD{bool} \VAR{bigEndianSequence}\rrbracket}\\
\hbox{\tt~~~}\EXP{(x\COLON \TYP{BinaryLinearEndianSequence}\llbracket{}b,n,\VAR{bigEndianSequence}\rrbracket)}\\
\hbox{\tt~~}\EXP{\KWD{where} \{\,T \KWD{extends} \TYP{BinaryWord}\llbracket{}b\rrbracket\,\}}}
\Method*{\EXP{\KWD{coerce}\llbracket\KWD{nat} b,\KWD{bool} \VAR{bigEndianBytes},\KWD{bool} \VAR{bigEndianBits},\KWD{bool} \VAR{bigEndianSequence}\rrbracket}\\
\hbox{\tt~~~}\EXP{(x\COLON \TYP{BinaryEndianLinearEndianSequence}\llbracket{}b,\VAR{bigEndianBytes},\VAR{bigEndianBits},}\\
\hbox{\tt~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~}\EXP{n,\VAR{bigEndianSequence}\rrbracket)}\\
\hbox{\tt~~}\EXP{\KWD{where} \{\,T \KWD{extends} \TYP{BinaryEndianWord}\llbracket{}b,\VAR{bigEndianBytes},\VAR{bigEndianBits}\rrbracket\,\}}}

Any binary linear endian sequence may be coerced to an ordinary binary linear sequence
of corresponding element type.  The bit values remain the same;
all that is lost is the endianness information of the sequence in the static type.


%%   coerce[\nat b,bool bigEndianBytes,bool bigEndianBits,bool bigEndianSequence\]
%%      (x: BinaryEndianLinearEndianSequence[\b,bigEndianBytes,bigEndianBits,
%%                                            n,bigEndianSequence\])
%%     where { T extends BinaryWord[\b\] }
\Method{\EXP{\KWD{coerce}\llbracket\KWD{nat} b,\KWD{bool} \VAR{bigEndianBytes},\KWD{bool} \VAR{bigEndianBits},\KWD{bool} \VAR{bigEndianSequence}\rrbracket}\\
{\tt~~~}\EXP{(x\COLON \TYP{BinaryEndianLinearEndianSequence}\llbracket{}b,\VAR{bigEndianBytes},\VAR{bigEndianBits},}\\
{\tt~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~}\EXP{n,\VAR{bigEndianSequence}\rrbracket)}\\
{\tt~~}\EXP{\KWD{where} \{\,T \KWD{extends} \TYP{BinaryWord}\llbracket{}b\rrbracket\,\}}}

A binary linear endian sequence of binary endian words may be coerced
to an ordinary binary linear sequence of ordinary binary words.  The bit values remain the same;
all that is lost is the endianness information of both the sequence and the elements.


%%   opr [j: IndexInt]: T throws { IndexOutOfBounds }
%%   opr [\nat k\] [j: IntegerStatic[\k\]]: T where { k < n }
\Method{\EXP{\KWD{opr} [j\COLON \TYP{IndexInt}]\COLON T \KWD{throws} \{\,\TYP{IndexOutOfBounds}\,\}}}
\Method*{\EXP{\KWD{opr} \llbracket\KWD{nat} k\rrbracket [j\COLON \TYP{IntegerStatic}\llbracket{}k\rrbracket]\COLON T \KWD{where} \{\,k < n\,\}}}

Subscripting returns element \VAR{j} of this linear sequence.
Indexing is zero-origin; an \TYP{IndexOutOfBounds} is thrown unless \EXP{0\leq{}j<n},
where \VAR{n} is the length of the linear sequence.
If the subscript is a static expression, then its validity is checked statically,
and no exception will occur at run time.


%%   opr [\nat m\] [r: RangeOfStaticSize[\IndexInt,m\]]: LinearSequence[\T,m\]
%%     throws { IndexOutOfBounds } where { m <= n }
%%   opr [\int a,nat m,int c\] [r: StaticRange[\a,m,c\]]: LinearSequence[\T,m\]
%%     where { 0 <= a < n, 0 <= a + m DOT c< n }
\Method{\EXP{\KWD{opr} \llbracket\KWD{nat} m\rrbracket [r\COLON \TYP{RangeOfStaticSize}\llbracket\TYP{IndexInt},m\rrbracket]\COLON \TYP{LinearSequence}\llbracket{}T,m\rrbracket}\\
{\tt~~}\EXP{\KWD{throws} \{\,\TYP{IndexOutOfBounds}\,\} \KWD{where} \{\,m \leq n\,\}}}
\Method*{\EXP{\KWD{opr} \llbracket\KWD{int} a,\KWD{nat} m,\KWD{int} c\rrbracket [r\COLON \TYP{StaticRange}\llbracket{}a,m,c\rrbracket]\COLON \TYP{LinearSequence}\llbracket{}T,m\rrbracket}\\
{\tt~~}\EXP{\KWD{where} \{\,0 \leq a < n, 0 \leq a + m \cdot c< n\,\}}}

Subscripting with a range of static size \VAR{m} returns the indicated subsequence of this linear sequence.
Indexing is zero-origin;
an \TYP{IndexOutOfBounds} is thrown unless \EXP{r \subseteq 0\mathinner{\hbox{\tt\char'43}}n},
where \VAR{n} is the length of the linear sequence.
If the subscript is a static range, then its validity is checked statically,
and no exception will occur at run time.
Element \VAR{k} of the result sequence is the same as
element \EXP{r.\VAR{lowerBound} + k \times r.\VAR{stride}} of this linear sequence, for all \EXP{0\leq{}k<m}.


%%   opr [j: IndexInt] := (v: T): LinearSequence[\T,n\] throws { IndexOutOfBounds }
%%   opr [\nat k\] [j: IntegerStatic[\k\]] := (v: T): LinearSequence[\T,n\] where { k < n }
\Method{\EXP{\KWD{opr} [j\COLON \TYP{IndexInt}] \ASSIGN (v\COLON T)\COLON \TYP{LinearSequence}\llbracket{}T,n\rrbracket \KWD{throws} \{\,\TYP{IndexOutOfBounds}\,\}}}
\Method*{\EXP{\KWD{opr} \llbracket\KWD{nat} k\rrbracket [j\COLON \TYP{IntegerStatic}\llbracket{}k\rrbracket] \ASSIGN (v\COLON T)\COLON \TYP{LinearSequence}\llbracket{}T,n\rrbracket \KWD{where} \{\,k < n\,\}}}

After subscripted value object assignment, element \VAR{j} of the subscripted variable is the same as the given value \VAR{v},
and all other elements are the same as before.
Indexing is zero-origin; an \TYP{IndexOutOfBounds} is thrown unless \EXP{0\leq{}j<n},
where \VAR{n} is the length of the linear sequence.
If the subscript is a static expression, then its validity is checked statically,
and no exception will occur at run time.


%%   opr [\nat m\] [r: RangeOfStaticSize[\IndexInt,m\]] := (v: LinearSequence[\T,m\]):
%%      LinearSequence[\T,n\]
%%     throws { IndexOutOfBounds } where { m <= n }
%%   opr [\int a,nat m,int c\] [r: StaticRange[\a,m,c\]] := (v: LinearSequence[\T,m\]):
%%      LinearSequence[\T,n\]
%%     where { 0 <= a < n, 0 <= a + m DOT c < n }
\Method{\EXP{\KWD{opr} \llbracket\KWD{nat} m\rrbracket [r\COLON \TYP{RangeOfStaticSize}\llbracket\TYP{IndexInt},m\rrbracket] \ASSIGN (v\COLON \TYP{LinearSequence}\llbracket{}T,m\rrbracket)\COLON }\\
{\tt~~~}\EXP{\TYP{LinearSequence}\llbracket{}T,n\rrbracket}\\
{\tt~~}\EXP{\KWD{throws} \{\,\TYP{IndexOutOfBounds}\,\} \KWD{where} \{\,m \leq n\,\}}}
\Method*{\EXP{\KWD{opr} \llbracket\KWD{int} a,\KWD{nat} m,\KWD{int} c\rrbracket [r\COLON \TYP{StaticRange}\llbracket{}a,m,c\rrbracket] \ASSIGN (v\COLON \TYP{LinearSequence}\llbracket{}T,m\rrbracket)\COLON }\\
{\tt~~~}\EXP{\TYP{LinearSequence}\llbracket{}T,n\rrbracket}\\
{\tt~~}\EXP{\KWD{where} \{\,0 \leq a < n, 0 \leq a + m \cdot c < n\,\}}}

After subscripted value object assignment, elements of the subscripted variable selected by \VAR{r}
are the same as corresponding elements of \VAR{v}, and all other elements are the same as before;
specifically, element \EXP{r.\VAR{lowerBound} + k \times r.\VAR{stride}} of the updated
variable is the same as element \VAR{k} of \VAR{v}, for all \EXP{0\leq{}k<m}.
Indexing is zero-origin; an \TYP{IndexOutOfBounds} is thrown unless \EXP{r \subseteq 0\mathinner{\hbox{\tt\char'43}}n},
where \VAR{n} is the length of the linear sequence.
If the subscript is a static range, then its validity is checked statically,
and no exception will occur at run time.


%%   update(j: IndexInt, v: T): LinearSequence[\T,n\] throws { IndexOutOfBounds }
%%   update[\nat k\](j: IntegerStatic[\k\], v: T): LinearSequence[\T,n\] where { k < n }
\Method{\EXP{\VAR{update}(j\COLON \TYP{IndexInt}, v\COLON T)\COLON \TYP{LinearSequence}\llbracket{}T,n\rrbracket \KWD{throws} \{\,\TYP{IndexOutOfBounds}\,\}}}
\Method*{\EXP{\VAR{update}\llbracket\KWD{nat} k\rrbracket(j\COLON \TYP{IntegerStatic}\llbracket{}k\rrbracket, v\COLON T)\COLON \TYP{LinearSequence}\llbracket{}T,n\rrbracket \KWD{where} \{\,k < n\,\}}}

This is a functional version of subscripted value object assignment:
element \VAR{j} of the result is the same as the given value \VAR{v},
and all other elements are the same as before.
Indexing is zero-origin; an \TYP{IndexOutOfBounds} is thrown unless \EXP{0\leq{}j<n},
where \VAR{n} is the length of the linear sequence.
If the subscript is a static expression, then its validity is checked statically,
and no exception will occur at run time.


%%   update[\nat m\](r: RangeOfStaticSize[\IndexInt,m\], v: LinearSequence[\T,m\]):
%%      LinearSequence[\T,n\]
%%     throws { IndexOutOfBounds } where { m <= n }
%%   update[\int a,nat m,int c\](r: StaticRange[\a,m,c\], v: LinearSequence[\T,m\]):
%%      LinearSequence[\T,n\]
%%     where { 0 <= a < n, 0 <= a + m DOT c < n }
\Method{\EXP{\VAR{update}\llbracket\KWD{nat} m\rrbracket(r\COLON \TYP{RangeOfStaticSize}\llbracket\TYP{IndexInt},m\rrbracket, v\COLON \TYP{LinearSequence}\llbracket{}T,m\rrbracket)\COLON }\\
{\tt~~~}\EXP{\TYP{LinearSequence}\llbracket{}T,n\rrbracket}\\
{\tt~~}\EXP{\KWD{throws} \{\,\TYP{IndexOutOfBounds}\,\} \KWD{where} \{\,m \leq n\,\}}}
\Method*{\EXP{\VAR{update}\llbracket\KWD{int} a,\KWD{nat} m,\KWD{int} c\rrbracket(r\COLON \TYP{StaticRange}\llbracket{}a,m,c\rrbracket, v\COLON \TYP{LinearSequence}\llbracket{}T,m\rrbracket)\COLON }\\
{\tt~~~}\EXP{\TYP{LinearSequence}\llbracket{}T,n\rrbracket}\\
{\tt~~}\EXP{\KWD{where} \{\,0 \leq a < n, 0 \leq a + m \cdot c < n\,\}}}

This is a functional version of subscripted value object assignment:
elements of the result selected by \VAR{r}
are the same as corresponding elements of \VAR{v}, and all other elements are the same as before;
specifically, element \EXP{r.\VAR{lowerBound} + k \times r.\VAR{stride}} of the result
is the same as element \VAR{k} of \VAR{v}, for all \EXP{0\leq{}k<m}.
Indexing is zero-origin; an \TYP{IndexOutOfBounds} is thrown unless \EXP{0\leq{}j<n},
where \VAR{n} is the length of the linear sequence.
If the subscript is a static range, then its validity is checked statically,
and no exception will occur at run time.


%%   opr || [\nat m\](self, other: LinearSequence[\T,m\]): LinearSequence[\T,n+m\]
\Method{\EXP{\KWD{opr}\,\|\,\llbracket\KWD{nat} m\rrbracket(\KWD{self}, \VAR{other}\COLON \TYP{LinearSequence}\llbracket{}T,m\rrbracket)\COLON \TYP{LinearSequence}\llbracket{}T,n+m\rrbracket}}

The result is a linear sequence whose length is equal to the sum of the lengths
of this linear sequence and the other linear sequence.  Element \VAR{k}
of the result is the same as element \VAR{k} of this linear sequence if \EXP{0\leq{}k<n},
and is the same as element \EXP{k-n} of the other linear sequence if \EXP{n\leq{}k<n+m}.


%%   getter reverse(): LinearSequence[\T,n\]
\Method{\EXP{\KWD{getter} \VAR{reverse}()\COLON \TYP{LinearSequence}\llbracket{}T,n\rrbracket}}

The result is a linear sequence such that element \VAR{k}
of the result is the same as element \VAR{n-1-k} of this linear sequence, for all \EXP{0\leq{}k<n}.


%%   getter littleEndian[\nat b\](): BinaryLinearEndianSequence[\b,n,false\]
%%     where { T extends BinaryWord[\b\] }
%%   getter bigEndian[\nat b\](): BinaryLinearEndianSequence[\b,n,true\]
%%     where { T extends BinaryWord[\b\] }
%%   getter littleEndian[\nat b,bool bigEndianBytes,bool bigEndianBits\]():
%%      BinaryEndianLinearEndianSequence[\b,bigEndianBytes,bigEndianBits,n,false\]
%%     where { T extends BinaryEndianWord[\b,bigEndianBytes,bigEndianBits\] }
%%   getter bigEndian[\nat b,bool bigEndianBytes,bool bigEndianBits\]():
%%      BinaryEndianLinearEndianSequence[\b,bigEndianBytes,bigEndianBits,n,true\]
%%     where { T extends BinaryEndianWord[\b,bigEndianBytes,bigEndianBits\] }
\Method{\EXP{\KWD{getter} \VAR{littleEndian}\llbracket\KWD{nat} b\rrbracket()\COLON \TYP{BinaryLinearEndianSequence}\llbracket{}b,n,\VAR{false}\rrbracket}\\
{\tt~~}\EXP{\KWD{where} \{\,T \KWD{extends} \TYP{BinaryWord}\llbracket{}b\rrbracket\,\}}}
\Method*{\EXP{\KWD{getter} \VAR{bigEndian}\llbracket\KWD{nat} b\rrbracket()\COLON \TYP{BinaryLinearEndianSequence}\llbracket{}b,n,\VAR{true}\rrbracket}\\
{\tt~~}\EXP{\KWD{where} \{\,T \KWD{extends} \TYP{BinaryWord}\llbracket{}b\rrbracket\,\}}}
\Method*{\EXP{\KWD{getter} \VAR{littleEndian}\llbracket\KWD{nat} b,\KWD{bool} \VAR{bigEndianBytes},\KWD{bool} \VAR{bigEndianBits}\rrbracket()\COLON }\\
{\tt~~~}\EXP{\TYP{BinaryEndianLinearEndianSequence}\llbracket{}b,\VAR{bigEndianBytes},\VAR{bigEndianBits},n,\VAR{false}\rrbracket}\\
{\tt~~}\EXP{\KWD{where} \{\,T \KWD{extends} \TYP{BinaryEndianWord}\llbracket{}b,\VAR{bigEndianBytes},\VAR{bigEndianBits}\rrbracket\,\}}}
\Method*{\EXP{\KWD{getter} \VAR{bigEndian}\llbracket\KWD{nat} b,\KWD{bool} \VAR{bigEndianBytes},\KWD{bool} \VAR{bigEndianBits}\rrbracket()\COLON }\\
{\tt~~~}\EXP{\TYP{BinaryEndianLinearEndianSequence}\llbracket{}b,\VAR{bigEndianBytes},\VAR{bigEndianBits},n,\VAR{true}\rrbracket}\\
{\tt~~}\EXP{\KWD{where} \{\,T \KWD{extends} \TYP{BinaryEndianWord}\llbracket{}b,\VAR{bigEndianBytes},\VAR{bigEndianBits}\rrbracket\,\}}}

These conversion getters allow a linear sequence of (possibly endian) binary words
to be treated as a specifically little-endian or specifically big-endian linear sequence.
This is especially useful just before invoking an endianness-dependent method, for example
\EXP{s.\VAR{littleEndian}.\VAR{countLeadingZeroBits}()}.


\section{Constructing Linear Sequences}

%% makeLinearSequence[\T extends Any,nat n\](item: T): LinearSequence[\T,n\]
\Method{\EXP{\VAR{makeLinearSequence}\llbracket{}T \KWD{extends} \TYP{Any},\KWD{nat} n\rrbracket(\VAR{item}\COLON T)\COLON \TYP{LinearSequence}\llbracket{}T,n\rrbracket}}
\seclabel{lib:makeLinearSequence}

A new linear sequence of length \VAR{n} is returned.
Every element of the linear sequence is initialized to be the same as the given \VAR{item}.


%% computeLinearSequence[\T extends Any,nat n\](f: IndexInt->T): LinearSequence[\T,n\]
\Method{\EXP{\VAR{computeLinearSequence}\llbracket{}T \KWD{extends} \TYP{Any},\KWD{nat} n\rrbracket(f\COLON \TYP{IndexInt}\rightarrow{}T)\COLON \TYP{LinearSequence}\llbracket{}T,n\rrbracket}}
\seclabel{lib:computeLinearSequence}

A new linear sequence of length \VAR{n} is returned.
Element \VAR{j} of the new linear sequence is initialized to a value
computed by calling the given function \VAR{f} with argument \VAR{j}.


\Trait{Fortress.Core.HeapSequence}
\seclabel{lib:HeapSequence}

A value of type \EXP{\TYP{HeapSequence}\llbracket{}T\rrbracket}
is an array-like object that contains items of type \VAR{T}.  The
length of a heap sequence is in general not known statically, but can be discovered
by asking for its length.  A variable of type \EXP{\TYP{HeapSequence}\llbracket{}T\rrbracket} occupies the
amount of storage required to hold a reference; this reference refers to an
object that occupies an amount of storage greater than or equal to the amount
that would be occupied by a variable of type \EXP{\TYP{LinearSequence}\llbracket{}T,n\rrbracket}
where \VAR{n} is the length of
the heap sequence.

Heap sequences, like linear sequences and unlike arrays, are not too fancy. The main
things you can do with heap sequences are subscripting and subscripted assignment.
Concatenation is \emph{not} supported, because a basic principle of the low-level types is that
none of the operations, other than explicit construction of a heap sequence,
does any heap allocation.  However, a range of static size may be used to
index a heap sequence; the result is a linear sequence.

%% trait HeapSequence[\T extends Any\] comprises { ... }
%%   opr [j: IndexInt]: T throws { IndexOutOfBounds }
%%   opr [\nat m\] [r: RangeOfStaticSize[\IndexInt,m\]]: LinearSequence[\T,m\]
%%     throws { IndexOutOfBounds }
%%   opr [j:IndexInt] := (v: T): () throws { IndexOutOfBounds }
%%   opr [\nat m\] [r: RangeOfStaticSize[\IndexInt,m\]] := (v: LinearSequence[\T,m\]): ()
%%     throws { IndexOutOfBounds }
%%   reverse(selfStart: IndexInt, length: IndexInt): () throws { IndexOutOfBounds }
%%   opr |self| : IndexInt
%% end
\begin{Fortress}
\(\KWD{trait} \TYP{HeapSequence}\llbracket{}T \KWD{extends} \TYP{Any}\rrbracket \KWD{comprises} \{\,\ldots\,\}\)\\
{\tt~~}\pushtabs\=\+\(  \KWD{opr} [j\COLON \TYP{IndexInt}]\COLON T \KWD{throws} \{\,\TYP{IndexOutOfBounds}\,\}\)\\
\(  \KWD{opr} \llbracket\KWD{nat} m\rrbracket [r\COLON \TYP{RangeOfStaticSize}\llbracket\TYP{IndexInt},m\rrbracket]\COLON \TYP{LinearSequence}\llbracket{}T,m\rrbracket\)\\
{\tt~~}\pushtabs\=\+\(    \KWD{throws} \{\,\TYP{IndexOutOfBounds}\,\}\)\-\\\poptabs
\(  \KWD{opr} [j\COLONOP\TYP{IndexInt}] \ASSIGN (v\COLON T)\COLON () \KWD{throws} \{\,\TYP{IndexOutOfBounds}\,\}\)\\
\(  \KWD{opr} \llbracket\KWD{nat} m\rrbracket [r\COLON \TYP{RangeOfStaticSize}\llbracket\TYP{IndexInt},m\rrbracket] \ASSIGN (v\COLON \TYP{LinearSequence}\llbracket{}T,m\rrbracket)\COLON ()\)\\
{\tt~~}\pushtabs\=\+\(    \KWD{throws} \{\,\TYP{IndexOutOfBounds}\,\}\)\-\\\poptabs
\(  \VAR{reverse}(\VAR{selfStart}\COLON \TYP{IndexInt}, \VAR{length}\COLON \TYP{IndexInt})\COLON () \KWD{throws} \{\,\TYP{IndexOutOfBounds}\,\}\)\\
\(  \KWD{opr} \left|\mathord{\KWD{self}}\right| \mathrel{\mathtt{:}} \TYP{IndexInt}\)\-\\\poptabs
\(\KWD{end}\)
\end{Fortress}



%%   opr [j: IndexInt]: T throws { IndexOutOfBounds }
\Method{\EXP{\KWD{opr} [j\COLON \TYP{IndexInt}]\COLON T \KWD{throws} \{\,\TYP{IndexOutOfBounds}\,\}}}

Subscripting returns element \VAR{j} of this heap sequence.
Indexing is zero-origin; an \TYP{IndexOutOfBounds} is thrown unless \EXP{0\leq{}j<n},
where \VAR{n} is the length of the heap sequence.


%%   opr [\nat m\] [r: RangeOfStaticSize[\IndexInt,m\]]: LinearSequence[\T,m\]
%%     throws { IndexOutOfBounds }
\Method{\EXP{\KWD{opr} \llbracket\KWD{nat} m\rrbracket [r\COLON \TYP{RangeOfStaticSize}\llbracket\TYP{IndexInt},m\rrbracket]\COLON \TYP{LinearSequence}\llbracket{}T,m\rrbracket}\\
{\tt~~}\EXP{\KWD{throws} \{\,\TYP{IndexOutOfBounds}\,\}}}

Subscripting by a range returns the indicated subsequence of this heap sequence.
The range must be a range of static size, and the result is returned as a linear sequence
(not a heap sequence), so no heap allocation is performed.
Indexing is zero-origin; an \TYP{IndexOutOfBounds} is thrown unless \EXP{r \subseteq (0\COLONOP{}n-1)},
where \VAR{n} is the length of the heap sequence.
Element \VAR{k} of the result linear sequence is the same as
element \EXP{r.\VAR{lowerBound} + k \times r.\VAR{stride}} of this heap sequence, for all \EXP{0\leq{}k<m}.


%%   opr [j:IndexInt] := (v: T): () throws { IndexOutOfBounds }
\Method{\EXP{\KWD{opr} [j\COLONOP\TYP{IndexInt}] \ASSIGN (v\COLON T)\COLON () \KWD{throws} \{\,\TYP{IndexOutOfBounds}\,\}}}

After subscripted assignment, element \VAR{j} of this heap sequence is the same as the given value \VAR{v},
and all other elements are the same as before.
Indexing is zero-origin; an \TYP{IndexOutOfBounds} is thrown unless \EXP{0\leq{}j<n},
where \VAR{n} is the length of the heap sequence.


%%   opr [\nat m\] [r: RangeOfStaticSize[\IndexInt,m\]] := (v: LinearSequence[\T,m\]): ()
%%     throws { IndexOutOfBounds }
\Method{\EXP{\KWD{opr} \llbracket\KWD{nat} m\rrbracket [r\COLON \TYP{RangeOfStaticSize}\llbracket\TYP{IndexInt},m\rrbracket] \ASSIGN (v\COLON \TYP{LinearSequence}\llbracket{}T,m\rrbracket)\COLON ()}\\
\hbox{\tt~~}\EXP{\KWD{throws} \{\,\TYP{IndexOutOfBounds}\,\}}}

After subscripted assignment using a range as a subscript, elements of the subscripted variable selected by \VAR{r}
are the same as corresponding elements of \VAR{v}, and all other elements are the same as before;
specifically, element \EXP{r.\VAR{lowerBound} + k \times r.\VAR{stride}} of the updated
variable is the same as element \VAR{k} of \VAR{v}, for all \EXP{0\leq{}k<m}.
The range must be a range of static size, and the values to be assigned
must be passed as linear sequence of the same size.
Indexing is zero-origin; an \TYP{IndexOutOfBounds} is thrown unless \EXP{r \subseteq (0\COLONOP{}n-1)},
where \VAR{n} is the length of the heap sequence.


%%   reverse(selfStart: IndexInt, length: IndexInt): () throws { IndexOutOfBounds }
\Method{\EXP{\VAR{reverse}(\VAR{selfStart}\COLON \TYP{IndexInt}, \VAR{length}\COLON \TYP{IndexInt})\COLON () \KWD{throws} \{\,\TYP{IndexOutOfBounds}\,\}}}

Elements \VAR{selfStart} through \EXP{\VAR{selfStart}+\VAR{length}-1}, inclusive, are reversed in order,
that is, rearranged
so that the value originally stored at element \EXP{\VAR{selfStart}+j} becomes element
\EXP{\VAR{selfStart}+\VAR{length}-1-j}, for all \EXP{0\leq{}j<\VAR{length}}.
Other elements of this heap sequence are unaffected.


%%   opr |self| : IndexInt
\Method{\EXP{\KWD{opr} \left|\mathord{\KWD{self}}\right| \mathrel{\mathtt{:}} \TYP{IndexInt}}}

The length of this heap sequence is returned.  Note that the size of a heap sequence is specified
at run time when the heap sequence is created;  once a heap sequence has been created,
its length does not change.


\section{Constructing Heap Sequences}

%% makeHeapSequence[\T extends Any\](n: IndexInt, item: T): HeapSequence[\T\]
%%   throws { NegativeLength }
\Method{\EXP{\VAR{makeHeapSequence}\llbracket{}T \KWD{extends} \TYP{Any}\rrbracket(n\COLON \TYP{IndexInt}, \VAR{item}\COLON T)\COLON \TYP{HeapSequence}\llbracket{}T\rrbracket}\\
{\tt~~}\EXP{\KWD{throws} \{\,\TYP{NegativeLength}\,\}}}
\seclabel{lib:makeHeapSequence}

A new heap sequence of length \VAR{n} is allocated and returned.
A \TYP{NegativeLength} is thrown if \EXP{n<0}.
Every element of the heap sequence is initialized to be the same as the given \VAR{item}.


%% computeHeapSequence[\T extends Any\](n: IndexInt, f: IndexInt->T): HeapSequence[\T\]
%%   throws { NegativeLength }
\Method{\EXP{\VAR{computeHeapSequence}\llbracket{}T \KWD{extends} \TYP{Any}\rrbracket(n\COLON \TYP{IndexInt}, f\COLON \TYP{IndexInt}\rightarrow{}T)\COLON \TYP{HeapSequence}\llbracket{}T\rrbracket}\\
{\tt~~}\EXP{\KWD{throws} \{\,\TYP{NegativeLength}\,\}}}
\seclabel{lib:computeHeapSequence}

A new heap sequence of length \VAR{n} is allocated and returned.
A \TYP{NegativeLength} is thrown if \EXP{n<0}.
Element \VAR{j} of the new heap sequence is initialized to a value
computed by calling the given function \VAR{f} with argument \VAR{j}.




\Trait{Fortress.Core.BinaryWord}
\seclabel{lib:BinaryWord}

A value of type \EXP{\TYP{BinaryWord}\llbracket{}b\rrbracket}
is a binary word of $2^b$ bits; $b$ may be any natural number,
so \EXP{\TYP{BinaryWord}\llbracket{}0\rrbracket}
is a bit, \EXP{\TYP{BinaryWord}\llbracket{}3\rrbracket} is a byte,
\EXP{\TYP{BinaryWord}\llbracket{}6\rrbracket} is a 64-bit word, and
\EXP{\TYP{BinaryWord}\llbracket{}10\rrbracket} is a 1024-bit word.
In fact, for convenience, the type abbreviations \TYP{Bit} and \TYP{Byte}
are defined:

%% type Bit = BinaryWord[\0\]
%% type Byte = BinaryWord[\3\]
\begin{Fortress}
\(\KWD{type} \TYP{Bit} = \TYP{BinaryWord}\llbracket{}0\rrbracket\)\\
\(\KWD{type} \TYP{Byte} = \TYP{BinaryWord}\llbracket{}3\rrbracket\)
\end{Fortress}

The type \EXP{\TYP{BinaryWord}\llbracket{}b\rrbracket} has \EXP{2^{(2^{b})}}
distinct values.  When the binary word is regarded as an unsigned
integer, these values are identified with the nonnegative integers
that are less than \EXP{2^{(2^{b})}}.
A binary word may also be regarded as a signed integer:
a value that, when regarded as an unsigned integer,
is identified with an integer less than \EXP{2^{(2^{b}-1)}},
is identified with that same integer when regarded as a signed integer;
but a value that, when regarded as an unsigned integer,
is identified with an integer not less than \EXP{2^{(2^{b}-1)}},
is identified with that same integer less \EXP{2^{(2^{b})}}.
(This is the standard ``two's complement'' representation
for signed integers.)

A binary word of one bit can have one of two values, 0 or 1.
A binary word of more than one bit has two halves, a high half and a low half,
which are binary words of half the size.  If \VAR{v} is the unsigned integer value of a binary word of
\EXP{2^{b}} bits, \EXP{b\geq{}1}, \VAR{h} is the unsigned integer value of its high half,
and \VAR{l} is the unsigned integer value of its low half,
then \EXP{v = h \cdot 2^{2^{b-1}} + l}.

Operations on binary words include bitwise boolean operations, arithmetic operations,
shifts and rotates, population count, and counting of leading and trailing zeros.
The type \EXP{\TYP{BinaryWord}\llbracket{}b\rrbracket}
is not ``endian'' and has no operations that depend on endianness.
However, if \VAR{w} is binary word,
then \EXP{w.\VAR{littleEndian}} is a little-endian version of \VAR{w}
and \EXP{w.\VAR{bigEndian}} is a big-endian version of \VAR{w}; for example,
if \VAR{w} is of type \EXP{\TYP{BinaryWord}\llbracket{}6\rrbracket}, then
\EXP{w.\VAR{littleEndian}_{63}} is the most significant bit
(the sign bit if the word is regarded as a two's-complement integer),
and \EXP{w.\VAR{bigEndian}_{0}} is that same bit.


%% trait BinaryWord[\nat b\] extends { BasicBinaryWordOperations[\BinaryWord[\b\]\] }
%%     comprises { ... }
%%     where { b <= maxBinaryWordBitLog }
%%   coerce[\int r\](x: IntegerStatic[\r\]) where { -2^(b-1) <= r < 2^b }
%%   coerce[\bool bigEndianBytes,bool bigEndianBits\]
%%      (x: BinaryEndianWord[\b,bigEndianBytes,bigEndianBits\])
%%   coerce[\nat b',nat n,bool bigEndianSequence\]
%%      (x: BinaryLinearEndianSequence[\b',n,bigEndianSequence\])
%%     where { 2^b = n DOT 2^b' }
%%   coerce[\nat b',bool bigEndianBytes,bool bigEndianBits,nat n,bool bigEndianSequence\]
%%      (x: BinaryEndianLinearEndianSequence[\b',bigEndianBytes,bigEndianBits,
%%                                            n,bigEndianSequence\])
%%     where { 2^b = n DOT 2^b' }
%%   bit(m: IndexInt): Bit
%%   getter lowHalf(): BinaryWord[\b-1\] where { b > 0 }
%%   getter highHalf(): BinaryWord[\b-1\] where { b > 0 }
%%   opr || [\nat m\](self, other: BinaryWord[\b\]): BinaryWord[\b+1\]
%%     where { b < maxBinaryWordBitLog }
%%   bitShuffle(other: BinaryWord[\b\]): BinaryWord[\b+1\]
%%     where { b < maxBinaryWordBitLog }
%%   bitUnshuffle(): (BinaryWord[\b-1\], BinaryWord[\b-1\]) where { b > 0 }
%% end
\begin{Fortress}
\(\KWD{trait} \TYP{BinaryWord}\llbracket\KWD{nat} b\rrbracket \KWD{extends} \{\,\TYP{BasicBinaryWordOperations}\llbracket\TYP{BinaryWord}\llbracket{}b\rrbracket\rrbracket\,\}\)\\
{\tt~~~~}\pushtabs\=\+\(    \KWD{comprises} \{\,\ldots\,\}\)\\
\(    \KWD{where} \{\,b \leq \VAR{maxBinaryWordBitLog}\,\}\)\-\\\poptabs
{\tt~~}\pushtabs\=\+\(  \KWD{coerce}\llbracket\KWD{int} r\rrbracket(x\COLON \TYP{IntegerStatic}\llbracket{}r\rrbracket) \KWD{where} \{\,-2^{b-1} \leq r < 2^{b}\,\}\)\\
\(  \KWD{coerce}\llbracket\KWD{bool} \VAR{bigEndianBytes},\KWD{bool} \VAR{bigEndianBits}\rrbracket\)\\
{\tt~~~}\pushtabs\=\+\(     (x\COLON \TYP{BinaryEndianWord}\llbracket{}b,\VAR{bigEndianBytes},\VAR{bigEndianBits}\rrbracket)\)\-\\\poptabs
\(  \KWD{coerce}\llbracket\KWD{nat} b',\KWD{nat} n,\KWD{bool} \VAR{bigEndianSequence}\rrbracket\)\\
{\tt~~~}\pushtabs\=\+\(     (x\COLON \TYP{BinaryLinearEndianSequence}\llbracket{}b',n,\VAR{bigEndianSequence}\rrbracket)\)\-\\\poptabs
{\tt~~}\pushtabs\=\+\(    \KWD{where} \{\,2^{b} = n \cdot 2^{b'}\,\}\)\-\\\poptabs
\(  \KWD{coerce}\llbracket\KWD{nat} b',\KWD{bool} \VAR{bigEndianBytes},\KWD{bool} \VAR{bigEndianBits},\KWD{nat} n,\KWD{bool} \VAR{bigEndianSequence}\rrbracket\)\\
{\tt~~~}\pushtabs\=\+\(     (x\COLON \TYP{BinaryEndianLinearEndianSequence}\llbracket\null\)\pushtabs\=\+\(b',\VAR{bigEndianBytes},\VAR{bigEndianBits},\)\\
\(                                           n,\VAR{bigEndianSequence}\rrbracket)\)\-\-\\\poptabs\poptabs
{\tt~~}\pushtabs\=\+\(    \KWD{where} \{\,2^{b} = n \cdot 2^{b'}\,\}\)\-\\\poptabs
\(  \VAR{bit}(m\COLON \TYP{IndexInt})\COLON \TYP{Bit}\)\\
\(  \KWD{getter} \VAR{lowHalf}()\COLON \TYP{BinaryWord}\llbracket{}b-1\rrbracket \KWD{where} \{\,b > 0\,\}\)\\
\(  \KWD{getter} \VAR{highHalf}()\COLON \TYP{BinaryWord}\llbracket{}b-1\rrbracket \KWD{where} \{\,b > 0\,\}\)\\
\(  \KWD{opr}\,\|\,\llbracket\KWD{nat} m\rrbracket(\KWD{self}, \VAR{other}\COLON \TYP{BinaryWord}\llbracket{}b\rrbracket)\COLON \TYP{BinaryWord}\llbracket{}b+1\rrbracket\)\\
{\tt~~}\pushtabs\=\+\(    \KWD{where} \{\,b < \VAR{maxBinaryWordBitLog}\,\}\)\-\\\poptabs
\(  \VAR{bitShuffle}(\VAR{other}\COLON \TYP{BinaryWord}\llbracket{}b\rrbracket)\COLON \TYP{BinaryWord}\llbracket{}b+1\rrbracket\)\\
{\tt~~}\pushtabs\=\+\(    \KWD{where} \{\,b < \VAR{maxBinaryWordBitLog}\,\}\)\-\\\poptabs
\(  \VAR{bitUnshuffle}()\COLON (\TYP{BinaryWord}\llbracket{}b-1\rrbracket, \TYP{BinaryWord}\llbracket{}b-1\rrbracket) \KWD{where} \{\,b > 0\,\}\)\-\\\poptabs
\(\KWD{end}\)
\end{Fortress}


%%   coerce[\int r\](x: IntegerStatic[\r\]) where { -2^(b-1) <= r < 2^b }
\Method{\EXP{\KWD{coerce}\llbracket\KWD{int} r\rrbracket(x\COLON \TYP{IntegerStatic}\llbracket{}r\rrbracket) \KWD{where} \{\,-2^{b-1} \leq r < 2^{b}\,\}}}

An static integer may be coerced to a binary word that corresponds to
that integer value when interpreted as either a signed integer or an unsigned integer.
For example, the type \EXP{\TYP{BinaryWord}\llbracket{}3\rrbracket} has \EXP{2^{(2^{3})}=256} distinct
binary word values; when they are interpreted as signed integers, the integer values range from $-128$ to $127$,
and when they are interpreted as unsigned integers, the integer values range from $0$ to $255$.
Therefore any static integer from $-128$ to $255$ may be coerced to type \EXP{\TYP{BinaryWord}\llbracket{}3\rrbracket}.


%%   coerce[\bool bigEndianBytes,bool bigEndianBits\]
%%      (x: BinaryEndianWord[\b,bigEndianBytes,bigEndianBits\])
\Method{\EXP{\KWD{coerce}\llbracket\KWD{bool} \VAR{bigEndianBytes},\KWD{bool} \VAR{bigEndianBits}\rrbracket}\\
{\tt~~~}\EXP{(x\COLON \TYP{BinaryEndianWord}\llbracket{}b,\VAR{bigEndianBytes},\VAR{bigEndianBits}\rrbracket)}}

Any binary endian word may be coerced to a plain binary word of the same size and value.
In effect, this coercion merely discards the endianness information.


%%   coerce[\nat b',nat n,bool bigEndianSequence\]
%%      (x: BinaryLinearEndianSequence[\b',n,bigEndianSequence\])
%%     where { 2^b = n DOT 2^b' }
\Method{\EXP{\KWD{coerce}\llbracket\KWD{nat} b',\KWD{nat} n,\KWD{bool} \VAR{bigEndianSequence}\rrbracket}\\
{\tt~~~}\EXP{(x\COLON \TYP{BinaryLinearEndianSequence}\llbracket{}b',n,\VAR{bigEndianSequence}\rrbracket)}\\
{\tt~~}\EXP{\KWD{where} \{\,2^{b} = n \cdot 2^{b'}\,\}}}

A binary linear endian sequence of smaller binary words may be coerced to a single binary word,
provided that the length of the linear sequence is an appropriate power of two, so that the
total number of bits in the sequence is the same as the total number of bits in the resulting
binary word.  The manner in which the elements of the sequence are used to form the new binary word value
respects the endianness of the sequence, so that element 0 of the sequence supplies the most significant
bits of the result if \VAR{bigEndianSequence} is true, but supplies the least significant
bits of the result if \VAR{bigEndianSequence} is false.


%%   coerce[\nat b',bool bigEndianBytes,bool bigEndianBits,nat n,bool bigEndianSequence\]
%%      (x: BinaryEndianLinearEndianSequence[\b',bigEndianBytes,bigEndianBits,
%%                                            n,bigEndianSequence\])
%%     where { 2^b = n DOT 2^b' }
\Method{\EXP{\KWD{coerce}\llbracket\KWD{nat} b',\KWD{bool} \VAR{bigEndianBytes},\KWD{bool} \VAR{bigEndianBits},\KWD{nat} n,\KWD{bool} \VAR{bigEndianSequence}\rrbracket}\\
{\tt~~~}\EXP{(x\COLON \TYP{BinaryEndianLinearEndianSequence}\llbracket{}b',\VAR{bigEndianBytes},\VAR{bigEndianBits},}\\
{\tt~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~}\EXP{n,\VAR{bigEndianSequence}\rrbracket)}\\
{\tt~~}\EXP{\KWD{where} \{\,2^{b} = n \cdot 2^{b'}\,\}}}

A binary endian linear endian sequence of smaller binary endian words may be coerced to a single binary word,
provided that the length of the linear sequence is an appropriate power of two, so that the
total number of bits in the sequence is the same as the total number of bits in the resulting
binary word.  The manner in which the elements of the sequence are used to form the new binary word value
respects the endianness of the sequence, so that element 0 of the sequence supplies the most significant
bits of the result if \VAR{bigEndianSequence} is true, but supplies the least significant
bits of the result if \VAR{bigEndianSequence} is false.  In effect, the ``bytes and bits'' endianness information
is simply ignored and discarded.


%%   bit(m: IndexInt): Bit
\Method{\EXP{\VAR{bit}(m\COLON \TYP{IndexInt})\COLON \TYP{Bit}}}

The result is a bit whose value (0 or 1) is equal to \EXP{\lfloor v \cdot 2^{-m} \rfloor \bmod 2}
where \VAR{v} is the value of the binary word regarded as an unsigned integer.  This formula holds
for any value of \VAR{m}; note that if \VAR{m} is negative or greater than \EXP{2^{b}-1},
the result will always be a 0-bit.  Thus the \VAR{bit} method provides a kind of ``little-endian''
indexing of the bits of a binary word, even a binary word whose type is not intrinsically
endian, but it does not require that the bit number identify an actual represented bit of the binary word.

The \VAR{bit} method is particularly useful for describing the behavioral properties of
other methods of binary data.


%%   getter lowHalf(): BinaryWord[\b-1\] where { b > 0 }
%%   getter highHalf(): BinaryWord[\b-1\] where { b > 0 }
\Method{\EXP{\KWD{getter} \VAR{lowHalf}()\COLON \TYP{BinaryWord}\llbracket{}b-1\rrbracket \KWD{where} \{\,b > 0\,\}}}
\Method*{\EXP{\KWD{getter} \VAR{highHalf}()\COLON \TYP{BinaryWord}\llbracket{}b-1\rrbracket \KWD{where} \{\,b > 0\,\}}}

The getters \VAR{lowHalf} and \VAR{highHalf} each return a binary word of half the size (in bits)
of this binary word; \VAR{lowHalf} returns the less significant bits, and \VAR{highHalf} returns
the more significant bits.

%%   property FORALL(v) AND[m<-0#2^(b-1)] v.lowHalf.bit(m) = v.bit(m)
%%   property FORALL(v) AND[m<-0#2^(b-1)] v.highHalf.bit(m) = v.bit(m+2^(b-1))
\begin{Fortress}
{\tt~~}\pushtabs\=\+\(  \KWD{property} \forall(v)\; \bigwedge\limits_{m\leftarrow{}0\mathinner{\hbox{\tt\char'43}}2^{b-1}} v.\VAR{lowHalf}.\VAR{bit}(m) = v.\VAR{bit}(m)\)\\
\(  \KWD{property} \forall(v)\; \bigwedge\limits_{m\leftarrow{}0\mathinner{\hbox{\tt\char'43}}2^{b-1}} v.\VAR{highHalf}.\VAR{bit}(m) = v.\VAR{bit}(m+2^{b-1})\)\-\\\poptabs
\end{Fortress}


%%   opr || [\nat m\](self, other: BinaryWord[\b\]): BinaryWord[\b+1\]
%%     where { b < maxBinaryWordBitLog }
\Method{\EXP{\KWD{opr}\,\|\,\llbracket\KWD{nat} m\rrbracket(\KWD{self}, \VAR{other}\COLON \TYP{BinaryWord}\llbracket{}b\rrbracket)\COLON \TYP{BinaryWord}\llbracket{}b+1\rrbracket}\\
{\tt~~}\EXP{\KWD{where} \{\,b < \VAR{maxBinaryWordBitLog}\,\}}}

The result of concatenating two binary words of size \EXP{2^{b}} is a single binary
word of size \EXP{2^{b+1}}.  The left-hand operand becomes the high (more significant) half of the result
and the right-hand operand becomes the low (less significant) half of the result.

%%   property FORALL (v,w) (v || w).highHalf = v
%%   property FORALL (v,w) (v || w).lowHalf = w
\begin{Fortress}
{\tt~~}\pushtabs\=\+\(  \KWD{property} \forall (v,w)\; (v\,\|\,w).\VAR{highHalf} = v\)\\
\(  \KWD{property} \forall (v,w)\; (v\,\|\,w).\VAR{lowHalf} = w\)\-\\\poptabs
\end{Fortress}


%%   bitShuffle(other: BinaryWord[\b\]): BinaryWord[\b+1\]
%%     where { b < maxBinaryWordBitLog }
\Method{\EXP{\VAR{bitShuffle}(\VAR{other}\COLON \TYP{BinaryWord}\llbracket{}b\rrbracket)\COLON \TYP{BinaryWord}\llbracket{}b+1\rrbracket}\\
{\tt~~}\EXP{\KWD{where} \{\,b < \VAR{maxBinaryWordBitLog}\,\}}}

The bit-shuffle operation interleaves the bits of two words, as if shuffling cards together
(using what magicians call a ``perfect shuffle'').
The result of shuffling the bits two binary words of size \EXP{2^{b}} is a single binary
word of size \EXP{2^{b+1}}.
This binary word provides the odd-numbered bits of the result
and the other binary word provides the even-numbered bits of the result.
For example, shuffling \STR{1111} and \STR{0000} produces \STR{10101010}.

%%   property FORALL(v, w, m: IndexInt) v.bitShuffle(w).bit(m) = (if odd m then v.bit((m-1)/2) else w.bit(m/2))
\begin{Fortress}
{\tt~~}\pushtabs\=\+\(  \KWD{property} \forall(v, w, m\COLON \TYP{IndexInt})\; v.\VAR{bitShuffle}(w).\VAR{bit}(m) = (\KWD{if} \VAR{odd}\mskip 4mu plus 4mu{m} \KWD{then} v.\VAR{bit}((m-1)/2) \KWD{else} w.\VAR{bit}(m/2))\)\-\\\poptabs
\end{Fortress}


%%   bitUnshuffle(): (BinaryWord[\b-1\], BinaryWord[\b-1\]) where { b > 0 }
\Method{\EXP{\VAR{bitUnshuffle}()\COLON (\TYP{BinaryWord}\llbracket{}b-1\rrbracket, \TYP{BinaryWord}\llbracket{}b-1\rrbracket) \KWD{where} \{\,b > 0\,\}}}

This is the inverse of the \VAR{bitShuffle} method: the odd-numbered bits of this binary word
are used to form a binary word of half the size, and likewise the even-numbered bits,
and a tuple of the two binary words is returned.

%%   property FORALL(v,w) v.bitShuffle(w).bitUnshuffle() = (v,w)
\begin{Fortress}
{\tt~~}\pushtabs\=\+\(  \KWD{property} \forall(v,w)\; v.\VAR{bitShuffle}(w).\VAR{bitUnshuffle}() = (v,w)\)\-\\\poptabs
\end{Fortress}


\Trait{Fortress.Core.BinaryEndianWord}
\seclabel{lib:BinaryEndianWord}

The type \EXP{\TYP{BinaryEndianWord}\llbracket{}b,\VAR{bigEndianBytes},\VAR{bigEndianBits}\rrbracket} is exactly
like \EXP{\TYP{BinaryWord}\llbracket{}b\rrbracket} but bears two kinds of endianness information.  A
\TYP{BinaryEndianWord} may be split into a sequence of smaller words; the result is of
type \TYP{BinaryLinearEndianSequence}.  The flag \VAR{bigEndianBytes} indicates whether
subword 0 is the most significant subword (if \VAR{bigEndianBytes} is true) or least
significant subword (if \VAR{bigEndianBytes} is false) of the original binary word.  A
\TYP{BinaryEndianWord} may also be subscripted to extract a bit or a bit field; the
flag \VAR{bigEndianBits} indicates whether bit 0 is the most significant bit (if
\VAR{bigEndianBits} is true) or least significant bit (if \VAR{bigEndianBits} is false) of
the original binary word.  (Yes, it may seem strange for the bit ordering to differ
from the subword ordering, but they do differ on a number of architectures, including SPARC.)
Extracting a bit produces a \TYP{Bit}, that is, a \EXP{\TYP{BinaryWord}\llbracket{}0\rrbracket}.
Extracting a bit field of width \VAR{k} produces a
\TYP{BinaryEndianLinearEndianSequence} with \EXP{n=k} and \EXP{b=0}; the endianness of
the sequence matches the bit-endianness of the original \TYP{BinaryEndianWord}.


%% trait BinaryEndianWord[\nat b, bool bigEndianBytes, bool bigEndianBits\]
%%     extends { BasicBinaryWordOperations[\BinaryEndianWord[\b,bigEndianBytes,bigEndianBits\],b\]}
%%     comprises { ... }
%%     where { b <= maxBinaryWordBitLog }
%%   coerce[\int r\](x: IntegerStatic[\r\]) where { -2^(b-1) <= r < 2^b }
%%   opr [j: IndexInt] : BinaryEndianWord[\1,bigEndianBytes,bigEndianBits\]
%%     throws { IndexOutOfBounds }
%%   opr [\nat k\] [j: IntegerStatic[\k\]] : BinaryEndianWord[\1,bigEndianBytes,bigEndianBits\]
%%     where { k < 2^b }
%%   opr [\nat m\] [r: RangeOfStaticSize[\IndexInt,m\]] :
%%      BinaryEndianLinearEndianSequence[\1,bigEndianBytes,bigEndianBits,m,bigEndianBits\]
%%     throws { IndexOutOfBounds }
%%   opr [\int a,nat m,int c\] [r: StaticRange[\a,m,c\]] :
%%      BinaryEndianLinearEndianSequence[\1,bigEndianBytes,bigEndianBits,m,bigEndianBits\]
%%     where { 0 <= a < 2^b, 0 <= a + m DOT c < 2^b }
%%   opr [j: IndexInt] := (v: Bit):
%%      BinaryEndianWord[\b,bigEndianBytes,bigEndianBits\]
%%     throws { IndexOutOfBounds }
%%   opr [\nat k\] [j: IntegerStatic[\k\]] := (v: Bit):
%%      BinaryEndianWord[\b,bigEndianBytes,bigEndianBits\]
%%     where { k < 2^b }
%%   opr [\nat m\] [r: RangeOfStaticSize[\IndexInt,m\]] := (v: BinaryLinearSequence[\1,m\]):
%%      BinaryEndianWord[\b,bigEndianBytes,bigEndianBits\]
%%     throws { IndexOutOfBounds }
%%   opr [\int a,nat m,int c\] [r: StaticRange[\a,m,c\]] := (v: BinaryLinearSequence[\1,k\]):
%%      BinaryEndianWord[\b,bigEndianBytes,bigEndianBits\]
%%     where { 0 <= a < 2^b, 0 <= a + m DOT c < 2^b }
%%   update(j: IndexInt, v: Bit):
%%      BinaryEndianWord[\b,bigEndianBytes,bigEndianBits\]
%%     throws { IndexOutOfBounds }
%%   update[\nat k\](j: IntegerStatic[\k\], v: Bit):
%%      BinaryEndianWord[\b,bigEndianBytes,bigEndianBits\]
%%     where { k < 2^b }
%%   update[\nat m\](r: RangeOfStaticSize[\IndexInt,m\], v: BinaryLinearSequence[\1,m\]):
%%      BinaryEndianWord[\b,bigEndianBytes,bigEndianBits\]
%%     throws { IndexOutOfBounds }
%%   update[\int a,nat m,int c\](r: StaticRange[\a,m,c\], v: BinaryLinearSequence[\1,m\]):
%%      BinaryEndianWord[\b,bigEndianBytes,bigEndianBits\]
%%     where { 0 <= a < 2^b, 0 <= a + m DOT c < 2^b }
%%   lowHalf(): BinaryEndianWord[\b-1,bigEndianBytes,bigEndianBits\] where { b > 0 }
%%   highHalf(): BinaryEndianWord[\b-1,bigEndianBytes,bigEndianBits\] where { b > 0 }
%%   opr || [\nat m,bool bigEndianSequence\]
%%      (self, other: BinaryEndianWord[\b,bigEndianBytes,bigEndianBits\]):
%%      BinaryEndianLinearEndianSequence[\b+1,bigEndianBytes,bigEndianBits,
%%                                        2,bigEndianSequence\]
%%     where { bigEndianSequence = bigEndianBytes }
%%   opr || [\nat m,bool bigEndianSequence,nat radix,nat q,nat k,nat v\]
%%      (self, other: NaturalNumeral[\m,radix,v\]):
%%      BinaryEndianLinearEndianSequence[\b,bigEndianBytes,bigEndianBits,
%%                                        k+1,bigEndianSequence\]
%%     where { bigEndianSequence = bigEndianBytes, radix = 2^q, q DOT m = k DOT 2^b }
%%   opr || [\nat m,bool bigEndianSequence,nat radix,nat q,nat k,nat v\]
%%      (other: NaturalNumeral[\m,radix,v\], self):
%%      BinaryEndianLinearEndianSequence[\b,bigEndianBytes,bigEndianBits,
%%                                        k+1,bigEndianSequence\]
%%     where { bigEndianSequence = bigEndianBytes, radix = 2^q, q DOT m = k DOT 2^b }
%%   bitShuffle(other: BinaryEndianWord[\b,bigEndianBytes,bigEndianBits\]):
%%     BinaryEndianWord[\b+1,bigEndianBytes,bigEndianBits\]
%%     where { b < maxBinaryWordBitLog }
%%   bitUnshuffle(): (BinaryEndianWord[\b-1,bigEndianBytes,bigEndianBits\],
%%                    BinaryEndianWord[\b-1,bigEndianBytes,bigEndianBits\])
%%     where { b > 0 }
%%   littleEndian(): BinaryEndianWord[\b,false,false\]
%%   bigEndian(): BinaryEndianWord[\b,true,true\]
%% end
\begin{Fortress}
\(\KWD{trait} \TYP{BinaryEndianWord}\llbracket\KWD{nat} b, \KWD{bool} \VAR{bigEndianBytes}, \KWD{bool} \VAR{bigEndianBits}\rrbracket\)\\
{\tt~~~~}\pushtabs\=\+\(    \KWD{extends} \{\,\TYP{BasicBinaryWordOperations}\llbracket\TYP{BinaryEndianWord}\llbracket{}b,\VAR{bigEndianBytes},\VAR{bigEndianBits}\rrbracket,b\rrbracket\}\)\\
\(    \KWD{comprises} \{\,\ldots\,\}\)\\
\(    \KWD{where} \{\,b \leq \VAR{maxBinaryWordBitLog}\,\}\)\-\\\poptabs
{\tt~~}\pushtabs\=\+\(  \KWD{coerce}\llbracket\KWD{int} r\rrbracket(x\COLON \TYP{IntegerStatic}\llbracket{}r\rrbracket) \KWD{where} \{\,-2^{b-1} \leq r < 2^{b}\,\}\)\\
\(  \KWD{opr} [j\COLON \TYP{IndexInt}] \mathrel{\mathtt{:}} \TYP{BinaryEndianWord}\llbracket{}1,\VAR{bigEndianBytes},\VAR{bigEndianBits}\rrbracket\)\\
{\tt~~}\pushtabs\=\+\(    \KWD{throws} \{\,\TYP{IndexOutOfBounds}\,\}\)\-\\\poptabs
\(  \KWD{opr} \llbracket\KWD{nat} k\rrbracket [j\COLON \TYP{IntegerStatic}\llbracket{}k\rrbracket] \mathrel{\mathtt{:}} \TYP{BinaryEndianWord}\llbracket{}1,\VAR{bigEndianBytes},\VAR{bigEndianBits}\rrbracket\)\\
{\tt~~}\pushtabs\=\+\(    \KWD{where} \{\,k < 2^{b}\,\}\)\-\\\poptabs
\(  \KWD{opr} \llbracket\KWD{nat} m\rrbracket [r\COLON \TYP{RangeOfStaticSize}\llbracket\TYP{IndexInt},m\rrbracket] \mathrel{\mathtt{:}} \)\\
{\tt~~~}\pushtabs\=\+\(     \TYP{BinaryEndianLinearEndianSequence}\llbracket{}1,\VAR{bigEndianBytes},\VAR{bigEndianBits},m,\VAR{bigEndianBits}\rrbracket\)\-\\\poptabs
{\tt~~}\pushtabs\=\+\(    \KWD{throws} \{\,\TYP{IndexOutOfBounds}\,\}\)\-\\\poptabs
\(  \KWD{opr} \llbracket\KWD{int} a,\KWD{nat} m,\KWD{int} c\rrbracket [r\COLON \TYP{StaticRange}\llbracket{}a,m,c\rrbracket] \mathrel{\mathtt{:}} \)\\
{\tt~~~}\pushtabs\=\+\(     \TYP{BinaryEndianLinearEndianSequence}\llbracket{}1,\VAR{bigEndianBytes},\VAR{bigEndianBits},m,\VAR{bigEndianBits}\rrbracket\)\-\\\poptabs
{\tt~~}\pushtabs\=\+\(    \KWD{where} \{\,0 \leq a < 2^{b}, 0 \leq a + m \cdot c < 2^{b}\,\}\)\-\\\poptabs
\(  \KWD{opr} [j\COLON \TYP{IndexInt}] \ASSIGN (v\COLON \TYP{Bit})\COLON \)\\
{\tt~~~}\pushtabs\=\+\(     \TYP{BinaryEndianWord}\llbracket{}b,\VAR{bigEndianBytes},\VAR{bigEndianBits}\rrbracket\)\-\\\poptabs
{\tt~~}\pushtabs\=\+\(    \KWD{throws} \{\,\TYP{IndexOutOfBounds}\,\}\)\-\\\poptabs
\(  \KWD{opr} \llbracket\KWD{nat} k\rrbracket [j\COLON \TYP{IntegerStatic}\llbracket{}k\rrbracket] \ASSIGN (v\COLON \TYP{Bit})\COLON \)\\
{\tt~~~}\pushtabs\=\+\(     \TYP{BinaryEndianWord}\llbracket{}b,\VAR{bigEndianBytes},\VAR{bigEndianBits}\rrbracket\)\-\\\poptabs
{\tt~~}\pushtabs\=\+\(    \KWD{where} \{\,k < 2^{b}\,\}\)\-\\\poptabs
\(  \KWD{opr} \llbracket\KWD{nat} m\rrbracket [r\COLON \TYP{RangeOfStaticSize}\llbracket\TYP{IndexInt},m\rrbracket] \ASSIGN (v\COLON \TYP{BinaryLinearSequence}\llbracket{}1,m\rrbracket)\COLON \)\\
{\tt~~~}\pushtabs\=\+\(     \TYP{BinaryEndianWord}\llbracket{}b,\VAR{bigEndianBytes},\VAR{bigEndianBits}\rrbracket\)\-\\\poptabs
{\tt~~}\pushtabs\=\+\(    \KWD{throws} \{\,\TYP{IndexOutOfBounds}\,\}\)\-\\\poptabs
\(  \KWD{opr} \llbracket\KWD{int} a,\KWD{nat} m,\KWD{int} c\rrbracket [r\COLON \TYP{StaticRange}\llbracket{}a,m,c\rrbracket] \ASSIGN (v\COLON \TYP{BinaryLinearSequence}\llbracket{}1,k\rrbracket)\COLON \)\\
{\tt~~~}\pushtabs\=\+\(     \TYP{BinaryEndianWord}\llbracket{}b,\VAR{bigEndianBytes},\VAR{bigEndianBits}\rrbracket\)\-\\\poptabs
{\tt~~}\pushtabs\=\+\(    \KWD{where} \{\,0 \leq a < 2^{b}, 0 \leq a + m \cdot c < 2^{b}\,\}\)\-\\\poptabs
\(  \VAR{update}(j\COLON \TYP{IndexInt}, v\COLON \TYP{Bit})\COLON \)\\
{\tt~~~}\pushtabs\=\+\(     \TYP{BinaryEndianWord}\llbracket{}b,\VAR{bigEndianBytes},\VAR{bigEndianBits}\rrbracket\)\-\\\poptabs
{\tt~~}\pushtabs\=\+\(    \KWD{throws} \{\,\TYP{IndexOutOfBounds}\,\}\)\-\\\poptabs
\(  \VAR{update}\llbracket\KWD{nat} k\rrbracket(j\COLON \TYP{IntegerStatic}\llbracket{}k\rrbracket, v\COLON \TYP{Bit})\COLON \)\\
{\tt~~~}\pushtabs\=\+\(     \TYP{BinaryEndianWord}\llbracket{}b,\VAR{bigEndianBytes},\VAR{bigEndianBits}\rrbracket\)\-\\\poptabs
{\tt~~}\pushtabs\=\+\(    \KWD{where} \{\,k < 2^{b}\,\}\)\-\\\poptabs
\(  \VAR{update}\llbracket\KWD{nat} m\rrbracket(r\COLON \TYP{RangeOfStaticSize}\llbracket\TYP{IndexInt},m\rrbracket, v\COLON \TYP{BinaryLinearSequence}\llbracket{}1,m\rrbracket)\COLON \)\\
{\tt~~~}\pushtabs\=\+\(     \TYP{BinaryEndianWord}\llbracket{}b,\VAR{bigEndianBytes},\VAR{bigEndianBits}\rrbracket\)\-\\\poptabs
{\tt~~}\pushtabs\=\+\(    \KWD{throws} \{\,\TYP{IndexOutOfBounds}\,\}\)\-\\\poptabs
\(  \VAR{update}\llbracket\KWD{int} a,\KWD{nat} m,\KWD{int} c\rrbracket(r\COLON \TYP{StaticRange}\llbracket{}a,m,c\rrbracket, v\COLON \TYP{BinaryLinearSequence}\llbracket{}1,m\rrbracket)\COLON \)\\
{\tt~~~}\pushtabs\=\+\(     \TYP{BinaryEndianWord}\llbracket{}b,\VAR{bigEndianBytes},\VAR{bigEndianBits}\rrbracket\)\-\\\poptabs
{\tt~~}\pushtabs\=\+\(    \KWD{where} \{\,0 \leq a < 2^{b}, 0 \leq a + m \cdot c < 2^{b}\,\}\)\-\\\poptabs
\(  \VAR{lowHalf}()\COLON \TYP{BinaryEndianWord}\llbracket{}b-1,\VAR{bigEndianBytes},\VAR{bigEndianBits}\rrbracket \KWD{where} \{\,b > 0\,\}\)\\
\(  \VAR{highHalf}()\COLON \TYP{BinaryEndianWord}\llbracket{}b-1,\VAR{bigEndianBytes},\VAR{bigEndianBits}\rrbracket \KWD{where} \{\,b > 0\,\}\)\\
\(  \KWD{opr}\,\|\,\llbracket\KWD{nat} m,\KWD{bool} \VAR{bigEndianSequence}\rrbracket\)\\
{\tt~~~}\pushtabs\=\+\(     (\KWD{self}, \VAR{other}\COLON \TYP{BinaryEndianWord}\llbracket{}b,\VAR{bigEndianBytes},\VAR{bigEndianBits}\rrbracket)\COLON \)\\
\(     \TYP{BinaryEndianLinearEndianSequence}\llbracket\null\)\pushtabs\=\+\(b+1,\VAR{bigEndianBytes},\VAR{bigEndianBits},\)\\
\(                                       2,\VAR{bigEndianSequence}\rrbracket\)\-\-\\\poptabs\poptabs
{\tt~~}\pushtabs\=\+\(    \KWD{where} \{\,\VAR{bigEndianSequence} = \VAR{bigEndianBytes}\,\}\)\-\\\poptabs
\(  \KWD{opr}\,\|\,\llbracket\KWD{nat} m,\KWD{bool} \VAR{bigEndianSequence},\KWD{nat} \VAR{radix},\KWD{nat} q,\KWD{nat} k,\KWD{nat} v\rrbracket\)\\
{\tt~~~}\pushtabs\=\+\(     (\KWD{self}, \VAR{other}\COLON \TYP{NaturalNumeral}\llbracket{}m,\VAR{radix},v\rrbracket)\COLON \)\\
\(     \TYP{BinaryEndianLinearEndianSequence}\llbracket\null\)\pushtabs\=\+\(b,\VAR{bigEndianBytes},\VAR{bigEndianBits},\)\\
\(                                       k+1,\VAR{bigEndianSequence}\rrbracket\)\-\-\\\poptabs\poptabs
{\tt~~}\pushtabs\=\+\(    \KWD{where} \{\,\VAR{bigEndianSequence} = \VAR{bigEndianBytes}, \VAR{radix} = 2^{q}, q \cdot m = k \cdot 2^{b}\,\}\)\-\\\poptabs
\(  \KWD{opr}\,\|\,\llbracket\KWD{nat} m,\KWD{bool} \VAR{bigEndianSequence},\KWD{nat} \VAR{radix},\KWD{nat} q,\KWD{nat} k,\KWD{nat} v\rrbracket\)\\
{\tt~~~}\pushtabs\=\+\(     (\VAR{other}\COLON \TYP{NaturalNumeral}\llbracket{}m,\VAR{radix},v\rrbracket, \KWD{self})\COLON \)\\
\(     \TYP{BinaryEndianLinearEndianSequence}\llbracket\null\)\pushtabs\=\+\(b,\VAR{bigEndianBytes},\VAR{bigEndianBits},\)\\
\(                                       k+1,\VAR{bigEndianSequence}\rrbracket\)\-\-\\\poptabs\poptabs
{\tt~~}\pushtabs\=\+\(    \KWD{where} \{\,\VAR{bigEndianSequence} = \VAR{bigEndianBytes}, \VAR{radix} = 2^{q}, q \cdot m = k \cdot 2^{b}\,\}\)\-\\\poptabs
\(  \VAR{bitShuffle}(\VAR{other}\COLON \TYP{BinaryEndianWord}\llbracket{}b,\VAR{bigEndianBytes},\VAR{bigEndianBits}\rrbracket)\COLON \)\\
{\tt~~}\pushtabs\=\+\(    \TYP{BinaryEndianWord}\llbracket{}b+1,\VAR{bigEndianBytes},\VAR{bigEndianBits}\rrbracket\)\\
\(    \KWD{where} \{\,b < \VAR{maxBinaryWordBitLog}\,\}\)\-\\\poptabs
\(  \VAR{bitUnshuffle}()\COLON (\null\)\pushtabs\=\+\(\TYP{BinaryEndianWord}\llbracket{}b-1,\VAR{bigEndianBytes},\VAR{bigEndianBits}\rrbracket,\)\\
\(                   \TYP{BinaryEndianWord}\llbracket{}b-1,\VAR{bigEndianBytes},\VAR{bigEndianBits}\rrbracket)\)\-\\\poptabs
{\tt~~}\pushtabs\=\+\(    \KWD{where} \{\,b > 0\,\}\)\-\\\poptabs
\(  \VAR{littleEndian}()\COLON \TYP{BinaryEndianWord}\llbracket{}b,\VAR{false},\VAR{false}\rrbracket\)\\
\(  \VAR{bigEndian}()\COLON \TYP{BinaryEndianWord}\llbracket{}b,\VAR{true},\VAR{true}\rrbracket\)\-\\\poptabs
\(\KWD{end}\)
\end{Fortress}


%%   coerce[\int r\](x: IntegerStatic[\r\]) where { -2^(b-1) <= r < 2^b }
\Method{\EXP{\KWD{coerce}\llbracket\KWD{int} r\rrbracket(x\COLON \TYP{IntegerStatic}\llbracket{}r\rrbracket) \KWD{where} \{\,-2^{b-1} \leq r < 2^{b}\,\}}}

An static integer may be coerced to a binary endian word exactly as if
it were coerced to a plain binary word of the same size; the endian numbering
of the bytes and bits does not affect which binary word value is produced from
the static integer.


%%   opr [j: IndexInt] : BinaryEndianWord[\1,bigEndianBytes,bigEndianBits\]
%%     throws { IndexOutOfBounds }
%%   opr [\nat k\] [j: IntegerStatic[\k\]] : BinaryEndianWord[\1,bigEndianBytes,bigEndianBits\]
%%     where { k < 2^b }
\Method{\EXP{\KWD{opr} [j\COLON \TYP{IndexInt}] \mathrel{\mathtt{:}} \TYP{BinaryEndianWord}\llbracket{}1,\VAR{bigEndianBytes},\VAR{bigEndianBits}\rrbracket}\\
{\tt~~}\EXP{\KWD{throws} \{\,\TYP{IndexOutOfBounds}\,\}}}
\Method*{\EXP{\KWD{opr} \llbracket\KWD{nat} k\rrbracket [j\COLON \TYP{IntegerStatic}\llbracket{}k\rrbracket] \mathrel{\mathtt{:}} \TYP{BinaryEndianWord}\llbracket{}1,\VAR{bigEndianBytes},\VAR{bigEndianBits}\rrbracket}\\
{\tt~~}\EXP{\KWD{where} \{\,k < 2^{b}\,\}}}

Subscripting returns bit \VAR{j} of this binary endian word.
The numbering of the bits is dictated by \VAR{bigEndianBits}.
Indexing is zero-origin; an \TYP{IndexOutOfBounds} is thrown unless \EXP{0\leq{}j<2^b}.
If the subscript is a static expression, then its validity is checked statically,
and no exception will occur at run time.

%%   property FORALL(v) AND[j<-0#2^b] v[j] = (if bigEndianBits then v.bit(2^b-1-j) else v.bit(j) end)
\begin{Fortress}
{\tt~~}\pushtabs\=\+\(  \KWD{property} \forall(v)\; \bigwedge\limits_{j\leftarrow{}0\mathinner{\hbox{\tt\char'43}}2^{b}} v_j = (\KWD{if} \VAR{bigEndianBits} \KWD{then} v.\VAR{bit}(2^{b}-1-j) \KWD{else} v.\VAR{bit}(j) \KWD{end})\)\-\\\poptabs
\end{Fortress}


%%   opr [\nat m\] [r: RangeOfStaticSize[\IndexInt,m\]] :
%%      BinaryEndianLinearEndianSequence[\1,bigEndianBytes,bigEndianBits,m,bigEndianBits\]
%%     throws { IndexOutOfBounds }
%%   opr [\int a,nat m,int c\] [r: StaticRange[\a,m,c\]] :
%%      BinaryEndianLinearEndianSequence[\1,bigEndianBytes,bigEndianBits,m,bigEndianBits\]
%%     where { 0 <= a < 2^b, 0 <= a + m DOT c < 2^b }
\Method{\EXP{\KWD{opr} \llbracket\KWD{nat} m\rrbracket [r\COLON \TYP{RangeOfStaticSize}\llbracket\TYP{IndexInt},m\rrbracket] \mathrel{\mathtt{:}} }\\
{\tt~~~}\EXP{\TYP{BinaryEndianLinearEndianSequence}\llbracket{}1,\VAR{bigEndianBytes},\VAR{bigEndianBits},m,\VAR{bigEndianBits}\rrbracket}\\
{\tt~~}\EXP{\KWD{throws} \{\,\TYP{IndexOutOfBounds}\,\}}}
\Method*{\EXP{\KWD{opr} \llbracket\KWD{int} a,\KWD{nat} m,\KWD{int} c\rrbracket [r\COLON \TYP{StaticRange}\llbracket{}a,m,c\rrbracket] \mathrel{\mathtt{:}} }\\
{\tt~~~}\EXP{\TYP{BinaryEndianLinearEndianSequence}\llbracket{}1,\VAR{bigEndianBytes},\VAR{bigEndianBits},m,\VAR{bigEndianBits}\rrbracket}\\
{\tt~~}\EXP{\KWD{where} \{\,0 \leq a < 2^{b}, 0 \leq a + m \cdot c < 2^{b}\,\}}}

Subscripting with a range of static size \VAR{m} returns the indicated subsequence of bits
of this binary endian word.
The numbering of the bits is dictated by \VAR{bigEndianBits}.
The result is a binary endian linear endian sequence of bits whose sequence endianness
is the same as the bit endianness of this binary endian word.
Indexing is zero-origin;
an \TYP{IndexOutOfBounds} is thrown unless \EXP{r \subseteq 0\mathinner{\hbox{\tt\char'43}}2^b}.
If the subscript is a static range, then its validity is checked statically,
and no exception will occur at run time.
Element \VAR{k} of the result sequence is the same as
the bit that would be selected from this binary endian word by subscripting it with
\EXP{r.\VAR{lowerBound} + k \times r.\VAR{stride}}, for all \EXP{0\leq{}k<m}.


%%   opr [j: IndexInt] := (v: Bit):
%%      BinaryEndianWord[\b,bigEndianBytes,bigEndianBits\]
%%     throws { IndexOutOfBounds }
%%   opr [\nat k\] [j: IntegerStatic[\k\]] := (v: Bit):
%%      BinaryEndianWord[\b,bigEndianBytes,bigEndianBits\]
%%     where { k < 2^b }
\Method{\EXP{\KWD{opr} [j\COLON \TYP{IndexInt}] \ASSIGN (v\COLON \TYP{Bit})\COLON }\\
{\tt~~~}\EXP{\TYP{BinaryEndianWord}\llbracket{}b,\VAR{bigEndianBytes},\VAR{bigEndianBits}\rrbracket}\\
{\tt~~}\EXP{\KWD{throws} \{\,\TYP{IndexOutOfBounds}\,\}}}
\Method*{\EXP{\KWD{opr} \llbracket\KWD{nat} k\rrbracket [j\COLON \TYP{IntegerStatic}\llbracket{}k\rrbracket] \ASSIGN (v\COLON \TYP{Bit})\COLON }\\
{\tt~~~}\EXP{\TYP{BinaryEndianWord}\llbracket{}b,\VAR{bigEndianBytes},\VAR{bigEndianBits}\rrbracket}\\
{\tt~~}\EXP{\KWD{where} \{\,k < 2^{b}\,\}}}

After subscripted value object assignment,
the bit that would be selected from this binary endian word by subscripting it with
\VAR{j} is the same as the given bit \VAR{v},
and all other bits are the same as before.
Indexing is zero-origin; an \TYP{IndexOutOfBounds} is thrown unless \EXP{0\leq{}j<2^b}.
If the subscript is a static expression, then its validity is checked statically,
and no exception will occur at run time.


%%   opr [\nat m\] [r: RangeOfStaticSize[\IndexInt,m\]] := (v: BinaryLinearSequence[\1,m\]):
%%      BinaryEndianWord[\b,bigEndianBytes,bigEndianBits\]
%%     throws { IndexOutOfBounds }
%%   opr [\int a,nat m,int c\] [r: StaticRange[\a,m,c\]] := (v: BinaryLinearSequence[\1,m\]):
%%      BinaryEndianWord[\b,bigEndianBytes,bigEndianBits\]
%%     where { 0 <= a < 2^b, 0 <= a + m DOT c < 2^b }
\Method{\EXP{\KWD{opr} \llbracket\KWD{nat} m\rrbracket [r\COLON \TYP{RangeOfStaticSize}\llbracket\TYP{IndexInt},m\rrbracket] \ASSIGN (v\COLON \TYP{BinaryLinearSequence}\llbracket{}1,m\rrbracket)\COLON }\\
{\tt~~~}\EXP{\TYP{BinaryEndianWord}\llbracket{}b,\VAR{bigEndianBytes},\VAR{bigEndianBits}\rrbracket}\\
{\tt~~}\EXP{\KWD{throws} \{\,\TYP{IndexOutOfBounds}\,\}}}
\Method*{\EXP{\KWD{opr} \llbracket\KWD{int} a,\KWD{nat} m,\KWD{int} c\rrbracket [r\COLON \TYP{StaticRange}\llbracket{}a,m,c\rrbracket] \ASSIGN (v\COLON \TYP{BinaryLinearSequence}\llbracket{}1,m\rrbracket)\COLON }\\
{\tt~~~}\EXP{\TYP{BinaryEndianWord}\llbracket{}b,\VAR{bigEndianBytes},\VAR{bigEndianBits}\rrbracket}\\
{\tt~~}\EXP{\KWD{where} \{\,0 \leq a < 2^{b}, 0 \leq a + m \cdot c < 2^{b}\,\}}}

After subscripted value object assignment,
bits that would be selected from this binary endian word by subscripting it with \VAR{r}
are the same as corresponding elements of \VAR{v}, and all other bits are the same as before;
specifically, the bit that would be selected from this binary endian word by subscripting it with
\EXP{r.\VAR{lowerBound} + k \times r.\VAR{stride}}
is the same as element \VAR{k} of \VAR{v}, for all \EXP{0\leq{}k<m}.
Indexing is zero-origin; an \TYP{IndexOutOfBounds} is thrown unless \EXP{r \subseteq 0\mathinner{\hbox{\tt\char'43}}2^b}.
If the subscript is a static range, then its validity is checked statically,
and no exception will occur at run time.


%%   update(j: IndexInt, v: Bit):
%%      BinaryEndianWord[\b,bigEndianBytes,bigEndianBits\]
%%     throws { IndexOutOfBounds }
%%   update[\nat k\](j: IntegerStatic[\k\], v: Bit):
%%      BinaryEndianWord[\b,bigEndianBytes,bigEndianBits\]
%%     where { k < 2^b }
\Method{\EXP{\VAR{update}(j\COLON \TYP{IndexInt}, v\COLON \TYP{Bit})\COLON }\\
{\tt~~~}\EXP{\TYP{BinaryEndianWord}\llbracket{}b,\VAR{bigEndianBytes},\VAR{bigEndianBits}\rrbracket}\\
{\tt~~}\EXP{\KWD{throws} \{\,\TYP{IndexOutOfBounds}\,\}}}
\Method*{\EXP{\VAR{update}\llbracket\KWD{nat} k\rrbracket(j\COLON \TYP{IntegerStatic}\llbracket{}k\rrbracket, v\COLON \TYP{Bit})\COLON }\\
{\tt~~~}\EXP{\TYP{BinaryEndianWord}\llbracket{}b,\VAR{bigEndianBytes},\VAR{bigEndianBits}\rrbracket}\\
{\tt~~}\EXP{\KWD{where} \{\,k < 2^{b}\,\}}}

This is a functional version of subscripted value object assignment:
the bit that would be selected from the result by subscripting it with
\VAR{j} is the same as the given bit \VAR{v},
and all other bits are the same as before.
Indexing is zero-origin; an \TYP{IndexOutOfBounds} is thrown unless \EXP{0\leq{}j<2^b}.
If the subscript is a static expression, then its validity is checked statically,
and no exception will occur at run time.


%%   update[\nat m\](r: RangeOfStaticSize[\IndexInt,m\], v: BinaryLinearSequence[\1,m\]):
%%      BinaryEndianWord[\b,bigEndianBytes,bigEndianBits\]
%%     throws { IndexOutOfBounds }
%%   update[\int a,nat m,int c\](r: StaticRange[\a,m,c\], v: BinaryLinearSequence[\1,m\]):
%%      BinaryEndianWord[\b,bigEndianBytes,bigEndianBits\]
%%     where { 0 <= a < 2^b, 0 <= a + m DOT c < 2^b }
\Method{\EXP{\VAR{update}\llbracket\KWD{nat} m\rrbracket(r\COLON \TYP{RangeOfStaticSize}\llbracket\TYP{IndexInt},m\rrbracket, v\COLON \TYP{BinaryLinearSequence}\llbracket{}1,m\rrbracket)\COLON }\\
{\tt~~~}\EXP{\TYP{BinaryEndianWord}\llbracket{}b,\VAR{bigEndianBytes},\VAR{bigEndianBits}\rrbracket}\\
{\tt~~}\EXP{\KWD{throws} \{\,\TYP{IndexOutOfBounds}\,\}}}
\Method*{\EXP{\VAR{update}\llbracket\KWD{int} a,\KWD{nat} m,\KWD{int} c\rrbracket(r\COLON \TYP{StaticRange}\llbracket{}a,m,c\rrbracket, v\COLON \TYP{BinaryLinearSequence}\llbracket{}1,m\rrbracket)\COLON }\\
{\tt~~~}\EXP{\TYP{BinaryEndianWord}\llbracket{}b,\VAR{bigEndianBytes},\VAR{bigEndianBits}\rrbracket}\\
{\tt~~}\EXP{\KWD{where} \{\,0 \leq a < 2^{b}, 0 \leq a + m \cdot c < 2^{b}\,\}}}

This is a functional version of subscripted value object assignment:
bits that would be selected from the result by subscripting it with \VAR{r}
are the same as corresponding elements of \VAR{v}, and all other bits are the same as before;
specifically, the bit that would be selected from the result by subscripting it with
\EXP{r.\VAR{lowerBound} + k \times r.\VAR{stride}}
is the same as element \VAR{k} of \VAR{v}, for all \EXP{0\leq{}k<m}.
Indexing is zero-origin; an \TYP{IndexOutOfBounds} is thrown unless \EXP{r \subseteq 0\mathinner{\hbox{\tt\char'43}}2^b}.
If the subscript is a static range, then its validity is checked statically,
and no exception will occur at run time.


%%   lowHalf(): BinaryEndianWord[\b-1,bigEndianBytes,bigEndianBits\] where { b > 0 }
%%   highHalf(): BinaryEndianWord[\b-1,bigEndianBytes,bigEndianBits\] where { b > 0 }
\Method{\EXP{\VAR{lowHalf}()\COLON \TYP{BinaryEndianWord}\llbracket{}b-1,\VAR{bigEndianBytes},\VAR{bigEndianBits}\rrbracket \KWD{where} \{\,b > 0\,\}}}
\Method*{\EXP{\VAR{highHalf}()\COLON \TYP{BinaryEndianWord}\llbracket{}b-1,\VAR{bigEndianBytes},\VAR{bigEndianBits}\rrbracket \KWD{where} \{\,b > 0\,\}}}

The getters \VAR{lowHalf} and \VAR{highHalf} each return a binary endian word of half the size (in bits)
of this binary endian word, and with the same endian characteristics;
\VAR{lowHalf} returns the less significant bits, and \VAR{highHalf} returns
the more significant bits.

%%   property FORALL(v) AND[m<-0#2^(b-1)] v.lowHalf.bit(m) = v.bit(m)
%%   property FORALL(v) AND[m<-0#2^(b-1)] v.highHalf.bit(m) = v.bit(m+2^(b-1))
%%   property FORALL(v) AND[m<-0#2^(b-1)] v.lowHalf[m] = v[if bigEndianBits then m+2^(b-1) else m end]
%%   property FORALL(v) AND[m<-0#2^(b-1)] v.highHalf[m] = v[if bigEndianBits then m else m+2^(b-1) end]
\begin{Fortress}
{\tt~~}\pushtabs\=\+\(  \KWD{property} \forall(v)\; \bigwedge\limits_{m\leftarrow{}0\mathinner{\hbox{\tt\char'43}}2^{b-1}} v.\VAR{lowHalf}.\VAR{bit}(m) = v.\VAR{bit}(m)\)\\
\(  \KWD{property} \forall(v)\; \bigwedge\limits_{m\leftarrow{}0\mathinner{\hbox{\tt\char'43}}2^{b-1}} v.\VAR{highHalf}.\VAR{bit}(m) = v.\VAR{bit}(m+2^{b-1})\)\\
\(  \KWD{property} \forall(v)\; \bigwedge\limits_{m\leftarrow{}0\mathinner{\hbox{\tt\char'43}}2^{b-1}} v.\VAR{lowHalf}_m = v[\KWD{if} \VAR{bigEndianBits} \KWD{then} m+2^{b-1} \KWD{else} m \KWD{end}]\)\\
\(  \KWD{property} \forall(v)\; \bigwedge\limits_{m\leftarrow{}0\mathinner{\hbox{\tt\char'43}}2^{b-1}} v.\VAR{highHalf}_m = v[\KWD{if} \VAR{bigEndianBits} \KWD{then} m \KWD{else} m+2^{b-1} \KWD{end}]\)\-\\\poptabs
\end{Fortress}


%%   opr || [\nat m,bool bigEndianSequence\]
%%      (self, other: BinaryEndianWord[\b,bigEndianBytes,bigEndianBits\]):
%%      BinaryEndianLinearEndianSequence[\b+1,bigEndianBytes,bigEndianBits,
%%                                        2,bigEndianSequence\]
%%     where { bigEndianSequence = bigEndianBytes }
\Method{\EXP{\KWD{opr}\,\|\,\llbracket\KWD{nat} m,\KWD{bool} \VAR{bigEndianSequence}\rrbracket}\\
{\tt~~~}\EXP{(\KWD{self}, \VAR{other}\COLON \TYP{BinaryEndianWord}\llbracket{}b,\VAR{bigEndianBytes},\VAR{bigEndianBits}\rrbracket)\COLON }\\
{\tt~~~}\EXP{\TYP{BinaryEndianLinearEndianSequence}\llbracket{}b+1,\VAR{bigEndianBytes},\VAR{bigEndianBits},}\\
{\tt~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~}\EXP{2,\VAR{bigEndianSequence}\rrbracket}\\
{\tt~~}\EXP{\KWD{where} \{\,\VAR{bigEndianSequence} = \VAR{bigEndianBytes}\,\}}}

[Description to be supplied.]


%%   opr || [\nat m,bool bigEndianSequence,nat radix,nat q,nat k,nat v\]
%%      (self, other: NaturalNumeral[\m,radix,v\]):
%%      BinaryEndianLinearEndianSequence[\b,bigEndianBytes,bigEndianBits,
%%                                        k+1,bigEndianSequence\]
%%     where { bigEndianSequence = bigEndianBytes, radix = 2^q, q DOT m = k DOT 2^b }
\Method{\EXP{\KWD{opr}\,\|\,\llbracket\KWD{nat} m,\KWD{bool} \VAR{bigEndianSequence},\KWD{nat} \VAR{radix},\KWD{nat} q,\KWD{nat} k,\KWD{nat} v\rrbracket}\\
{\tt~~~}\EXP{(\KWD{self}, \VAR{other}\COLON \TYP{NaturalNumeral}\llbracket{}m,\VAR{radix},v\rrbracket)\COLON }\\
{\tt~~~}\EXP{\TYP{BinaryEndianLinearEndianSequence}\llbracket{}b,\VAR{bigEndianBytes},\VAR{bigEndianBits},}\\
{\tt~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~}\EXP{k+1,\VAR{bigEndianSequence}\rrbracket}\\
{\tt~~}\EXP{\KWD{where} \{\,\VAR{bigEndianSequence} = \VAR{bigEndianBytes}, \VAR{radix} = 2^{q}, q \cdot m = k \cdot 2^{b}\,\}}}

[Description to be supplied.]


%%   opr || [\nat m,bool bigEndianSequence,nat radix,nat q,nat k,nat v\]
%%      (other: NaturalNumeral[\m,radix,v\], self):
%%      BinaryEndianLinearEndianSequence[\b,bigEndianBytes,bigEndianBits,
%%                                        k+1,bigEndianSequence\]
%%     where { bigEndianSequence = bigEndianBytes, radix = 2^q, q DOT m = k DOT 2^b }
\Method{\EXP{\KWD{opr}\,\|\,\llbracket\KWD{nat} m,\KWD{bool} \VAR{bigEndianSequence},\KWD{nat} \VAR{radix},\KWD{nat} q,\KWD{nat} k,\KWD{nat} v\rrbracket}\\
{\tt~~~}\EXP{(\VAR{other}\COLON \TYP{NaturalNumeral}\llbracket{}m,\VAR{radix},v\rrbracket, \KWD{self})\COLON }\\
{\tt~~~}\EXP{\TYP{BinaryEndianLinearEndianSequence}\llbracket{}b,\VAR{bigEndianBytes},\VAR{bigEndianBits},}\\
{\tt~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~}\EXP{k+1,\VAR{bigEndianSequence}\rrbracket}\\
{\tt~~}\EXP{\KWD{where} \{\,\VAR{bigEndianSequence} = \VAR{bigEndianBytes}, \VAR{radix} = 2^{q}, q \cdot m = k \cdot 2^{b}\,\}}}

[Description to be supplied.]


%%   bitShuffle(other: BinaryEndianWord[\b,bigEndianBytes,bigEndianBits\]):
%%     BinaryEndianWord[\b+1,bigEndianBytes,bigEndianBits\]
%%     where { b < maxBinaryWordBitLog }
\Method{\EXP{\VAR{bitShuffle}(\VAR{other}\COLON \TYP{BinaryEndianWord}\llbracket{}b,\VAR{bigEndianBytes},\VAR{bigEndianBits}\rrbracket)\COLON }\\
{\tt~~}\EXP{\TYP{BinaryEndianWord}\llbracket{}b+1,\VAR{bigEndianBytes},\VAR{bigEndianBits}\rrbracket}\\
{\tt~~}\EXP{\KWD{where} \{\,b < \VAR{maxBinaryWordBitLog}\,\}}}

[Description to be supplied.]


%%   bitUnshuffle(): (BinaryEndianWord[\b-1,bigEndianBytes,bigEndianBits\],
%%                    BinaryEndianWord[\b-1,bigEndianBytes,bigEndianBits\])
%%     where { b > 0 }
\Method{\EXP{\VAR{bitUnshuffle}()\COLON (\TYP{BinaryEndianWord}\llbracket{}b-1,\VAR{bigEndianBytes},\VAR{bigEndianBits}\rrbracket,}\\
{\tt~~~~~~~~~~~~~~~~~}\EXP{\TYP{BinaryEndianWord}\llbracket{}b-1,\VAR{bigEndianBytes},\VAR{bigEndianBits}\rrbracket)}\\
{\tt~~}\EXP{\KWD{where} \{\,b > 0\,\}}}

[Description to be supplied.]



%%   littleEndian(): BinaryEndianWord[\b,false,false\]
%%   bigEndian(): BinaryEndianWord[\b,true,true\]
\Method{\EXP{\VAR{littleEndian}()\COLON \TYP{BinaryEndianWord}\llbracket{}b,\VAR{false},\VAR{false}\rrbracket}}
\Method*{\EXP{\VAR{bigEndian}()\COLON \TYP{BinaryEndianWord}\llbracket{}b,\VAR{true},\VAR{true}\rrbracket}}

[Description to be supplied.]






\Trait{Fortress.Core.BasicBinaryOperations}
\seclabel{lib:BasicBinaryOperations}

%% trait BasicBinaryOperations[\T extends BasicBinaryOperations[\T\]\]
%%   wrappingAdd(other: T): T
%%   add(other: T, carryIn: Bit=0): (T,Bit)
%%   signedAdd(other: T, overflowAction: ()->T): T
%%   unsignedAdd(other: T, overflowAction: ()->T): T
%%   saturatingSignedAdd(other: T): T
%%   saturatingUnsignedAdd(other: T): T
%%   wrappingSubtract(other: T): T
%%   subtract(other: T, carryIn: Bit=1): (T,Bit)
%%   signedSubtract(other: T, overflowAction: ()->T): T
%%   unsignedSubtract(other: T, overflowAction: ()->T): T
%%   saturatingSignedSubtract(other: T): T
%%   saturatingUnsignedSubtract(other: T): T
%%   wrappingNegate(): T
%%   negate(carryIn: Bit=1): (T,Bit)
%%   signedNegate(overflowAction: ()->T): T
%%   unsignedNegate(overflowAction: ()->T): T
%%   saturatingSignedNegate(): T
%%   bitNot(): T
%%   bitAnd(other: T): T
%%   bitOr(other: T): T
%%   bitXor(other: T): T
%%   bitXorNot(other: T): T
%%   bitNand(other: T): T
%%   bitNor(other: T): T
%%   bitAndNot(other: T): T
%%   bitOrNot(other: T): T
%%   signedMax(other: T): T
%%   signedMin(other: T): T
%%   unsignedMax(other: T): T
%%   unsignedMin(other: T): T
%%   opr =(self,other: T): Boolean
%%   opr =/=(self,other: T): Boolean
%%   signedLT(other: T): Boolean
%%   signedLE(other: T): Boolean
%%   signedGE(other: T): Boolean
%%   signedGT(other: T): Boolean
%%   unsignedLT(other: T): Boolean
%%   unsignedLE(other: T): Boolean
%%   unsignedGE(other: T): Boolean
%%   unsignedGT(other: T): Boolean
%%   signedShift(j: IndexInt): T
%%   signedShift(j: IndexInt, overflowAction: ()->T): T
%%   saturatingSignedShift(j: IndexInt): T
%%   unsignedShift(j: IndexInt): T
%%   unsignedShift(j: IndexInt, overflowAction: ()->T): T
%%   saturatingUnsignedShift(j: IndexInt): T
%%   bitRotate(j: IndexInt): T
%%   countOneBits(): IndexInt
%%   countLeadingZeroBits(): IndexInt
%%   countTrailingZeroBits(): IndexInt
%%   leftmostOneBit(): T
%%   rightmostOneBit(): T
%%   bitReverse(): T
%%   signedIndex(): IndexInt throws { IntegerOverflow }
%%   unsignedIndex(): IndexInt throws { IntegerOverflow }
%%   gatherBits(mask: T): T
%%   spreadBits(mask: T): T
%%   disentangleBits(mask: T): T
%%   intersperseBits(mask: T): T
%% end
\begin{Fortress}
\(\KWD{trait} \TYP{BasicBinaryOperations}\llbracket{}T \KWD{extends} \TYP{BasicBinaryOperations}\llbracket{}T\rrbracket\rrbracket\)\\
{\tt~~}\pushtabs\=\+\(  \VAR{wrappingAdd}(\VAR{other}\COLON T)\COLON T\)\\
\(  \VAR{add}(\VAR{other}\COLON T, \VAR{carryIn}\COLON \TYP{Bit}=0)\COLON (T,\TYP{Bit})\)\\
\(  \VAR{signedAdd}(\VAR{other}\COLON T, \VAR{overflowAction}\COLON ()\rightarrow{}T)\COLON T\)\\
\(  \VAR{unsignedAdd}(\VAR{other}\COLON T, \VAR{overflowAction}\COLON ()\rightarrow{}T)\COLON T\)\\
\(  \VAR{saturatingSignedAdd}(\VAR{other}\COLON T)\COLON T\)\\
\(  \VAR{saturatingUnsignedAdd}(\VAR{other}\COLON T)\COLON T\)\\
\(  \VAR{wrappingSubtract}(\VAR{other}\COLON T)\COLON T\)\\
\(  \VAR{subtract}(\VAR{other}\COLON T, \VAR{carryIn}\COLON \TYP{Bit}=1)\COLON (T,\TYP{Bit})\)\\
\(  \VAR{signedSubtract}(\VAR{other}\COLON T, \VAR{overflowAction}\COLON ()\rightarrow{}T)\COLON T\)\\
\(  \VAR{unsignedSubtract}(\VAR{other}\COLON T, \VAR{overflowAction}\COLON ()\rightarrow{}T)\COLON T\)\\
\(  \VAR{saturatingSignedSubtract}(\VAR{other}\COLON T)\COLON T\)\\
\(  \VAR{saturatingUnsignedSubtract}(\VAR{other}\COLON T)\COLON T\)\\
\(  \VAR{wrappingNegate}()\COLON T\)\\
\(  \VAR{negate}(\VAR{carryIn}\COLON \TYP{Bit}=1)\COLON (T,\TYP{Bit})\)\\
\(  \VAR{signedNegate}(\VAR{overflowAction}\COLON ()\rightarrow{}T)\COLON T\)\\
\(  \VAR{unsignedNegate}(\VAR{overflowAction}\COLON ()\rightarrow{}T)\COLON T\)\\
\(  \VAR{saturatingSignedNegate}()\COLON T\)\\
\(  \VAR{bitNot}()\COLON T\)\\
\(  \VAR{bitAnd}(\VAR{other}\COLON T)\COLON T\)\\
\(  \VAR{bitOr}(\VAR{other}\COLON T)\COLON T\)\\
\(  \VAR{bitXor}(\VAR{other}\COLON T)\COLON T\)\\
\(  \VAR{bitXorNot}(\VAR{other}\COLON T)\COLON T\)\\
\(  \VAR{bitNand}(\VAR{other}\COLON T)\COLON T\)\\
\(  \VAR{bitNor}(\VAR{other}\COLON T)\COLON T\)\\
\(  \VAR{bitAndNot}(\VAR{other}\COLON T)\COLON T\)\\
\(  \VAR{bitOrNot}(\VAR{other}\COLON T)\COLON T\)\\
\(  \VAR{signedMax}(\VAR{other}\COLON T)\COLON T\)\\
\(  \VAR{signedMin}(\VAR{other}\COLON T)\COLON T\)\\
\(  \VAR{unsignedMax}(\VAR{other}\COLON T)\COLON T\)\\
\(  \VAR{unsignedMin}(\VAR{other}\COLON T)\COLON T\)\\
\(  \KWD{opr} \mathord{=}(\KWD{self},\VAR{other}\COLON T)\COLON \TYP{Boolean}\)\\
\(  \KWD{opr} \mathord{\neq}(\KWD{self},\VAR{other}\COLON T)\COLON \TYP{Boolean}\)\\
\(  \VAR{signedLT}(\VAR{other}\COLON T)\COLON \TYP{Boolean}\)\\
\(  \VAR{signedLE}(\VAR{other}\COLON T)\COLON \TYP{Boolean}\)\\
\(  \VAR{signedGE}(\VAR{other}\COLON T)\COLON \TYP{Boolean}\)\\
\(  \VAR{signedGT}(\VAR{other}\COLON T)\COLON \TYP{Boolean}\)\\
\(  \VAR{unsignedLT}(\VAR{other}\COLON T)\COLON \TYP{Boolean}\)\\
\(  \VAR{unsignedLE}(\VAR{other}\COLON T)\COLON \TYP{Boolean}\)\\
\(  \VAR{unsignedGE}(\VAR{other}\COLON T)\COLON \TYP{Boolean}\)\\
\(  \VAR{unsignedGT}(\VAR{other}\COLON T)\COLON \TYP{Boolean}\)\\
\(  \VAR{signedShift}(j\COLON \TYP{IndexInt})\COLON T\)\\
\(  \VAR{signedShift}(j\COLON \TYP{IndexInt}, \VAR{overflowAction}\COLON ()\rightarrow{}T)\COLON T\)\\
\(  \VAR{saturatingSignedShift}(j\COLON \TYP{IndexInt})\COLON T\)\\
\(  \VAR{unsignedShift}(j\COLON \TYP{IndexInt})\COLON T\)\\
\(  \VAR{unsignedShift}(j\COLON \TYP{IndexInt}, \VAR{overflowAction}\COLON ()\rightarrow{}T)\COLON T\)\\
\(  \VAR{saturatingUnsignedShift}(j\COLON \TYP{IndexInt})\COLON T\)\\
\(  \VAR{bitRotate}(j\COLON \TYP{IndexInt})\COLON T\)\\
\(  \VAR{countOneBits}()\COLON \TYP{IndexInt}\)\\
\(  \VAR{countLeadingZeroBits}()\COLON \TYP{IndexInt}\)\\
\(  \VAR{countTrailingZeroBits}()\COLON \TYP{IndexInt}\)\\
\(  \VAR{leftmostOneBit}()\COLON T\)\\
\(  \VAR{rightmostOneBit}()\COLON T\)\\
\(  \VAR{bitReverse}()\COLON T\)\\
\(  \VAR{signedIndex}()\COLON \TYP{IndexInt} \KWD{throws} \{\,\TYP{IntegerOverflow}\,\}\)\\
\(  \VAR{unsignedIndex}()\COLON \TYP{IndexInt} \KWD{throws} \{\,\TYP{IntegerOverflow}\,\}\)\\
\(  \VAR{gatherBits}(\VAR{mask}\COLON T)\COLON T\)\\
\(  \VAR{spreadBits}(\VAR{mask}\COLON T)\COLON T\)\\
\(  \VAR{disentangleBits}(\VAR{mask}\COLON T)\COLON T\)\\
\(  \VAR{intersperseBits}(\VAR{mask}\COLON T)\COLON T\)\-\\\poptabs
\(\KWD{end}\)
\end{Fortress}


%%   wrappingAdd(other: T): T
%%   add(other: T, carryIn: Bit=0): (T,Bit)
%%   signedAdd(other: T, overflowAction: ()->T): T
%%   unsignedAdd(other: T, overflowAction: ()->T): T
%%   saturatingSignedAdd(other: T): T
%%   saturatingUnsignedAdd(other: T): T
\Method{\EXP{\VAR{wrappingAdd}(\VAR{other}\COLON T)\COLON T}}
\Method*{\EXP{\VAR{add}(\VAR{other}\COLON T, \VAR{carryIn}\COLON \TYP{Bit}=0)\COLON (T,\TYP{Bit})}}
\Method*{\EXP{\VAR{signedAdd}(\VAR{other}\COLON T, \VAR{overflowAction}\COLON ()\rightarrow{}T)\COLON T}}
\Method*{\EXP{\VAR{unsignedAdd}(\VAR{other}\COLON T, \VAR{overflowAction}\COLON ()\rightarrow{}T)\COLON T}}
\Method*{\EXP{\VAR{saturatingSignedAdd}(\VAR{other}\COLON T)\COLON T}}
\Method*{\EXP{\VAR{saturatingUnsignedAdd}(\VAR{other}\COLON T)\COLON T}}

[Description to be supplied.]


%%   wrappingSubtract(other: T): T
%%   subtract(other: T, carryIn: Bit=1): (T,Bit)
%%   signedSubtract(other: T, overflowAction: ()->T): T
%%   unsignedSubtract(other: T, overflowAction: ()->T): T
%%   saturatingSignedSubtract(other: T): T
%%   saturatingUnsignedSubtract(other: T): T
\Method{\EXP{\VAR{wrappingSubtract}(\VAR{other}\COLON T)\COLON T}}
\Method*{\EXP{\VAR{subtract}(\VAR{other}\COLON T, \VAR{carryIn}\COLON \TYP{Bit}=1)\COLON (T,\TYP{Bit})}}
\Method*{\EXP{\VAR{signedSubtract}(\VAR{other}\COLON T, \VAR{overflowAction}\COLON ()\rightarrow{}T)\COLON T}}
\Method*{\EXP{\VAR{unsignedSubtract}(\VAR{other}\COLON T, \VAR{overflowAction}\COLON ()\rightarrow{}T)\COLON T}}
\Method*{\EXP{\VAR{saturatingSignedSubtract}(\VAR{other}\COLON T)\COLON T}}
\Method*{\EXP{\VAR{saturatingUnsignedSubtract}(\VAR{other}\COLON T)\COLON T}}

[Description to be supplied.]


%%   wrappingNegate(): T
%%   negate(carryIn: Bit=1): (T,Bit)
%%   signedNegate(overflowAction: ()->T): T
%%   unsignedNegate(overflowAction: ()->T): T
%%   saturatingSignedNegate(): T
\Method{\EXP{\VAR{wrappingNegate}()\COLON T}}
\Method*{\EXP{\VAR{negate}(\VAR{carryIn}\COLON \TYP{Bit}=1)\COLON (T,\TYP{Bit})}}
\Method*{\EXP{\VAR{signedNegate}(\VAR{overflowAction}\COLON ()\rightarrow{}T)\COLON T}}
\Method*{\EXP{\VAR{unsignedNegate}(\VAR{overflowAction}\COLON ()\rightarrow{}T)\COLON T}}
\Method*{\EXP{\VAR{saturatingSignedNegate}()\COLON T}}

[Description to be supplied.]


%%   bitNot(): T
\Method{\EXP{\VAR{bitNot}()\COLON T}}

[Description to be supplied.]


%%   bitAnd(other: T): T
%%   bitOr(other: T): T
%%   bitXor(other: T): T
%%   bitXorNot(other: T): T
%%   bitNand(other: T): T
%%   bitNor(other: T): T
%%   bitAndNot(other: T): T
%%   bitOrNot(other: T): T
\Method{\EXP{\VAR{bitAnd}(\VAR{other}\COLON T)\COLON T}}
\Method*{\EXP{\VAR{bitOr}(\VAR{other}\COLON T)\COLON T}}
\Method*{\EXP{\VAR{bitXor}(\VAR{other}\COLON T)\COLON T}}
\Method*{\EXP{\VAR{bitXorNot}(\VAR{other}\COLON T)\COLON T}}
\Method*{\EXP{\VAR{bitNand}(\VAR{other}\COLON T)\COLON T}}
\Method*{\EXP{\VAR{bitNor}(\VAR{other}\COLON T)\COLON T}}
\Method*{\EXP{\VAR{bitAndNot}(\VAR{other}\COLON T)\COLON T}}
\Method*{\EXP{\VAR{bitOrNot}(\VAR{other}\COLON T)\COLON T}}

[Description to be supplied.]


%%   signedMax(other: T): T
%%   signedMin(other: T): T
\Method{\EXP{\VAR{signedMax}(\VAR{other}\COLON T)\COLON T}}
\Method*{\EXP{\VAR{signedMin}(\VAR{other}\COLON T)\COLON T}}

[Description to be supplied.]


%%   unsignedMax(other: T): T
%%   unsignedMin(other: T): T
\Method{\EXP{\VAR{unsignedMax}(\VAR{other}\COLON T)\COLON T}}
\Method*{\EXP{\VAR{unsignedMin}(\VAR{other}\COLON T)\COLON T}}

[Description to be supplied.]


%%   opr =(self,other: T): Boolean
%%   opr =/=(self,other: T): Boolean
\Method{\EXP{\KWD{opr} \mathord{=}(\KWD{self},\VAR{other}\COLON T)\COLON \TYP{Boolean}}}
\Method*{\EXP{\KWD{opr} \mathord{\neq}(\KWD{self},\VAR{other}\COLON T)\COLON \TYP{Boolean}}}

[Description to be supplied.]


%%   signedLT(other: T): Boolean
%%   signedLE(other: T): Boolean
%%   signedGE(other: T): Boolean
%%   signedGT(other: T): Boolean
\Method{\EXP{\VAR{signedLT}(\VAR{other}\COLON T)\COLON \TYP{Boolean}}}
\Method*{\EXP{\VAR{signedLE}(\VAR{other}\COLON T)\COLON \TYP{Boolean}}}
\Method*{\EXP{\VAR{signedGE}(\VAR{other}\COLON T)\COLON \TYP{Boolean}}}
\Method*{\EXP{\VAR{signedGT}(\VAR{other}\COLON T)\COLON \TYP{Boolean}}}

[Description to be supplied.]


%%   unsignedLT(other: T): Boolean
%%   unsignedLE(other: T): Boolean
%%   unsignedGE(other: T): Boolean
%%   unsignedGT(other: T): Boolean
\Method{\EXP{\VAR{unsignedLT}(\VAR{other}\COLON T)\COLON \TYP{Boolean}}}
\Method*{\EXP{\VAR{unsignedLE}(\VAR{other}\COLON T)\COLON \TYP{Boolean}}}
\Method*{\EXP{\VAR{unsignedGE}(\VAR{other}\COLON T)\COLON \TYP{Boolean}}}
\Method*{\EXP{\VAR{unsignedGT}(\VAR{other}\COLON T)\COLON \TYP{Boolean}}}

[Description to be supplied.]


%%   signedShift(j: IndexInt): T
%%   signedShift(j: IndexInt, overflowAction: ()->T): T
%%   saturatingSignedShift(j: IndexInt): T
\Method{\EXP{\VAR{signedShift}(j\COLON \TYP{IndexInt})\COLON T}}
\Method*{\EXP{\VAR{signedShift}(j\COLON \TYP{IndexInt}, \VAR{overflowAction}\COLON ()\rightarrow{}T)\COLON T}}
\Method*{\EXP{\VAR{saturatingSignedShift}(j\COLON \TYP{IndexInt})\COLON T}}

[Description to be supplied.]


%%   unsignedShift(j: IndexInt): T
%%   unsignedShift(j: IndexInt, overflowAction: ()->T): T
%%   saturatingUnsignedShift(j: IndexInt): T
\Method{\EXP{\VAR{unsignedShift}(j\COLON \TYP{IndexInt})\COLON T}}
\Method*{\EXP{\VAR{unsignedShift}(j\COLON \TYP{IndexInt}, \VAR{overflowAction}\COLON ()\rightarrow{}T)\COLON T}}
\Method*{\EXP{\VAR{saturatingUnsignedShift}(j\COLON \TYP{IndexInt})\COLON T}}

[Description to be supplied.]


%%   bitRotate(j: IndexInt): T
\Method{\EXP{\VAR{bitRotate}(j\COLON \TYP{IndexInt})\COLON T}}

[Description to be supplied.]


%%   countOneBits(): IndexInt
\Method{\EXP{\VAR{countOneBits}()\COLON \TYP{IndexInt}}}

[Description to be supplied.]


%%   countLeadingZeroBits(): IndexInt
%%   countTrailingZeroBits(): IndexInt
\Method{\EXP{\VAR{countLeadingZeroBits}()\COLON \TYP{IndexInt}}}
\Method*{\EXP{\VAR{countTrailingZeroBits}()\COLON \TYP{IndexInt}}}

[Description to be supplied.]


%%   leftmostOneBit(): T
%%   rightmostOneBit(): T
\Method{\EXP{\VAR{leftmostOneBit}()\COLON T}}
\Method*{\EXP{\VAR{rightmostOneBit}()\COLON T}}

[Description to be supplied.]


%%   bitReverse(): T
\Method{\EXP{\VAR{bitReverse}()\COLON T}}

[Description to be supplied.]


%%   signedIndex(): IndexInt throws { IntegerOverflow }
%%   unsignedIndex(): IndexInt throws { IntegerOverflow }
\Method{\EXP{\VAR{signedIndex}()\COLON \TYP{IndexInt} \KWD{throws} \{\,\TYP{IntegerOverflow}\,\}}}
\Method*{\EXP{\VAR{unsignedIndex}()\COLON \TYP{IndexInt} \KWD{throws} \{\,\TYP{IntegerOverflow}\,\}}}

[Description to be supplied.]


%%   gatherBits(mask: T): T
%%   spreadBits(mask: T): T
\Method{\EXP{\VAR{gatherBits}(\VAR{mask}\COLON T)\COLON T}}
\Method*{\EXP{\VAR{spreadBits}(\VAR{mask}\COLON T)\COLON T}}

[Description to be supplied.]


%%   disentangleBits(mask: T): T
%%   intersperseBits(mask: T): T
\Method{\EXP{\VAR{disentangleBits}(\VAR{mask}\COLON T)\COLON T}}
\Method*{\EXP{\VAR{intersperseBits}(\VAR{mask}\COLON T)\COLON T}}

[Description to be supplied.]







\Trait{Fortress.Core.BasicBinaryWordOperations}
\seclabel{lib:BasicBinaryWordOperations}

%% trait BasicBinaryWordOperations[\T extends BasicBinaryWordOperations[\T,b\], nat b\]
%%     extends BasicBinaryOperations[\T\] where { b <= maxBinaryWordBitLog }
%%   multiplyLow(other: T): T where { b <= maxMultiplyBitLog }
%%   multiplyLow(other: T, overflowAction: ()->T): T where { b <= maxMultiplyBitLog }
%%   saturatedMultiplyLow(other: T): T where { b <= maxMultiplyBitLog }
%%   multiplyHigh(other: T): T where { b <= maxMultiplyBitLog }
%%   multiplyDouble(other: T): (T,T) where { b <= maxMultiplyBitLog }
%%   signedDivide(other: T, overflowAction: ()->T, zeroDivideAction: ()->T): T
%%     where { b <= maxDivideBitLog }
%%   unsignedDivide(other: T, zeroDivideAction: ()->T): T where { b <= maxDivideBitLog }
%%   signedDivRem(other: T, overflowAction: ()->T, zeroDivideAction: ()->T): (T,T)
%%     where { b <= maxDivideBitLog }
%%   unsignedDivRem(other: T, zeroDivideAction: ()->T): (T,T) where { b <= maxDivideBitLog }
%%   signedRemainder(other: T, zeroDivideAction: ()->T): T where { b <= maxDivideBitLog }
%%   unsignedModulo(other: T, zeroDivideAction: ()->T): T where { b <= maxDivideBitLog }
%%   bitSwap(j: IndexInt): T
%%   getter littleEndian(): BinaryEndianWord[\b,false,false\]
%%   getter bigEndian(): BinaryEndianWord[\b,true,true\]
%% end
\begin{Fortress}
\(\KWD{trait} \TYP{BasicBinaryWordOperations}\llbracket{}T \KWD{extends} \TYP{BasicBinaryWordOperations}\llbracket{}T,b\rrbracket, \KWD{nat} b\rrbracket\)\\
{\tt~~~~}\pushtabs\=\+\(    \KWD{extends} \TYP{BasicBinaryOperations}\llbracket{}T\rrbracket \KWD{where} \{\,b \leq \VAR{maxBinaryWordBitLog}\,\}\)\-\\\poptabs
{\tt~~}\pushtabs\=\+\(  \VAR{multiplyLow}(\VAR{other}\COLON T)\COLON T \KWD{where} \{\,b \leq \VAR{maxMultiplyBitLog}\,\}\)\\
\(  \VAR{multiplyLow}(\VAR{other}\COLON T, \VAR{overflowAction}\COLON ()\rightarrow{}T)\COLON T \KWD{where} \{\,b \leq \VAR{maxMultiplyBitLog}\,\}\)\\
\(  \VAR{saturatedMultiplyLow}(\VAR{other}\COLON T)\COLON T \KWD{where} \{\,b \leq \VAR{maxMultiplyBitLog}\,\}\)\\
\(  \VAR{multiplyHigh}(\VAR{other}\COLON T)\COLON T \KWD{where} \{\,b \leq \VAR{maxMultiplyBitLog}\,\}\)\\
\(  \VAR{multiplyDouble}(\VAR{other}\COLON T)\COLON (T,T) \KWD{where} \{\,b \leq \VAR{maxMultiplyBitLog}\,\}\)\\
\(  \VAR{signedDivide}(\VAR{other}\COLON T, \VAR{overflowAction}\COLON ()\rightarrow{}T, \VAR{zeroDivideAction}\COLON ()\rightarrow{}T)\COLON T\)\\
{\tt~~}\pushtabs\=\+\(    \KWD{where} \{\,b \leq \VAR{maxDivideBitLog}\,\}\)\-\\\poptabs
\(  \VAR{unsignedDivide}(\VAR{other}\COLON T, \VAR{zeroDivideAction}\COLON ()\rightarrow{}T)\COLON T \KWD{where} \{\,b \leq \VAR{maxDivideBitLog}\,\}\)\\
\(  \VAR{signedDivRem}(\VAR{other}\COLON T, \VAR{overflowAction}\COLON ()\rightarrow{}T, \VAR{zeroDivideAction}\COLON ()\rightarrow{}T)\COLON (T,T)\)\\
{\tt~~}\pushtabs\=\+\(    \KWD{where} \{\,b \leq \VAR{maxDivideBitLog}\,\}\)\-\\\poptabs
\(  \VAR{unsignedDivRem}(\VAR{other}\COLON T, \VAR{zeroDivideAction}\COLON ()\rightarrow{}T)\COLON (T,T) \KWD{where} \{\,b \leq \VAR{maxDivideBitLog}\,\}\)\\
\(  \VAR{signedRemainder}(\VAR{other}\COLON T, \VAR{zeroDivideAction}\COLON ()\rightarrow{}T)\COLON T \KWD{where} \{\,b \leq \VAR{maxDivideBitLog}\,\}\)\\
\(  \VAR{unsignedModulo}(\VAR{other}\COLON T, \VAR{zeroDivideAction}\COLON ()\rightarrow{}T)\COLON T \KWD{where} \{\,b \leq \VAR{maxDivideBitLog}\,\}\)\\
\(  \VAR{bitSwap}(j\COLON \TYP{IndexInt})\COLON T\)\\
\(  \KWD{getter} \VAR{littleEndian}()\COLON \TYP{BinaryEndianWord}\llbracket{}b,\VAR{false},\VAR{false}\rrbracket\)\\
\(  \KWD{getter} \VAR{bigEndian}()\COLON \TYP{BinaryEndianWord}\llbracket{}b,\VAR{true},\VAR{true}\rrbracket\)\-\\\poptabs
\(\KWD{end}\)
\end{Fortress}


%%   multiplyLow(other: T): T where { b <= maxMultiplyBitLog }
%%   multiplyLow(other: T, overflowAction: ()->T): T where { b <= maxMultiplyBitLog }
%%   saturatedMultiplyLow(other: T): T where { b <= maxMultiplyBitLog }
%%   multiplyHigh(other: T): T where { b <= maxMultiplyBitLog }
%%   multiplyDouble(other: T): (T,T) where { b <= maxMultiplyBitLog }
\Method{\EXP{\VAR{multiplyLow}(\VAR{other}\COLON T)\COLON T \KWD{where} \{\,b \leq \VAR{maxMultiplyBitLog}\,\}}}
\Method*{\EXP{\VAR{multiplyLow}(\VAR{other}\COLON T, \VAR{overflowAction}\COLON ()\rightarrow{}T)\COLON T \KWD{where} \{\,b \leq \VAR{maxMultiplyBitLog}\,\}}}
\Method*{\EXP{\VAR{saturatedMultiplyLow}(\VAR{other}\COLON T)\COLON T \KWD{where} \{\,b \leq \VAR{maxMultiplyBitLog}\,\}}}
\Method*{\EXP{\VAR{multiplyHigh}(\VAR{other}\COLON T)\COLON T \KWD{where} \{\,b \leq \VAR{maxMultiplyBitLog}\,\}}}
\Method*{\EXP{\VAR{multiplyDouble}(\VAR{other}\COLON T)\COLON (T,T) \KWD{where} \{\,b \leq \VAR{maxMultiplyBitLog}\,\}}}

[Description to be supplied.]


%%   signedDivide(other: T, overflowAction: ()->T, zeroDivideAction: ()->T): T
%%     where { b <= maxDivideBitLog }
%%   unsignedDivide(other: T, zeroDivideAction: ()->T): T where { b <= maxDivideBitLog }
\Method{\EXP{\VAR{signedDivide}(\VAR{other}\COLON T, \VAR{overflowAction}\COLON ()\rightarrow{}T, \VAR{zeroDivideAction}\COLON ()\rightarrow{}T)\COLON T}\\
{\tt~~}\EXP{\KWD{where} \{\,b \leq \VAR{maxDivideBitLog}\,\}}}
\Method*{\EXP{\VAR{unsignedDivide}(\VAR{other}\COLON T, \VAR{zeroDivideAction}\COLON ()\rightarrow{}T)\COLON T \KWD{where} \{\,b \leq \VAR{maxDivideBitLog}\,\}}}

[Description to be supplied.]


%%   signedDivRem(other: T, overflowAction: ()->T, zeroDivideAction: ()->T): (T,T)
%%     where { b <= maxDivideBitLog }
%%   unsignedDivRem(other: T, zeroDivideAction: ()->T): (T,T) where { b <= maxDivideBitLog }
\Method{\EXP{\VAR{signedDivRem}(\VAR{other}\COLON T, \VAR{overflowAction}\COLON ()\rightarrow{}T, \VAR{zeroDivideAction}\COLON ()\rightarrow{}T)\COLON (T,T)}\\
{\tt~~}\EXP{\KWD{where} \{\,b \leq \VAR{maxDivideBitLog}\,\}}}
\Method*{\EXP{\VAR{unsignedDivRem}(\VAR{other}\COLON T, \VAR{zeroDivideAction}\COLON ()\rightarrow{}T)\COLON (T,T) \KWD{where} \{\,b \leq \VAR{maxDivideBitLog}\,\}}}

[Description to be supplied.]


%%   signedRemainder(other: T, zeroDivideAction: ()->T): T where { b <= maxDivideBitLog }
%%   unsignedModulo(other: T, zeroDivideAction: ()->T): T where { b <= maxDivideBitLog }
\Method{\EXP{\VAR{signedRemainder}(\VAR{other}\COLON T, \VAR{zeroDivideAction}\COLON ()\rightarrow{}T)\COLON T \KWD{where} \{\,b \leq \VAR{maxDivideBitLog}\,\}}}
\Method*{\EXP{\VAR{unsignedModulo}(\VAR{other}\COLON T, \VAR{zeroDivideAction}\COLON ()\rightarrow{}T)\COLON T \KWD{where} \{\,b \leq \VAR{maxDivideBitLog}\,\}}}

[Description to be supplied.]


%%   bitSwap(j: IndexInt): T
\Method{\EXP{\VAR{bitSwap}(j\COLON \TYP{IndexInt})\COLON T}}

[Description to be supplied.]


%%   getter littleEndian(): BinaryEndianWord[\b,false,false\]
%%   getter bigEndian(): BinaryEndianWord[\b,true,true\]
\Method{\EXP{\KWD{getter} \VAR{littleEndian}()\COLON \TYP{BinaryEndianWord}\llbracket{}b,\VAR{false},\VAR{false}\rrbracket}}
\Method*{\EXP{\KWD{getter} \VAR{bigEndian}()\COLON \TYP{BinaryEndianWord}\llbracket{}b,\VAR{true},\VAR{true}\rrbracket}}

[Description to be supplied.]







\Trait{Fortress.Core.BinaryLinearEndianSequence}
\seclabel{lib:BinaryLinearEndianSequence}

%% trait BinaryLinearEndianSequence[\nat b, nat n, bool bigEndianSequence\]
%%         extends { BasicBinaryOperations[\BinaryLinearEndianSequence[\b,n,bigEndianSequence\]\] }
%%     where { b <= maxBinaryWordBitLog }
%%   coerce[\nat b',bool bigEndianBytes,bool bigEndianBits\]
%%      (x: BinaryEndianWord[\b',bigEndianBytes,bigEndianBits\])
%%     where { bigEndianBytes = bigEndianSequence, 2^b' = n DOT 2^b }
%%   coerce[\nat m,nat radix,nat q,nat k,nat v\](x: NaturalNumeral[\m,radix,v\])
%%     where { radix = 2^q, q DOT m = n DOT 2^bk }
%%   opr [j: IndexInt] : BinaryWord[\b\]
%%     throws { IndexOutOfBounds }
%%   opr [\nat k\] [j: IntegerStatic[\k\]] : BinaryWord[\b\] where { k < n }
%%   opr [\nat m\] [r: RangeOfStaticSize[\IndexInt,m\]] :
%%      BinaryLinearEndianSequence[\b,m,bigEndianSequence\]
%%     throws { IndexOutOfBounds } where { m <= n }
%%   opr [\int a,nat m,int c\] [r: StaticRange[\a,m,c\]] :
%%      BinaryLinearEndianSequence[\b,m,bigEndianSequence\]
%%     where { 0 <= a < n, 0 <= a + m DOT c < n }
%%   opr [j: IndexInt] := (v: BinaryWord[\b\]):
%%      BinaryLinearEndianSequence[\b,n,bigEndianSequence\]
%%     throws { IndexOutOfBounds }
%%   opr [\nat k\] [j: IntegerStatic[\k\]] := (v: BinaryWord[\b\]):
%%      BinaryLinearEndianSequence[\b,n,bigEndianSequence\] where { k < n }
%%   opr [\nat m\][r: RangeOfStaticSize[\IndexInt,m\]] :=
%%      (v: BinaryLinearEndianSequence[\b,m,bigEndianSequence\]):
%%      BinaryLinearEndianSequence[\b,n,bigEndianSequence\]
%%     throws { IndexOutOfBounds }
%%   opr [\int a,nat m,int c\][r: StaticRange[\a,m,c\]] :=
%%      (v: BinaryLinearEndianSequence[\b,m,bigEndianSequence\]):
%%      BinaryLinearEndianSequence[\b,n,bigEndianSequence\]
%%     where { 0 <= a < n, 0 <= a + m DOT c < n }
%%   update(j: IndexInt, v: BinaryWord[\b\]):
%%      BinaryLinearEndianSequence[\b,n,bigEndianSequence\]
%%     throws { IndexOutOfBounds }
%%   update[\nat k\](j: IntegerStatic[\k\], v: BinaryWord[\b\]):
%%      BinaryLinearEndianSequence[\b,n,bigEndianSequence\] where { k < n }
%%   update[\nat m\](r: RangeOfStaticSize[\IndexInt,m\],
%%                   v: BinaryLinearEndianSequence[\b,m,bigEndianSequence\]):
%%      BinaryLinearEndianSequence[\b,n,bigEndianSequence\]
%%     throws { IndexOutOfBounds }
%%   update[\int a,nat m,int c\](r: StaticRange[\a,m,c\],
%%                               v: BinaryLinearEndianSequence[\b,m,bigEndianSequence\]):
%%      BinaryLinearEndianSequence[\b,n,bigEndianSequence\]
%%     where { 0 <= a < n, 0 <= a + m DOT c < n }
%%   opr || [\nat m\](self, other: BinaryLinearEndianSequence[\b,m,bigEndianSequence\]):
%%      BinaryLinearEndianSequence[\b,n+m,bigEndianSequence\]
%%   opr || [\nat m,nat radix,nat q,nat k,nat v\](self, other: NaturalNumeral[\m,radix,v\]):
%%      LinearSequence[\BinaryWord[\b\],n+k\] where { radix = 2^q, q DOT m = k DOT 2^b }
%%   opr || [\nat m,nat radix,nat q,nat k,nat v\](other: NaturalNumeral[\m,radix,v\], self):
%%      LinearSequence[\BinaryWord[\b\],n+k\] where { radix = 2^q, q DOT m = k DOT 2^b }
%%   littleEndian(): BinaryEndianLinearEndianSequence[\b,false,false,n,bigEndianSequence\]
%%   bigEndian(): BinaryEndianLinearEndianSequence[\b,true,true,n,bigEndianSequence\]
%%   littleEndianBits(): BinaryEndianLinearEndianSequence[\b,bigEndianBytes,false,
%%                                                         n,bigEndianSequence\]
%%   bigEndianBits(): BinaryEndianLinearEndianSequence[\b,bigEndianBytes,true,
%%                                                      n,bigEndianSequence\]
%%   littleEndianSequence(): BinaryLinearEndianSequence[\b,n,false\]
%%   bigEndianSequence(): BinaryLinearEndianSequence[\b,n,true\]
%%   split[\nat b'\](): BinaryLinearEndianSequence[\b',n DOT 2^(b-b'),bigEndianSequence\]
%%     where { b' <= b }
%% end
\begin{Fortress}
\(\KWD{trait} \TYP{BinaryLinearEndianSequence}\llbracket\KWD{nat} b, \KWD{nat} n, \KWD{bool} \VAR{bigEndianSequence}\rrbracket\)\\
{\tt~~~~~~~~}\pushtabs\=\+\(        \KWD{extends} \{\,\TYP{BasicBinaryOperations}\llbracket\TYP{BinaryLinearEndianSequence}\llbracket{}b,n,\VAR{bigEndianSequence}\rrbracket\rrbracket\,\}\)\-\\\poptabs
{\tt~~~~}\pushtabs\=\+\(    \KWD{where} \{\,b \leq \VAR{maxBinaryWordBitLog}\,\}\)\-\\\poptabs
{\tt~~}\pushtabs\=\+\(  \KWD{coerce}\llbracket\KWD{nat} b',\KWD{bool} \VAR{bigEndianBytes},\KWD{bool} \VAR{bigEndianBits}\rrbracket\)\\
{\tt~~~}\pushtabs\=\+\(     (x\COLON \TYP{BinaryEndianWord}\llbracket{}b',\VAR{bigEndianBytes},\VAR{bigEndianBits}\rrbracket)\)\-\\\poptabs
{\tt~~}\pushtabs\=\+\(    \KWD{where} \{\,\VAR{bigEndianBytes} = \VAR{bigEndianSequence}, 2^{b'} = n \cdot 2^{b}\,\}\)\-\\\poptabs
\(  \KWD{coerce}\llbracket\KWD{nat} m,\KWD{nat} \VAR{radix},\KWD{nat} q,\KWD{nat} k,\KWD{nat} v\rrbracket(x\COLON \TYP{NaturalNumeral}\llbracket{}m,\VAR{radix},v\rrbracket)\)\\
{\tt~~}\pushtabs\=\+\(    \KWD{where} \{\,\VAR{radix} = 2^{q}, q \cdot m = n \cdot 2^{\VAR{bk}}\,\}\)\-\\\poptabs
\(  \KWD{opr} [j\COLON \TYP{IndexInt}] \mathrel{\mathtt{:}} \TYP{BinaryWord}\llbracket{}b\rrbracket\)\\
{\tt~~}\pushtabs\=\+\(    \KWD{throws} \{\,\TYP{IndexOutOfBounds}\,\}\)\-\\\poptabs
\(  \KWD{opr} \llbracket\KWD{nat} k\rrbracket [j\COLON \TYP{IntegerStatic}\llbracket{}k\rrbracket] \mathrel{\mathtt{:}} \TYP{BinaryWord}\llbracket{}b\rrbracket \KWD{where} \{\,k < n\,\}\)\\
\(  \KWD{opr} \llbracket\KWD{nat} m\rrbracket [r\COLON \TYP{RangeOfStaticSize}\llbracket\TYP{IndexInt},m\rrbracket] \mathrel{\mathtt{:}} \)\\
{\tt~~~}\pushtabs\=\+\(     \TYP{BinaryLinearEndianSequence}\llbracket{}b,m,\VAR{bigEndianSequence}\rrbracket\)\-\\\poptabs
{\tt~~}\pushtabs\=\+\(    \KWD{throws} \{\,\TYP{IndexOutOfBounds}\,\} \KWD{where} \{\,m \leq n\,\}\)\-\\\poptabs
\(  \KWD{opr} \llbracket\KWD{int} a,\KWD{nat} m,\KWD{int} c\rrbracket [r\COLON \TYP{StaticRange}\llbracket{}a,m,c\rrbracket] \mathrel{\mathtt{:}} \)\\
{\tt~~~}\pushtabs\=\+\(     \TYP{BinaryLinearEndianSequence}\llbracket{}b,m,\VAR{bigEndianSequence}\rrbracket\)\-\\\poptabs
{\tt~~}\pushtabs\=\+\(    \KWD{where} \{\,0 \leq a < n, 0 \leq a + m \cdot c < n\,\}\)\-\\\poptabs
\(  \KWD{opr} [j\COLON \TYP{IndexInt}] \ASSIGN (v\COLON \TYP{BinaryWord}\llbracket{}b\rrbracket)\COLON \)\\
{\tt~~~}\pushtabs\=\+\(     \TYP{BinaryLinearEndianSequence}\llbracket{}b,n,\VAR{bigEndianSequence}\rrbracket\)\-\\\poptabs
{\tt~~}\pushtabs\=\+\(    \KWD{throws} \{\,\TYP{IndexOutOfBounds}\,\}\)\-\\\poptabs
\(  \KWD{opr} \llbracket\KWD{nat} k\rrbracket [j\COLON \TYP{IntegerStatic}\llbracket{}k\rrbracket] \ASSIGN (v\COLON \TYP{BinaryWord}\llbracket{}b\rrbracket)\COLON \)\\
{\tt~~~}\pushtabs\=\+\(     \TYP{BinaryLinearEndianSequence}\llbracket{}b,n,\VAR{bigEndianSequence}\rrbracket \KWD{where} \{\,k < n\,\}\)\-\\\poptabs
\(  \KWD{opr} \llbracket\KWD{nat} m\rrbracket[r\COLON \TYP{RangeOfStaticSize}\llbracket\TYP{IndexInt},m\rrbracket] \ASSIGN\)\\
{\tt~~~}\pushtabs\=\+\(     (v\COLON \TYP{BinaryLinearEndianSequence}\llbracket{}b,m,\VAR{bigEndianSequence}\rrbracket)\COLON \)\\
\(     \TYP{BinaryLinearEndianSequence}\llbracket{}b,n,\VAR{bigEndianSequence}\rrbracket\)\-\\\poptabs
{\tt~~}\pushtabs\=\+\(    \KWD{throws} \{\,\TYP{IndexOutOfBounds}\,\}\)\-\\\poptabs
\(  \KWD{opr} \llbracket\KWD{int} a,\KWD{nat} m,\KWD{int} c\rrbracket[r\COLON \TYP{StaticRange}\llbracket{}a,m,c\rrbracket] \ASSIGN\)\\
{\tt~~~}\pushtabs\=\+\(     (v\COLON \TYP{BinaryLinearEndianSequence}\llbracket{}b,m,\VAR{bigEndianSequence}\rrbracket)\COLON \)\\
\(     \TYP{BinaryLinearEndianSequence}\llbracket{}b,n,\VAR{bigEndianSequence}\rrbracket\)\-\\\poptabs
{\tt~~}\pushtabs\=\+\(    \KWD{where} \{\,0 \leq a < n, 0 \leq a + m \cdot c < n\,\}\)\-\\\poptabs
\(  \VAR{update}(j\COLON \TYP{IndexInt}, v\COLON \TYP{BinaryWord}\llbracket{}b\rrbracket)\COLON \)\\
{\tt~~~}\pushtabs\=\+\(     \TYP{BinaryLinearEndianSequence}\llbracket{}b,n,\VAR{bigEndianSequence}\rrbracket\)\-\\\poptabs
{\tt~~}\pushtabs\=\+\(    \KWD{throws} \{\,\TYP{IndexOutOfBounds}\,\}\)\-\\\poptabs
\(  \VAR{update}\llbracket\KWD{nat} k\rrbracket(j\COLON \TYP{IntegerStatic}\llbracket{}k\rrbracket, v\COLON \TYP{BinaryWord}\llbracket{}b\rrbracket)\COLON \)\\
{\tt~~~}\pushtabs\=\+\(     \TYP{BinaryLinearEndianSequence}\llbracket{}b,n,\VAR{bigEndianSequence}\rrbracket \KWD{where} \{\,k < n\,\}\)\-\\\poptabs
\(  \VAR{update}\llbracket\KWD{nat} m\rrbracket(\null\)\pushtabs\=\+\(r\COLON \TYP{RangeOfStaticSize}\llbracket\TYP{IndexInt},m\rrbracket,\)\\
\(                  v\COLON \TYP{BinaryLinearEndianSequence}\llbracket{}b,m,\VAR{bigEndianSequence}\rrbracket)\COLON \)\-\\\poptabs
{\tt~~~}\pushtabs\=\+\(     \TYP{BinaryLinearEndianSequence}\llbracket{}b,n,\VAR{bigEndianSequence}\rrbracket\)\-\\\poptabs
{\tt~~}\pushtabs\=\+\(    \KWD{throws} \{\,\TYP{IndexOutOfBounds}\,\}\)\-\\\poptabs
\(  \VAR{update}\llbracket\KWD{int} a,\KWD{nat} m,\KWD{int} c\rrbracket(\null\)\pushtabs\=\+\(r\COLON \TYP{StaticRange}\llbracket{}a,m,c\rrbracket,\)\\
\(                              v\COLON \TYP{BinaryLinearEndianSequence}\llbracket{}b,m,\VAR{bigEndianSequence}\rrbracket)\COLON \)\-\\\poptabs
{\tt~~~}\pushtabs\=\+\(     \TYP{BinaryLinearEndianSequence}\llbracket{}b,n,\VAR{bigEndianSequence}\rrbracket\)\-\\\poptabs
{\tt~~}\pushtabs\=\+\(    \KWD{where} \{\,0 \leq a < n, 0 \leq a + m \cdot c < n\,\}\)\-\\\poptabs
\(  \KWD{opr}\,\|\,\llbracket\KWD{nat} m\rrbracket(\KWD{self}, \VAR{other}\COLON \TYP{BinaryLinearEndianSequence}\llbracket{}b,m,\VAR{bigEndianSequence}\rrbracket)\COLON \)\\
{\tt~~~}\pushtabs\=\+\(     \TYP{BinaryLinearEndianSequence}\llbracket{}b,n+m,\VAR{bigEndianSequence}\rrbracket\)\-\\\poptabs
\(  \KWD{opr}\,\|\,\llbracket\KWD{nat} m,\KWD{nat} \VAR{radix},\KWD{nat} q,\KWD{nat} k,\KWD{nat} v\rrbracket(\KWD{self}, \VAR{other}\COLON \TYP{NaturalNumeral}\llbracket{}m,\VAR{radix},v\rrbracket)\COLON \)\\
{\tt~~~}\pushtabs\=\+\(     \TYP{LinearSequence}\llbracket{}\TYP{BinaryWord}\llbracket{}b\rrbracket,n+k\rrbracket \KWD{where} \{\,\VAR{radix} = 2^{q}, q \cdot m = k \cdot 2^{b}\,\}\)\-\\\poptabs
\(  \KWD{opr}\,\|\,\llbracket\KWD{nat} m,\KWD{nat} \VAR{radix},\KWD{nat} q,\KWD{nat} k,\KWD{nat} v\rrbracket(\VAR{other}\COLON \TYP{NaturalNumeral}\llbracket{}m,\VAR{radix},v\rrbracket, \KWD{self})\COLON \)\\
{\tt~~~}\pushtabs\=\+\(     \TYP{LinearSequence}\llbracket{}\TYP{BinaryWord}\llbracket{}b\rrbracket,n+k\rrbracket \KWD{where} \{\,\VAR{radix} = 2^{q}, q \cdot m = k \cdot 2^{b}\,\}\)\-\\\poptabs
\(  \VAR{littleEndian}()\COLON \TYP{BinaryEndianLinearEndianSequence}\llbracket{}b,\VAR{false},\VAR{false},n,\VAR{bigEndianSequence}\rrbracket\)\\
\(  \VAR{bigEndian}()\COLON \TYP{BinaryEndianLinearEndianSequence}\llbracket{}b,\VAR{true},\VAR{true},n,\VAR{bigEndianSequence}\rrbracket\)\\
\(  \VAR{littleEndianBits}()\COLON \TYP{BinaryEndianLinearEndianSequence}\llbracket\null\)\pushtabs\=\+\(b,\VAR{bigEndianBytes},\VAR{false},\)\\
\(                                                        n,\VAR{bigEndianSequence}\rrbracket\)\-\\\poptabs
\(  \VAR{bigEndianBits}()\COLON \TYP{BinaryEndianLinearEndianSequence}\llbracket\null\)\pushtabs\=\+\(b,\VAR{bigEndianBytes},\VAR{true},\)\\
\(                                                     n,\VAR{bigEndianSequence}\rrbracket\)\-\\\poptabs
\(  \VAR{littleEndianSequence}()\COLON \TYP{BinaryLinearEndianSequence}\llbracket{}b,n,\VAR{false}\rrbracket\)\\
\(  \VAR{bigEndianSequence}()\COLON \TYP{BinaryLinearEndianSequence}\llbracket{}b,n,\VAR{true}\rrbracket\)\\
\(  \VAR{split}\llbracket\KWD{nat} b'\rrbracket()\COLON \TYP{BinaryLinearEndianSequence}\llbracket{}b',n \cdot 2^{b-b'},\VAR{bigEndianSequence}\rrbracket\)\\
{\tt~~}\pushtabs\=\+\(    \KWD{where} \{\,b' \leq b\,\}\)\-\-\\\poptabs\poptabs
\(\KWD{end}\)
\end{Fortress}


%%   coerce[\nat b',bool bigEndianBytes,bool bigEndianBits\]
%%      (x: BinaryEndianWord[\b',bigEndianBytes,bigEndianBits\])
%%     where { bigEndianBytes = bigEndianSequence, 2^b' = n DOT 2^b }
\Method{\EXP{\KWD{coerce}\llbracket\KWD{nat} b',\KWD{bool} \VAR{bigEndianBytes},\KWD{bool} \VAR{bigEndianBits}\rrbracket}\\
{\tt~~~}\EXP{(x\COLON \TYP{BinaryEndianWord}\llbracket{}b',\VAR{bigEndianBytes},\VAR{bigEndianBits}\rrbracket)}\\
{\tt~~}\EXP{\KWD{where} \{\,\VAR{bigEndianBytes} = \VAR{bigEndianSequence}, 2^{b'} = n \cdot 2^{b}\,\}}}

[Description to be supplied.]


%%   coerce[\nat m,nat radix,nat q,nat k,nat v\](x: NaturalNumeral[\m,radix,v\])
%%     where { radix = 2^q, q DOT m = n DOT 2^bk }
\Method{\EXP{\KWD{coerce}\llbracket\KWD{nat} m,\KWD{nat} \VAR{radix},\KWD{nat} q,\KWD{nat} k,\KWD{nat} v\rrbracket(x\COLON \TYP{NaturalNumeral}\llbracket{}m,\VAR{radix},v\rrbracket)}\\
{\tt~~}\EXP{\KWD{where} \{\,\VAR{radix} = 2^{q}, q \cdot m = n \cdot 2^{\VAR{bk}}\,\}}}

[Description to be supplied.]


%%   opr [j: IndexInt] : BinaryWord[\b\]
%%     throws { IndexOutOfBounds }
%%   opr [\nat k\] [j: IntegerStatic[\k\]] : BinaryWord[\b\] where { k < n }
\Method{\EXP{\KWD{opr} [j\COLON \TYP{IndexInt}] \mathrel{\mathtt{:}} \TYP{BinaryWord}\llbracket{}b\rrbracket}\\
{\tt~~}\EXP{\KWD{throws} \{\,\TYP{IndexOutOfBounds}\,\}}}
\Method*{\EXP{\KWD{opr} \llbracket\KWD{nat} k\rrbracket [j\COLON \TYP{IntegerStatic}\llbracket{}k\rrbracket] \mathrel{\mathtt{:}} \TYP{BinaryWord}\llbracket{}b\rrbracket \KWD{where} \{\,k < n\,\}}}

[Description to be supplied.]


%%   opr [\nat m\] [r: RangeOfStaticSize[\IndexInt,m\]] :
%%      BinaryLinearEndianSequence[\b,m,bigEndianSequence\]
%%     throws { IndexOutOfBounds } where { m <= n }
%%   opr [\int a,nat m,int c\] [r: StaticRange[\a,m,c\]] :
%%      BinaryLinearEndianSequence[\b,m,bigEndianSequence\]
%%     where { 0 <= a < n, 0 <= a + m DOT c < n }
\Method{\EXP{\KWD{opr} \llbracket\KWD{nat} m\rrbracket [r\COLON \TYP{RangeOfStaticSize}\llbracket\TYP{IndexInt},m\rrbracket] \mathrel{\mathtt{:}} }\\
{\tt~~~}\EXP{\TYP{BinaryLinearEndianSequence}\llbracket{}b,m,\VAR{bigEndianSequence}\rrbracket}\\
{\tt~~}\EXP{\KWD{throws} \{\,\TYP{IndexOutOfBounds}\,\} \KWD{where} \{\,m \leq n\,\}}}
\Method*{\EXP{\KWD{opr} \llbracket\KWD{int} a,\KWD{nat} m,\KWD{int} c\rrbracket [r\COLON \TYP{StaticRange}\llbracket{}a,m,c\rrbracket] \mathrel{\mathtt{:}} }\\
{\tt~~~}\EXP{\TYP{BinaryLinearEndianSequence}\llbracket{}b,m,\VAR{bigEndianSequence}\rrbracket}\\
{\tt~~}\EXP{\KWD{where} \{\,0 \leq a < n, 0 \leq a + m \cdot c < n\,\}}}

[Description to be supplied.]


%%   opr [j: IndexInt] := (v: BinaryWord[\b\]):
%%      BinaryLinearEndianSequence[\b,n,bigEndianSequence\]
%%     throws { IndexOutOfBounds }
%%   opr [\nat k\] [j: IntegerStatic[\k\]] := (v: BinaryWord[\b\]):
%%      BinaryLinearEndianSequence[\b,n,bigEndianSequence\] where { k < n }
\Method{\EXP{\KWD{opr} [j\COLON \TYP{IndexInt}] \ASSIGN (v\COLON \TYP{BinaryWord}\llbracket{}b\rrbracket)\COLON }\\
{\tt~~~}\EXP{\TYP{BinaryLinearEndianSequence}\llbracket{}b,n,\VAR{bigEndianSequence}\rrbracket}\\
{\tt~~}\EXP{\KWD{throws} \{\,\TYP{IndexOutOfBounds}\,\}}}
\Method*{\EXP{\KWD{opr} \llbracket\KWD{nat} k\rrbracket [j\COLON \TYP{IntegerStatic}\llbracket{}k\rrbracket] \ASSIGN (v\COLON \TYP{BinaryWord}\llbracket{}b\rrbracket)\COLON }\\
{\tt~~~}\EXP{\TYP{BinaryLinearEndianSequence}\llbracket{}b,n,\VAR{bigEndianSequence}\rrbracket \KWD{where} \{\,k < n\,\}}}

[Description to be supplied.]


%%   opr [\nat m\][r: RangeOfStaticSize[\IndexInt,m\]] :=
%%      (v: BinaryLinearEndianSequence[\b,m,bigEndianSequence\]):
%%      BinaryLinearEndianSequence[\b,n,bigEndianSequence\]
%%     throws { IndexOutOfBounds }
%%   opr [\int a,nat m,int c\][r: StaticRange[\a,m,c\]] :=
%%      (v: BinaryLinearEndianSequence[\b,m,bigEndianSequence\]):
%%      BinaryLinearEndianSequence[\b,n,bigEndianSequence\]
%%     where { 0 <= a < n, 0 <= a + m DOT c < n }
\Method{\EXP{\KWD{opr} \llbracket\KWD{nat} m\rrbracket[r\COLON \TYP{RangeOfStaticSize}\llbracket\TYP{IndexInt},m\rrbracket] \ASSIGN}\\
{\tt~~~}\EXP{(v\COLON \TYP{BinaryLinearEndianSequence}\llbracket{}b,m,\VAR{bigEndianSequence}\rrbracket)\COLON }\\
{\tt~~~}\EXP{\TYP{BinaryLinearEndianSequence}\llbracket{}b,n,\VAR{bigEndianSequence}\rrbracket}\\
{\tt~~}\EXP{\KWD{throws} \{\,\TYP{IndexOutOfBounds}\,\}}}
\Method*{\EXP{\KWD{opr} \llbracket\KWD{int} a,\KWD{nat} m,\KWD{int} c\rrbracket[r\COLON \TYP{StaticRange}\llbracket{}a,m,c\rrbracket] \ASSIGN}\\
{\tt~~~}\EXP{(v\COLON \TYP{BinaryLinearEndianSequence}\llbracket{}b,m,\VAR{bigEndianSequence}\rrbracket)\COLON }\\
{\tt~~~}\EXP{\TYP{BinaryLinearEndianSequence}\llbracket{}b,n,\VAR{bigEndianSequence}\rrbracket}\\
{\tt~~}\EXP{\KWD{where} \{\,0 \leq a < n, 0 \leq a + m \cdot c < n\,\}}}

[Description to be supplied.]


%%   update(j: IndexInt, v: BinaryWord[\b\]):
%%      BinaryLinearEndianSequence[\b,n,bigEndianSequence\]
%%     throws { IndexOutOfBounds }
%%   update[\nat k\](j: IntegerStatic[\k\], v: BinaryWord[\b\]):
%%      BinaryLinearEndianSequence[\b,n,bigEndianSequence\] where { k < n }
\Method{\EXP{\VAR{update}(j\COLON \TYP{IndexInt}, v\COLON \TYP{BinaryWord}\llbracket{}b\rrbracket)\COLON }\\
{\tt~~~}\EXP{\TYP{BinaryLinearEndianSequence}\llbracket{}b,n,\VAR{bigEndianSequence}\rrbracket}\\
{\tt~~}\EXP{\KWD{throws} \{\,\TYP{IndexOutOfBounds}\,\}}}
\Method*{\EXP{\VAR{update}\llbracket\KWD{nat} k\rrbracket(j\COLON \TYP{IntegerStatic}\llbracket{}k\rrbracket, v\COLON \TYP{BinaryWord}\llbracket{}b\rrbracket)\COLON }\\
{\tt~~~}\EXP{\TYP{BinaryLinearEndianSequence}\llbracket{}b,n,\VAR{bigEndianSequence}\rrbracket \KWD{where} \{\,k < n\,\}}}

[Description to be supplied.]


%%   update[\nat m\](r: RangeOfStaticSize[\IndexInt,m\],
%%                   v: BinaryLinearEndianSequence[\b,m,bigEndianSequence\]):
%%      BinaryLinearEndianSequence[\b,n,bigEndianSequence\]
%%     throws { IndexOutOfBounds }
%%   update[\int a,nat m,int c\](r: StaticRange[\a,m,c\],
%%                               v: BinaryLinearEndianSequence[\b,m,bigEndianSequence\]):
%%      BinaryLinearEndianSequence[\b,n,bigEndianSequence\]
%%     where { 0 <= a < n, 0 <= a + m DOT c < n }
\Method{\EXP{\VAR{update}\llbracket\KWD{nat} m\rrbracket(r\COLON \TYP{RangeOfStaticSize}\llbracket\TYP{IndexInt},m\rrbracket,}\\
{\tt~~~~~~~~~~~~~~~~}\EXP{v\COLON \TYP{BinaryLinearEndianSequence}\llbracket{}b,m,\VAR{bigEndianSequence}\rrbracket)\COLON }\\
{\tt~~~}\EXP{\TYP{BinaryLinearEndianSequence}\llbracket{}b,n,\VAR{bigEndianSequence}\rrbracket}\\
{\tt~~}\EXP{\KWD{throws} \{\,\TYP{IndexOutOfBounds}\,\}}}
\Method*{\EXP{\VAR{update}\llbracket\KWD{int} a,\KWD{nat} m,\KWD{int} c\rrbracket(r\COLON \TYP{StaticRange}\llbracket{}a,m,c\rrbracket,}\\
{\tt~~~~~~~~~~~~~~~~~~~~~~~~~~~~}\EXP{v\COLON \TYP{BinaryLinearEndianSequence}\llbracket{}b,m,\VAR{bigEndianSequence}\rrbracket)\COLON }\\
{\tt~~~}\EXP{\TYP{BinaryLinearEndianSequence}\llbracket{}b,n,\VAR{bigEndianSequence}\rrbracket}\\
{\tt~~}\EXP{\KWD{where} \{\,0 \leq a < n, 0 \leq a + m \cdot c < n\,\}}}

[Description to be supplied.]


%%   opr || [\nat m\](self, other: BinaryLinearEndianSequence[\b,m,bigEndianSequence\]):
%%      BinaryLinearEndianSequence[\b,n+m,bigEndianSequence\]
\Method{\EXP{\KWD{opr}\,\|\,\llbracket\KWD{nat} m\rrbracket(\KWD{self}, \VAR{other}\COLON \TYP{BinaryLinearEndianSequence}\llbracket{}b,m,\VAR{bigEndianSequence}\rrbracket)\COLON }\\
{\tt~~~}\EXP{\TYP{BinaryLinearEndianSequence}\llbracket{}b,n+m,\VAR{bigEndianSequence}\rrbracket}}

[Description to be supplied.]


%%   opr || [\nat m,nat radix,nat q,nat k,nat v\](self, other: NaturalNumeral[\m,radix,v\]):
%%      LinearSequence[\T,n+k\] where { radix = 2^q, q DOT m = k DOT 2^b }
\Method{\EXP{\KWD{opr}\,\|\,\llbracket\KWD{nat} m,\KWD{nat} \VAR{radix},\KWD{nat} q,\KWD{nat} k,\KWD{nat} v\rrbracket(\KWD{self}, \VAR{other}\COLON \TYP{NaturalNumeral}\llbracket{}m,\VAR{radix},v\rrbracket)\COLON }\\
{\tt~~~}\EXP{\TYP{LinearSequence}\llbracket{}T,n+k\rrbracket \KWD{where} \{\,\VAR{radix} = 2^{q}, q \cdot m = k \cdot 2^{b}\,\}}}

[Description to be supplied.]


%%   opr || [\nat m,nat radix,nat q,nat k,nat v\](other: NaturalNumeral[\m,radix,v\], self):
%%      LinearSequence[\T,n+k\] where { radix = 2^q, q DOT m = k DOT 2^b }
\Method{\EXP{\KWD{opr}\,\|\,\llbracket\KWD{nat} m,\KWD{nat} \VAR{radix},\KWD{nat} q,\KWD{nat} k,\KWD{nat} v\rrbracket(\VAR{other}\COLON \TYP{NaturalNumeral}\llbracket{}m,\VAR{radix},v\rrbracket, \KWD{self})\COLON }\\
{\tt~~~}\EXP{\TYP{LinearSequence}\llbracket{}T,n+k\rrbracket \KWD{where} \{\,\VAR{radix} = 2^{q}, q \cdot m = k \cdot 2^{b}\,\}}}

[Description to be supplied.]


%%   littleEndian(): BinaryEndianLinearEndianSequence[\b,false,false,n,bigEndianSequence\]
%%   bigEndian(): BinaryEndianLinearEndianSequence[\b,true,true,n,bigEndianSequence\]
\Method{\EXP{\VAR{littleEndian}()\COLON \TYP{BinaryEndianLinearEndianSequence}\llbracket{}b,\VAR{false},\VAR{false},n,\VAR{bigEndianSequence}\rrbracket}}
\Method*{\EXP{\VAR{bigEndian}()\COLON \TYP{BinaryEndianLinearEndianSequence}\llbracket{}b,\VAR{true},\VAR{true},n,\VAR{bigEndianSequence}\rrbracket}}

[Description to be supplied.]


%%   littleEndianBits(): BinaryEndianLinearEndianSequence[\b,bigEndianBytes,false,
%%                                                         n,bigEndianSequence\]
%%   bigEndianBits(): BinaryEndianLinearEndianSequence[\b,bigEndianBytes,true,
%%                                                      n,bigEndianSequence\]
\Method{\EXP{\VAR{littleEndianBits}()\COLON \TYP{BinaryEndianLinearEndianSequence}\llbracket{}b,\VAR{bigEndianBytes},\VAR{false},}\\
{\tt~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~}\EXP{n,\VAR{bigEndianSequence}\rrbracket}}
\Method*{\EXP{\VAR{bigEndianBits}()\COLON \TYP{BinaryEndianLinearEndianSequence}\llbracket{}b,\VAR{bigEndianBytes},\VAR{true},}\\
{\tt~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~}\EXP{n,\VAR{bigEndianSequence}\rrbracket}}

[Description to be supplied.]


%%   littleEndianSequence(): BinaryLinearEndianSequence[\b,n,false\]
%%   bigEndianSequence(): BinaryLinearEndianSequence[\b,n,true\]
\Method{\EXP{\VAR{littleEndianSequence}()\COLON \TYP{BinaryLinearEndianSequence}\llbracket{}b,n,\VAR{false}\rrbracket}}
\Method*{\EXP{\VAR{bigEndianSequence}()\COLON \TYP{BinaryLinearEndianSequence}\llbracket{}b,n,\VAR{true}\rrbracket}}

[Description to be supplied.]


%%   split[\nat b'\](): BinaryLinearEndianSequence[\b',n DOT 2^(b-b'),bigEndianSequence\]
%%     where { b' <= b }
\Method{\EXP{\VAR{split}\llbracket\KWD{nat} b'\rrbracket()\COLON \TYP{BinaryLinearEndianSequence}\llbracket{}b',n \cdot 2^{b-b'},\VAR{bigEndianSequence}\rrbracket}\\
{\tt~~}\EXP{\KWD{where} \{\,b' \leq b\,\}}}

[Description to be supplied.]



\Trait{Fortress.Core.BinaryEndianLinearEndianSequence}
\seclabel{lib:BinaryEndianLinearEndianSequence}

%% trait BinaryEndianLinearEndianSequence[\nat b, bool bigEndianBytes, bool bigEndianBits,
%%                                         nat n, bool bigEndianSequence\]
%%     extends { BasicBinaryOperations[\
%%                 BinaryEndianLinearEndianSequence[\b,bigEndianBytes,bigEndianBits,
%%                                                   n,bigEndianSequence\]\] }
%%     where { b <= maxBinaryWordBitLog }
%%   coerce[\nat b',bool bigEndianBytes,bool bigEndianBits\]
%%      (x: BinaryEndianWord[\b',bigEndianBytes,bigEndianBits\])
%%     where { bigEndianBytes = bigEndianSequence, 2^b' = n DOT 2^b }
%%   coerce[\nat m,nat radix,nat q,nat k,nat v\](x: NaturalNumeral[\m,radix,v\])
%%     where { radix = 2^q, q DOT m = n DOT 2^bk }
%%   opr [j: IndexInt] : BinaryEndianWord[\b, bigEndianBytes, bigEndianBits\]
%%     throws { IndexOutOfBounds }
%%   opr [\nat k\] [j: IntegerStatic[\k\]] : BinaryWord[\b, bigEndianBytes, bigEndianBits\]
%%     where { k < n }
%%   opr [\nat m\] [r: RangeOfStaticSize[\IndexInt,m\]] :
%%      BinaryEndianLinearEndianSequence[\b,bigEndianBytes,bigEndianBits,
%%                                        m,bigEndianSequence\]
%%     throws { IndexOutOfBounds } where { m <= n }
%%   opr [\int a,nat m,int c\] [r: StaticRange[\a,m,c\]] :
%%      BinaryEndianLinearEndianSequence[\b,bigEndianBytes,bigEndianBits,
%%                                        m,bigEndianSequence\]
%%     where { 0 <= a < n, 0 <= a + m DOT c < n }
%%   opr [j: IndexInt] := (v: BinaryEndianWord[\b, bigEndianBytes, bigEndianBits\]):
%%      BinaryEndianLinearEndianSequence[\b,bigEndianBytes,bigEndianBits,
%%                                        n,bigEndianSequence\]
%%     throws { IndexOutOfBounds }
%%   opr [\nat k\] [j: IntegerStatic[\k\]] :=
%%      (v: BinaryEndianWord[\b, bigEndianBytes, bigEndianBits\]):
%%      BinaryEndianLinearEndianSequence[\b,bigEndianBytes,bigEndianBits,
%%                                        n,bigEndianSequence\]
%%     where { k < n }
%%   opr [\nat m\][r: RangeOfStaticSize[\IndexInt,m\]] :=
%%      (v: BinaryEndianLinearEndianSequence[\b,bigEndianBytes,bigEndianBits,
%%                                            m,bigEndianSequence\]):
%%      BinaryEndianLinearEndianSequence[\b,bigEndianBytes,bigEndianBits,
%%                                        n,bigEndianSequence\]
%%     throws { IndexOutOfBounds }
%%   opr [\int a,nat m,int c\][r: StaticRange[\a,m,c\]] :=
%%      (v: BinaryEndianLinearEndianSequence[\b,bigEndianBytes,bigEndianBits,
%%                                            k,bigEndianSequence\]):
%%      BinaryEndianLinearEndianSequence[\b,bigEndianBytes,bigEndianBits,
%%                                        n,bigEndianSequence\]
%%     where { 0 <= a < n, 0 <= a + m DOT c < n }
%%   update(j: IndexInt, v: BinaryEndianWord[\b, bigEndianBytes, bigEndianBits\]):
%%      BinaryEndianLinearEndianSequence[\b,bigEndianBytes,bigEndianBits,
%%                                        n,bigEndianSequence\]
%%     throws { IndexOutOfBounds }
%%   update[\nat k\](j: IntegerStatic[\k\],
%%                   v: BinaryEndianWord[\b, bigEndianBytes, bigEndianBits\]):
%%      BinaryEndianLinearEndianSequence[\b,bigEndianBytes,bigEndianBits,
%%                                        n,bigEndianSequence\]
%%     where { k < n }
%%   update[\nat m\](r: RangeOfStaticSize[\IndexInt,m\],
%%                   v: BinaryEndianLinearEndianSequence[\b,bigEndianBytes,bigEndianBits,
%%                                                        m,bigEndianSequence\]):
%%      BinaryEndianLinearEndianSequence[\b,bigEndianBytes,bigEndianBits,
%%                                        n,bigEndianSequence\]
%%     throws { IndexOutOfBounds }
%%   update[\int a,nat m,int c\]
%%      (r: StaticRange[\a,m,c\],
%%       v: BinaryEndianLinearEndianSequence[\b,bigEndianBytes,bigEndianBits,
%%                                            m,bigEndianSequence\]):
%%      BinaryEndianLinearEndianSequence[\b,bigEndianBytes,bigEndianBits,
%%                                        n,bigEndianSequence\]
%%     where { 0 <= a < n, 0 <= a + m DOT c < n }
%%   opr || [\nat m\](self, other: BinaryEndianLinearEndianSequence[\
%%                                   b,bigEndianBytes,bigEndianBits,
%%                                   m,bigEndianSequence\]):
%%      BinaryEndianLinearEndianSequence[\b,bigEndianBytes,bigEndianBits,
%%                                        n+m,bigEndianSequence\]
%%   opr || [\nat m,nat radix,nat q,nat k,nat v\](self, other: NaturalNumeral[\m,radix,v\]):
%%      LinearSequence[\T,n+k\]
%%     where { radix = 2^q, q DOT m = k DOT 2^b }
%%   opr || [\nat m,nat radix,nat q,nat k,nat v\](other: NaturalNumeral[\m,radix,v\], self):
%%      LinearSequence[\T,n+k\]
%%     where { radix = 2^q, q DOT m = k DOT 2^b }
%%   littleEndian(): BinaryEndianLinearEndianSequence[\b,false,false,n,bigEndianSequence\]
%%   bigEndian(): BinaryEndianLinearEndianSequence[\b,true,true,n,bigEndianSequence\]
%%   littleEndianBits(): BinaryEndianLinearEndianSequence[\b,bigEndianBytes,false,
%%                                                         n,bigEndianSequence\]
%%   bigEndianBits(): BinaryEndianLinearEndianSequence[\b,bigEndianBytes,true,
%%                                                      n,bigEndianSequence\]
%%   littleEndianSequence(): BinaryEndianLinearEndianSequence[\b,bigEndianBytes,bigEndianBits,
%%                                                             n,false\]
%%   bigEndianSequence(): BinaryEndianLinearEndianSequence[\b,bigEndianBytes,bigEndianBits,
%%                                                          n,true\]
%%   split[\nat b'\]():
%%       BinaryEndianLinearEndianSequence[\b',bigEndianBytes,bigEndianBits,
%%                                         n DOT 2^(b-b'),bigEndianSequence\]
%%     where { b' <= b }
%% end
\begin{Fortress}
\(\KWD{trait} \TYP{BinaryEndianLinearEndianSequence}\llbracket\null\)\pushtabs\=\+\(\KWD{nat} b, \KWD{bool} \VAR{bigEndianBytes}, \KWD{bool} \VAR{bigEndianBits},\)\\
\(                                        \KWD{nat} n, \KWD{bool} \VAR{bigEndianSequence}\rrbracket\)\-\\\poptabs
{\tt~~~~}\pushtabs\=\+\(    \KWD{extends} \{\,\TYP{BasicBinaryOperations}\llbracket\)\\
{\tt~~~~~~~~~~~~}\pushtabs\=\+\(                \TYP{BinaryEndianLinearEndianSequence}\llbracket\null\)\pushtabs\=\+\(b,\VAR{bigEndianBytes},\VAR{bigEndianBits},\)\\
\(                                                  n,\VAR{bigEndianSequence}\rrbracket\rrbracket\,\}\)\-\-\\\poptabs\poptabs
\(    \KWD{where} \{\,b \leq \VAR{maxBinaryWordBitLog}\,\}\)\-\\\poptabs
{\tt~~}\pushtabs\=\+\(  \KWD{coerce}\llbracket\KWD{nat} b',\KWD{bool} \VAR{bigEndianBytes},\KWD{bool} \VAR{bigEndianBits}\rrbracket\)\\
{\tt~~~}\pushtabs\=\+\(     (x\COLON \TYP{BinaryEndianWord}\llbracket{}b',\VAR{bigEndianBytes},\VAR{bigEndianBits}\rrbracket)\)\-\\\poptabs
{\tt~~}\pushtabs\=\+\(    \KWD{where} \{\,\VAR{bigEndianBytes} = \VAR{bigEndianSequence}, 2^{b'} = n \cdot 2^{b}\,\}\)\-\\\poptabs
\(  \KWD{coerce}\llbracket\KWD{nat} m,\KWD{nat} \VAR{radix},\KWD{nat} q,\KWD{nat} k,\KWD{nat} v\rrbracket(x\COLON \TYP{NaturalNumeral}\llbracket{}m,\VAR{radix},v\rrbracket)\)\\
{\tt~~}\pushtabs\=\+\(    \KWD{where} \{\,\VAR{radix} = 2^{q}, q \cdot m = n \cdot 2^{\VAR{bk}}\,\}\)\-\\\poptabs
\(  \KWD{opr} [j\COLON \TYP{IndexInt}] \mathrel{\mathtt{:}} \TYP{BinaryEndianWord}\llbracket{}b, \VAR{bigEndianBytes}, \VAR{bigEndianBits}\rrbracket\)\\
{\tt~~}\pushtabs\=\+\(    \KWD{throws} \{\,\TYP{IndexOutOfBounds}\,\}\)\-\\\poptabs
\(  \KWD{opr} \llbracket\KWD{nat} k\rrbracket [j\COLON \TYP{IntegerStatic}\llbracket{}k\rrbracket] \mathrel{\mathtt{:}} \TYP{BinaryWord}\llbracket{}b, \VAR{bigEndianBytes}, \VAR{bigEndianBits}\rrbracket\)\\
{\tt~~}\pushtabs\=\+\(    \KWD{where} \{\,k < n\,\}\)\-\\\poptabs
\(  \KWD{opr} \llbracket\KWD{nat} m\rrbracket [r\COLON \TYP{RangeOfStaticSize}\llbracket\TYP{IndexInt},m\rrbracket] \mathrel{\mathtt{:}} \)\\
{\tt~~~}\pushtabs\=\+\(     \TYP{BinaryEndianLinearEndianSequence}\llbracket\null\)\pushtabs\=\+\(b,\VAR{bigEndianBytes},\VAR{bigEndianBits},\)\\
\(                                       m,\VAR{bigEndianSequence}\rrbracket\)\-\-\\\poptabs\poptabs
{\tt~~}\pushtabs\=\+\(    \KWD{throws} \{\,\TYP{IndexOutOfBounds}\,\} \KWD{where} \{\,m \leq n\,\}\)\-\\\poptabs
\(  \KWD{opr} \llbracket\KWD{int} a,\KWD{nat} m,\KWD{int} c\rrbracket [r\COLON \TYP{StaticRange}\llbracket{}a,m,c\rrbracket] \mathrel{\mathtt{:}} \)\\
{\tt~~~}\pushtabs\=\+\(     \TYP{BinaryEndianLinearEndianSequence}\llbracket\null\)\pushtabs\=\+\(b,\VAR{bigEndianBytes},\VAR{bigEndianBits},\)\\
\(                                       m,\VAR{bigEndianSequence}\rrbracket\)\-\-\\\poptabs\poptabs
{\tt~~}\pushtabs\=\+\(    \KWD{where} \{\,0 \leq a < n, 0 \leq a + m \cdot c < n\,\}\)\-\\\poptabs
\(  \KWD{opr} [j\COLON \TYP{IndexInt}] \ASSIGN (v\COLON \TYP{BinaryEndianWord}\llbracket{}b, \VAR{bigEndianBytes}, \VAR{bigEndianBits}\rrbracket)\COLON \)\\
{\tt~~~}\pushtabs\=\+\(     \TYP{BinaryEndianLinearEndianSequence}\llbracket\null\)\pushtabs\=\+\(b,\VAR{bigEndianBytes},\VAR{bigEndianBits},\)\\
\(                                       n,\VAR{bigEndianSequence}\rrbracket\)\-\-\\\poptabs\poptabs
{\tt~~}\pushtabs\=\+\(    \KWD{throws} \{\,\TYP{IndexOutOfBounds}\,\}\)\-\\\poptabs
\(  \KWD{opr} \llbracket\KWD{nat} k\rrbracket [j\COLON \TYP{IntegerStatic}\llbracket{}k\rrbracket] \ASSIGN\)\\
{\tt~~~}\pushtabs\=\+\(     (v\COLON \TYP{BinaryEndianWord}\llbracket{}b, \VAR{bigEndianBytes}, \VAR{bigEndianBits}\rrbracket)\COLON \)\\
\(     \TYP{BinaryEndianLinearEndianSequence}\llbracket\null\)\pushtabs\=\+\(b,\VAR{bigEndianBytes},\VAR{bigEndianBits},\)\\
\(                                       n,\VAR{bigEndianSequence}\rrbracket\)\-\-\\\poptabs\poptabs
{\tt~~}\pushtabs\=\+\(    \KWD{where} \{\,k < n\,\}\)\-\\\poptabs
\(  \KWD{opr} \llbracket\KWD{nat} m\rrbracket[r\COLON \TYP{RangeOfStaticSize}\llbracket\TYP{IndexInt},m\rrbracket] \ASSIGN\)\\
{\tt~~~}\pushtabs\=\+\(     (v\COLON \TYP{BinaryEndianLinearEndianSequence}\llbracket\null\)\pushtabs\=\+\(b,\VAR{bigEndianBytes},\VAR{bigEndianBits},\)\\
\(                                           m,\VAR{bigEndianSequence}\rrbracket)\COLON \)\-\\\poptabs
\(     \TYP{BinaryEndianLinearEndianSequence}\llbracket\null\)\pushtabs\=\+\(b,\VAR{bigEndianBytes},\VAR{bigEndianBits},\)\\
\(                                       n,\VAR{bigEndianSequence}\rrbracket\)\-\-\\\poptabs\poptabs
{\tt~~}\pushtabs\=\+\(    \KWD{throws} \{\,\TYP{IndexOutOfBounds}\,\}\)\-\\\poptabs
\(  \KWD{opr} \llbracket\KWD{int} a,\KWD{nat} m,\KWD{int} c\rrbracket[r\COLON \TYP{StaticRange}\llbracket{}a,m,c\rrbracket] \ASSIGN\)\\
{\tt~~~}\pushtabs\=\+\(     (v\COLON \TYP{BinaryEndianLinearEndianSequence}\llbracket\null\)\pushtabs\=\+\(b,\VAR{bigEndianBytes},\VAR{bigEndianBits},\)\\
\(                                           k,\VAR{bigEndianSequence}\rrbracket)\COLON \)\-\\\poptabs
\(     \TYP{BinaryEndianLinearEndianSequence}\llbracket\null\)\pushtabs\=\+\(b,\VAR{bigEndianBytes},\VAR{bigEndianBits},\)\\
\(                                       n,\VAR{bigEndianSequence}\rrbracket\)\-\-\\\poptabs\poptabs
{\tt~~}\pushtabs\=\+\(    \KWD{where} \{\,0 \leq a < n, 0 \leq a + m \cdot c < n\,\}\)\-\\\poptabs
\(  \VAR{update}(j\COLON \TYP{IndexInt}, v\COLON \TYP{BinaryEndianWord}\llbracket{}b, \VAR{bigEndianBytes}, \VAR{bigEndianBits}\rrbracket)\COLON \)\\
{\tt~~~}\pushtabs\=\+\(     \TYP{BinaryEndianLinearEndianSequence}\llbracket\null\)\pushtabs\=\+\(b,\VAR{bigEndianBytes},\VAR{bigEndianBits},\)\\
\(                                       n,\VAR{bigEndianSequence}\rrbracket\)\-\-\\\poptabs\poptabs
{\tt~~}\pushtabs\=\+\(    \KWD{throws} \{\,\TYP{IndexOutOfBounds}\,\}\)\-\\\poptabs
\(  \VAR{update}\llbracket\KWD{nat} k\rrbracket(\null\)\pushtabs\=\+\(j\COLON \TYP{IntegerStatic}\llbracket{}k\rrbracket,\)\\
\(                  v\COLON \TYP{BinaryEndianWord}\llbracket{}b, \VAR{bigEndianBytes}, \VAR{bigEndianBits}\rrbracket)\COLON \)\-\\\poptabs
{\tt~~~}\pushtabs\=\+\(     \TYP{BinaryEndianLinearEndianSequence}\llbracket\null\)\pushtabs\=\+\(b,\VAR{bigEndianBytes},\VAR{bigEndianBits},\)\\
\(                                       n,\VAR{bigEndianSequence}\rrbracket\)\-\-\\\poptabs\poptabs
{\tt~~}\pushtabs\=\+\(    \KWD{where} \{\,k < n\,\}\)\-\\\poptabs
\(  \VAR{update}\llbracket\KWD{nat} m\rrbracket(\null\)\pushtabs\=\+\(r\COLON \TYP{RangeOfStaticSize}\llbracket\TYP{IndexInt},m\rrbracket,\)\\
\(                  v\COLON \TYP{BinaryEndianLinearEndianSequence}\llbracket\null\)\pushtabs\=\+\(b,\VAR{bigEndianBytes},\VAR{bigEndianBits},\)\\
\(                                                       m,\VAR{bigEndianSequence}\rrbracket)\COLON \)\-\-\\\poptabs\poptabs
{\tt~~~}\pushtabs\=\+\(     \TYP{BinaryEndianLinearEndianSequence}\llbracket\null\)\pushtabs\=\+\(b,\VAR{bigEndianBytes},\VAR{bigEndianBits},\)\\
\(                                       n,\VAR{bigEndianSequence}\rrbracket\)\-\-\\\poptabs\poptabs
{\tt~~}\pushtabs\=\+\(    \KWD{throws} \{\,\TYP{IndexOutOfBounds}\,\}\)\-\\\poptabs
\(  \VAR{update}\llbracket\KWD{int} a,\KWD{nat} m,\KWD{int} c\rrbracket\)\\
{\tt~~~}\pushtabs\=\+\(     (\null\)\pushtabs\=\+\(r\COLON \TYP{StaticRange}\llbracket{}a,m,c\rrbracket,\)\\
\(      v\COLON \TYP{BinaryEndianLinearEndianSequence}\llbracket\null\)\pushtabs\=\+\(b,\VAR{bigEndianBytes},\VAR{bigEndianBits},\)\\
\(                                           m,\VAR{bigEndianSequence}\rrbracket)\COLON \)\-\-\\\poptabs\poptabs
\(     \TYP{BinaryEndianLinearEndianSequence}\llbracket\null\)\pushtabs\=\+\(b,\VAR{bigEndianBytes},\VAR{bigEndianBits},\)\\
\(                                       n,\VAR{bigEndianSequence}\rrbracket\)\-\-\\\poptabs\poptabs
{\tt~~}\pushtabs\=\+\(    \KWD{where} \{\,0 \leq a < n, 0 \leq a + m \cdot c < n\,\}\)\-\\\poptabs
\(  \KWD{opr}\,\|\,\llbracket\KWD{nat} m\rrbracket(\KWD{self}, \VAR{other}\COLON \TYP{BinaryEndianLinearEndianSequence}\llbracket\)\\
{\tt~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~}\pushtabs\=\+\(                                  b,\VAR{bigEndianBytes},\VAR{bigEndianBits},\)\\
\(                                  m,\VAR{bigEndianSequence}\rrbracket)\COLON \)\-\\\poptabs
{\tt~~~}\pushtabs\=\+\(     \TYP{BinaryEndianLinearEndianSequence}\llbracket\null\)\pushtabs\=\+\(b,\VAR{bigEndianBytes},\VAR{bigEndianBits},\)\\
\(                                       n+m,\VAR{bigEndianSequence}\rrbracket\)\-\-\\\poptabs\poptabs
\(  \KWD{opr}\,\|\,\llbracket\KWD{nat} m,\KWD{nat} \VAR{radix},\KWD{nat} q,\KWD{nat} k,\KWD{nat} v\rrbracket(\KWD{self}, \VAR{other}\COLON \TYP{NaturalNumeral}\llbracket{}m,\VAR{radix},v\rrbracket)\COLON \)\\
{\tt~~~}\pushtabs\=\+\(     \TYP{LinearSequence}\llbracket{}T,n+k\rrbracket\)\-\\\poptabs
{\tt~~}\pushtabs\=\+\(    \KWD{where} \{\,\VAR{radix} = 2^{q}, q \cdot m = k \cdot 2^{b}\,\}\)\-\\\poptabs
\(  \KWD{opr}\,\|\,\llbracket\KWD{nat} m,\KWD{nat} \VAR{radix},\KWD{nat} q,\KWD{nat} k,\KWD{nat} v\rrbracket(\VAR{other}\COLON \TYP{NaturalNumeral}\llbracket{}m,\VAR{radix},v\rrbracket, \KWD{self})\COLON \)\\
{\tt~~~}\pushtabs\=\+\(     \TYP{LinearSequence}\llbracket{}T,n+k\rrbracket\)\-\\\poptabs
{\tt~~}\pushtabs\=\+\(    \KWD{where} \{\,\VAR{radix} = 2^{q}, q \cdot m = k \cdot 2^{b}\,\}\)\-\\\poptabs
\(  \VAR{littleEndian}()\COLON \TYP{BinaryEndianLinearEndianSequence}\llbracket{}b,\VAR{false},\VAR{false},n,\VAR{bigEndianSequence}\rrbracket\)\\
\(  \VAR{bigEndian}()\COLON \TYP{BinaryEndianLinearEndianSequence}\llbracket{}b,\VAR{true},\VAR{true},n,\VAR{bigEndianSequence}\rrbracket\)\\
\(  \VAR{littleEndianBits}()\COLON \TYP{BinaryEndianLinearEndianSequence}\llbracket\null\)\pushtabs\=\+\(b,\VAR{bigEndianBytes},\VAR{false},\)\\
\(                                                        n,\VAR{bigEndianSequence}\rrbracket\)\-\\\poptabs
\(  \VAR{bigEndianBits}()\COLON \TYP{BinaryEndianLinearEndianSequence}\llbracket\null\)\pushtabs\=\+\(b,\VAR{bigEndianBytes},\VAR{true},\)\\
\(                                                     n,\VAR{bigEndianSequence}\rrbracket\)\-\\\poptabs
\(  \VAR{littleEndianSequence}()\COLON \TYP{BinaryEndianLinearEndianSequence}\llbracket\null\)\pushtabs\=\+\(b,\VAR{bigEndianBytes},\VAR{bigEndianBits},\)\\
\(                                                            n,\VAR{false}\rrbracket\)\-\\\poptabs
\(  \VAR{bigEndianSequence}()\COLON \TYP{BinaryEndianLinearEndianSequence}\llbracket\null\)\pushtabs\=\+\(b,\VAR{bigEndianBytes},\VAR{bigEndianBits},\)\\
\(                                                         n,\VAR{true}\rrbracket\)\-\\\poptabs
\(  \VAR{split}\llbracket\KWD{nat} b'\rrbracket()\COLONOP\)\\
{\tt~~~~}\pushtabs\=\+\(      \TYP{BinaryEndianLinearEndianSequence}\llbracket\null\)\pushtabs\=\+\(b',\VAR{bigEndianBytes},\VAR{bigEndianBits},\)\\
\(                                        n \cdot 2^{b-b'},\VAR{bigEndianSequence}\rrbracket\)\-\-\\\poptabs\poptabs
{\tt~~}\pushtabs\=\+\(    \KWD{where} \{\,b' \leq b\,\}\)\-\-\\\poptabs\poptabs
\(\KWD{end}\)
\end{Fortress}


%%   coerce[\nat b',bool bigEndianBytes,bool bigEndianBits\]
%%      (x: BinaryEndianWord[\b',bigEndianBytes,bigEndianBits\])
%%     where { bigEndianBytes = bigEndianSequence, 2^b' = n DOT 2^b }
\Method{\EXP{\KWD{coerce}\llbracket\KWD{nat} b',\KWD{bool} \VAR{bigEndianBytes},\KWD{bool} \VAR{bigEndianBits}\rrbracket}\\
{\tt~~~}\EXP{(x\COLON \TYP{BinaryEndianWord}\llbracket{}b',\VAR{bigEndianBytes},\VAR{bigEndianBits}\rrbracket)}\\
{\tt~~}\EXP{\KWD{where} \{\,\VAR{bigEndianBytes} = \VAR{bigEndianSequence}, 2^{b'} = n \cdot 2^{b}\,\}}}

[Description to be supplied.]


%%   coerce[\nat m,nat radix,nat q,nat k,nat v\](x: NaturalNumeral[\m,radix,v\])
%%     where { radix = 2^q, q DOT m = n DOT 2^bk }
\Method{\EXP{\KWD{coerce}\llbracket\KWD{nat} m,\KWD{nat} \VAR{radix},\KWD{nat} q,\KWD{nat} k,\KWD{nat} v\rrbracket(x\COLON \TYP{NaturalNumeral}\llbracket{}m,\VAR{radix},v\rrbracket)}\\
{\tt~~}\EXP{\KWD{where} \{\,\VAR{radix} = 2^{q}, q \cdot m = n \cdot 2^{\VAR{bk}}\,\}}}

[Description to be supplied.]


%%   opr [j: IndexInt] : BinaryEndianWord[\b, bigEndianBytes, bigEndianBits\]
%%     throws { IndexOutOfBounds }
%%   opr [\nat k\] [j: IntegerStatic[\k\]] : BinaryWord[\b, bigEndianBytes, bigEndianBits\]
%%     where { k < n }
\Method{\EXP{\KWD{opr} [j\COLON \TYP{IndexInt}] \mathrel{\mathtt{:}} \TYP{BinaryEndianWord}\llbracket{}b, \VAR{bigEndianBytes}, \VAR{bigEndianBits}\rrbracket}\\
{\tt~~}\EXP{\KWD{throws} \{\,\TYP{IndexOutOfBounds}\,\}}}
\Method*{\EXP{\KWD{opr} \llbracket\KWD{nat} k\rrbracket [j\COLON \TYP{IntegerStatic}\llbracket{}k\rrbracket] \mathrel{\mathtt{:}} \TYP{BinaryWord}\llbracket{}b, \VAR{bigEndianBytes}, \VAR{bigEndianBits}\rrbracket}\\
{\tt~~}\EXP{\KWD{where} \{\,k < n\,\}}}

[Description to be supplied.]


%%   opr [\nat m\] [r: RangeOfStaticSize[\IndexInt,m\]] :
%%      BinaryEndianLinearEndianSequence[\b,bigEndianBytes,bigEndianBits,
%%                                        m,bigEndianSequence\]
%%     throws { IndexOutOfBounds } where { m <= n }
%%   opr [\int a,nat m,int c\] [r: StaticRange[\a,m,c\]] :
%%      BinaryEndianLinearEndianSequence[\b,bigEndianBytes,bigEndianBits,
%%                                        m,bigEndianSequence\]
%%     where { 0 <= a < n, 0 <= a + m DOT c < n }
\Method{\EXP{\KWD{opr} \llbracket\KWD{nat} m\rrbracket [r\COLON \TYP{RangeOfStaticSize}\llbracket\TYP{IndexInt},m\rrbracket] \mathrel{\mathtt{:}} }\\
{\tt~~~}\EXP{\TYP{BinaryEndianLinearEndianSequence}\llbracket{}b,\VAR{bigEndianBytes},\VAR{bigEndianBits},}\\
{\tt~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~}\EXP{m,\VAR{bigEndianSequence}\rrbracket}\\
{\tt~~}\EXP{\KWD{throws} \{\,\TYP{IndexOutOfBounds}\,\} \KWD{where} \{\,m \leq n\,\}}}
\Method*{\EXP{\KWD{opr} \llbracket\KWD{int} a,\KWD{nat} m,\KWD{int} c\rrbracket [r\COLON \TYP{StaticRange}\llbracket{}a,m,c\rrbracket] \mathrel{\mathtt{:}} }\\
{\tt~~~}\EXP{\TYP{BinaryEndianLinearEndianSequence}\llbracket{}b,\VAR{bigEndianBytes},\VAR{bigEndianBits},}\\
{\tt~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~}\EXP{m,\VAR{bigEndianSequence}\rrbracket}\\
{\tt~~}\EXP{\KWD{where} \{\,0 \leq a < n, 0 \leq a + m \cdot c < n\,\}}}

[Description to be supplied.]


%%   opr [j: IndexInt] := (v: BinaryEndianWord[\b, bigEndianBytes, bigEndianBits\]):
%%      BinaryEndianLinearEndianSequence[\b,bigEndianBytes,bigEndianBits,
%%                                        n,bigEndianSequence\]
%%     throws { IndexOutOfBounds }
%%   opr [\nat k\] [j: IntegerStatic[\k\]] :=
%%      (v: BinaryEndianWord[\b, bigEndianBytes, bigEndianBits\]):
%%      BinaryEndianLinearEndianSequence[\b,bigEndianBytes,bigEndianBits,
%%                                        n,bigEndianSequence\]
%%     where { k < n }
\Method{\EXP{\KWD{opr} [j\COLON \TYP{IndexInt}] \ASSIGN (v\COLON \TYP{BinaryEndianWord}\llbracket{}b, \VAR{bigEndianBytes}, \VAR{bigEndianBits}\rrbracket)\COLON }\\
{\tt~~~}\EXP{\TYP{BinaryEndianLinearEndianSequence}\llbracket{}b,\VAR{bigEndianBytes},\VAR{bigEndianBits},}\\
{\tt~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~}\EXP{n,\VAR{bigEndianSequence}\rrbracket}\\
{\tt~~}\EXP{\KWD{throws} \{\,\TYP{IndexOutOfBounds}\,\}}}
\Method*{\EXP{\KWD{opr} \llbracket\KWD{nat} k\rrbracket [j\COLON \TYP{IntegerStatic}\llbracket{}k\rrbracket] \ASSIGN}\\
{\tt~~~}\EXP{(v\COLON \TYP{BinaryEndianWord}\llbracket{}b, \VAR{bigEndianBytes}, \VAR{bigEndianBits}\rrbracket)\COLON }\\
{\tt~~~}\EXP{\TYP{BinaryEndianLinearEndianSequence}\llbracket{}b,\VAR{bigEndianBytes},\VAR{bigEndianBits},}\\
{\tt~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~}\EXP{n,\VAR{bigEndianSequence}\rrbracket}\\
{\tt~~}\EXP{\KWD{where} \{\,k < n\,\}}}

[Description to be supplied.]


%%   opr [\nat m\][r: RangeOfStaticSize[\IndexInt,m\]] :=
%%      (v: BinaryEndianLinearEndianSequence[\b,bigEndianBytes,bigEndianBits,
%%                                            m,bigEndianSequence\]):
%%      BinaryEndianLinearEndianSequence[\b,bigEndianBytes,bigEndianBits,
%%                                        n,bigEndianSequence\]
%%     throws { IndexOutOfBounds }
%%   opr [\int a,nat m,int c\][r: StaticRange[\a,m,c\]] :=
%%      (v: BinaryEndianLinearEndianSequence[\b,bigEndianBytes,bigEndianBits,
%%                                            k,bigEndianSequence\]):
%%      BinaryEndianLinearEndianSequence[\b,bigEndianBytes,bigEndianBits,
%%                                        n,bigEndianSequence\]
%%     where { 0 <= a < n, 0 <= a + m DOT c < n }
\Method{\EXP{\KWD{opr} \llbracket\KWD{nat} m\rrbracket[r\COLON \TYP{RangeOfStaticSize}\llbracket\TYP{IndexInt},m\rrbracket] \ASSIGN}\\
{\tt~~~}\EXP{(v\COLON \TYP{BinaryEndianLinearEndianSequence}\llbracket{}b,\VAR{bigEndianBytes},\VAR{bigEndianBits},}\\
{\tt~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~}\EXP{m,\VAR{bigEndianSequence}\rrbracket)\COLON }\\
{\tt~~~}\EXP{\TYP{BinaryEndianLinearEndianSequence}\llbracket{}b,\VAR{bigEndianBytes},\VAR{bigEndianBits},}\\
{\tt~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~}\EXP{n,\VAR{bigEndianSequence}\rrbracket}\\
{\tt~~}\EXP{\KWD{throws} \{\,\TYP{IndexOutOfBounds}\,\}}}
\Method*{\EXP{\KWD{opr} \llbracket\KWD{int} a,\KWD{nat} m,\KWD{int} c\rrbracket[r\COLON \TYP{StaticRange}\llbracket{}a,m,c\rrbracket] \ASSIGN}\\
{\tt~~~}\EXP{(v\COLON \TYP{BinaryEndianLinearEndianSequence}\llbracket{}b,\VAR{bigEndianBytes},\VAR{bigEndianBits},}\\
{\tt~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~}\EXP{k,\VAR{bigEndianSequence}\rrbracket)\COLON }\\
{\tt~~~}\EXP{\TYP{BinaryEndianLinearEndianSequence}\llbracket{}b,\VAR{bigEndianBytes},\VAR{bigEndianBits},}\\
{\tt~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~}\EXP{n,\VAR{bigEndianSequence}\rrbracket}\\
{\tt~~}\EXP{\KWD{where} \{\,0 \leq a < n, 0 \leq a + m \cdot c < n\,\}}}

[Description to be supplied.]


%%   update(j: IndexInt, v: BinaryEndianWord[\b, bigEndianBytes, bigEndianBits\]):
%%      BinaryEndianLinearEndianSequence[\b,bigEndianBytes,bigEndianBits,
%%                                        n,bigEndianSequence\]
%%     throws { IndexOutOfBounds }
%%   update[\nat k\](j: IntegerStatic[\k\],
%%                   v: BinaryEndianWord[\b, bigEndianBytes, bigEndianBits\]):
%%      BinaryEndianLinearEndianSequence[\b,bigEndianBytes,bigEndianBits,
%%                                        n,bigEndianSequence\]
%%     where { k < n }
\Method{\EXP{\VAR{update}(j\COLON \TYP{IndexInt}, v\COLON \TYP{BinaryEndianWord}\llbracket{}b, \VAR{bigEndianBytes}, \VAR{bigEndianBits}\rrbracket)\COLON }\\
{\tt~~~}\EXP{\TYP{BinaryEndianLinearEndianSequence}\llbracket{}b,\VAR{bigEndianBytes},\VAR{bigEndianBits},}\\
{\tt~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~}\EXP{n,\VAR{bigEndianSequence}\rrbracket}\\
{\tt~~}\EXP{\KWD{throws} \{\,\TYP{IndexOutOfBounds}\,\}}}
\Method*{\EXP{\VAR{update}\llbracket\KWD{nat} k\rrbracket(j\COLON \TYP{IntegerStatic}\llbracket{}k\rrbracket,}\\
{\tt~~~~~~~~~~~~~~~~}\EXP{v\COLON \TYP{BinaryEndianWord}\llbracket{}b, \VAR{bigEndianBytes}, \VAR{bigEndianBits}\rrbracket)\COLON }\\
{\tt~~~}\EXP{\TYP{BinaryEndianLinearEndianSequence}\llbracket{}b,\VAR{bigEndianBytes},\VAR{bigEndianBits},}\\
{\tt~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~}\EXP{n,\VAR{bigEndianSequence}\rrbracket}\\
{\tt~~}\EXP{\KWD{where} \{\,k < n\,\}}}

[Description to be supplied.]


%%   update[\nat m\](r: RangeOfStaticSize[\IndexInt,m\],
%%                   v: BinaryEndianLinearEndianSequence[\b,bigEndianBytes,bigEndianBits,
%%                                                        m,bigEndianSequence\]):
%%      BinaryEndianLinearEndianSequence[\b,bigEndianBytes,bigEndianBits,
%%                                        n,bigEndianSequence\]
%%     throws { IndexOutOfBounds }
%%   update[\int a,nat m,int c\]
%%      (r: StaticRange[\a,m,c\],
%%       v: BinaryEndianLinearEndianSequence[\b,bigEndianBytes,bigEndianBits,
%%                                            m,bigEndianSequence\]):
%%      BinaryEndianLinearEndianSequence[\b,bigEndianBytes,bigEndianBits,
%%                                        n,bigEndianSequence\]
%%     where { 0 <= a < n, 0 <= a + m DOT c < n }
\Method{\EXP{\VAR{update}\llbracket\KWD{nat} m\rrbracket(r\COLON \TYP{RangeOfStaticSize}\llbracket\TYP{IndexInt},m\rrbracket,}\\
{\tt~~~~~~~~~~~~~~~~}\EXP{v\COLON \TYP{BinaryEndianLinearEndianSequence}\llbracket{}b,\VAR{bigEndianBytes},\VAR{bigEndianBits},}\\
{\tt~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~}\EXP{m,\VAR{bigEndianSequence}\rrbracket)\COLON }\\
{\tt~~~}\EXP{\TYP{BinaryEndianLinearEndianSequence}\llbracket{}b,\VAR{bigEndianBytes},\VAR{bigEndianBits},}\\
{\tt~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~}\EXP{n,\VAR{bigEndianSequence}\rrbracket}\\
{\tt~~}\EXP{\KWD{throws} \{\,\TYP{IndexOutOfBounds}\,\}}}
\Method*{\EXP{\VAR{update}\llbracket\KWD{int} a,\KWD{nat} m,\KWD{int} c\rrbracket}\\
{\tt~~~}\EXP{(r\COLON \TYP{StaticRange}\llbracket{}a,m,c\rrbracket,}\\
{\tt~~~~}\EXP{v\COLON \TYP{BinaryEndianLinearEndianSequence}\llbracket{}b,\VAR{bigEndianBytes},\VAR{bigEndianBits},}\\
{\tt~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~}\EXP{m,\VAR{bigEndianSequence}\rrbracket)\COLON }\\
{\tt~~~}\EXP{\TYP{BinaryEndianLinearEndianSequence}\llbracket{}b,\VAR{bigEndianBytes},\VAR{bigEndianBits},}\\
{\tt~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~}\EXP{n,\VAR{bigEndianSequence}\rrbracket}\\
{\tt~~}\EXP{\KWD{where} \{\,0 \leq a < n, 0 \leq a + m \cdot c < n\,\}}}

[Description to be supplied.]


%%   opr || [\nat m\](self, other: BinaryEndianLinearEndianSequence[\
%%                                   b,bigEndianBytes,bigEndianBits,
%%                                   m,bigEndianSequence\]):
%%      BinaryEndianLinearEndianSequence[\b,bigEndianBytes,bigEndianBits,
%%                                        n+m,bigEndianSequence\]
\Method{\EXP{\KWD{opr}\,\|\,\llbracket\KWD{nat} m\rrbracket(\KWD{self}, \VAR{other}\COLON \TYP{BinaryEndianLinearEndianSequence}\llbracket}\\
{\tt~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~}\EXP{b,\VAR{bigEndianBytes},\VAR{bigEndianBits},}\\
{\tt~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~}\EXP{m,\VAR{bigEndianSequence}\rrbracket)\COLON }\\
{\tt~~~}\EXP{\TYP{BinaryEndianLinearEndianSequence}\llbracket{}b,\VAR{bigEndianBytes},\VAR{bigEndianBits},}\\
{\tt~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~}\EXP{n+m,\VAR{bigEndianSequence}\rrbracket}}

[Description to be supplied.]


%%   opr || [\nat m,nat radix,nat q,nat k,nat v\](self, other: NaturalNumeral[\m,radix,v\]):
%%      LinearSequence[\T,n+k\]
%%     where { radix = 2^q, q DOT m = k DOT 2^b }
\Method{\EXP{\KWD{opr}\,\|\,\llbracket\KWD{nat} m,\KWD{nat} \VAR{radix},\KWD{nat} q,\KWD{nat} k,\KWD{nat} v\rrbracket(\KWD{self}, \VAR{other}\COLON \TYP{NaturalNumeral}\llbracket{}m,\VAR{radix},v\rrbracket)\COLON }\\
{\tt~~~}\EXP{\TYP{LinearSequence}\llbracket{}T,n+k\rrbracket}\\
{\tt~~}\EXP{\KWD{where} \{\,\VAR{radix} = 2^{q}, q \cdot m = k \cdot 2^{b}\,\}}}

[Description to be supplied.]


%%   opr || [\nat m,nat radix,nat q,nat k,nat v\](other: NaturalNumeral[\m,radix,v\], self):
%%      LinearSequence[\T,n+k\]
%%     where { radix = 2^q, q DOT m = k DOT 2^b }
\Method{\EXP{\KWD{opr}\,\|\,\llbracket\KWD{nat} m,\KWD{nat} \VAR{radix},\KWD{nat} q,\KWD{nat} k,\KWD{nat} v\rrbracket(\VAR{other}\COLON \TYP{NaturalNumeral}\llbracket{}m,\VAR{radix},v\rrbracket, \KWD{self})\COLON }\\
{\tt~~~}\EXP{\TYP{LinearSequence}\llbracket{}T,n+k\rrbracket}\\
{\tt~~}\EXP{\KWD{where} \{\,\VAR{radix} = 2^{q}, q \cdot m = k \cdot 2^{b}\,\}}}

[Description to be supplied.]


%%   littleEndian(): BinaryEndianLinearEndianSequence[\b,false,false,n,bigEndianSequence\]
%%   bigEndian(): BinaryEndianLinearEndianSequence[\b,true,true,n,bigEndianSequence\]
\Method{\EXP{\VAR{littleEndian}()\COLON \TYP{BinaryEndianLinearEndianSequence}\llbracket{}b,\VAR{false},\VAR{false},n,\VAR{bigEndianSequence}\rrbracket}}
\Method*{\EXP{\VAR{bigEndian}()\COLON \TYP{BinaryEndianLinearEndianSequence}\llbracket{}b,\VAR{true},\VAR{true},n,\VAR{bigEndianSequence}\rrbracket}}

[Description to be supplied.]


%%   littleEndianBits(): BinaryEndianLinearEndianSequence[\b,bigEndianBytes,false,
%%                                                         n,bigEndianSequence\]
%%   bigEndianBits(): BinaryEndianLinearEndianSequence[\b,bigEndianBytes,true,
%%                                                      n,bigEndianSequence\]
\Method{\EXP{\VAR{littleEndianBits}()\COLON \TYP{BinaryEndianLinearEndianSequence}\llbracket{}b,\VAR{bigEndianBytes},\VAR{false},}\\
{\tt~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~}\EXP{n,\VAR{bigEndianSequence}\rrbracket}}
\Method*{\EXP{\VAR{bigEndianBits}()\COLON \TYP{BinaryEndianLinearEndianSequence}\llbracket{}b,\VAR{bigEndianBytes},\VAR{true},}\\
{\tt~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~}\EXP{n,\VAR{bigEndianSequence}\rrbracket}}

[Description to be supplied.]


%%   littleEndianSequence(): BinaryEndianLinearEndianSequence[\b,bigEndianBytes,bigEndianBits,
%%                                                             n,false\]
%%   bigEndianSequence(): BinaryEndianLinearEndianSequence[\b,bigEndianBytes,bigEndianBits,
%%                                                          n,true\]
\Method{\EXP{\VAR{littleEndianSequence}()\COLON \TYP{BinaryEndianLinearEndianSequence}\llbracket{}b,\VAR{bigEndianBytes},\VAR{bigEndianBits},}\\
{\tt~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~}\EXP{n,\VAR{false}\rrbracket}}
\Method*{\EXP{\VAR{bigEndianSequence}()\COLON \TYP{BinaryEndianLinearEndianSequence}\llbracket{}b,\VAR{bigEndianBytes},\VAR{bigEndianBits},}\\
{\tt~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~}\EXP{n,\VAR{true}\rrbracket}}

[Description to be supplied.]


%%   split[\nat b'\]():
%%       BinaryEndianLinearEndianSequence[\b',bigEndianBytes,bigEndianBits,
%%                                         n DOT 2^(b-b'),bigEndianSequence\]
%%     where { b' <= b }
\Method{\EXP{\VAR{split}\llbracket\KWD{nat} b'\rrbracket()\COLONOP}\\
{\tt~~~~}\EXP{\TYP{BinaryEndianLinearEndianSequence}\llbracket{}b',\VAR{bigEndianBytes},\VAR{bigEndianBits},}\\
{\tt~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~}\EXP{n \cdot 2^{b-b'},\VAR{bigEndianSequence}\rrbracket}\\
{\tt~~}\EXP{\KWD{where} \{\,b' \leq b\,\}}}

[Description to be supplied.]







\Trait{Fortress.Core.BinaryHeapEndianSequence}
\seclabel{lib:BinaryHeapEndianSequence}

%% trait BinaryHeapEndianSequence[\nat b, bool bigEndianSequence\]
%%     extends { BinaryHeapSequence[\b\],
%%               BasicBinaryHeapSubsequenceOperations[\
%%                 BinaryHeapEndianSequence[\b,bigEndianSequence\],
%%                 bigEndianSequence\] }
%% end
\begin{Fortress}
\(\KWD{trait} \TYP{BinaryHeapEndianSequence}\llbracket\KWD{nat} b, \KWD{bool} \VAR{bigEndianSequence}\rrbracket\)\\
{\tt~~~~}\pushtabs\=\+\(    \KWD{extends} \{\,\null\)\pushtabs\=\+\(\TYP{BinaryHeapSequence}\llbracket{}b\rrbracket,\)\\
\(              \TYP{BasicBinaryHeapSubsequenceOperations}\llbracket\)\\
{\tt~~}\pushtabs\=\+\(                \TYP{BinaryHeapEndianSequence}\llbracket{}b,\VAR{bigEndianSequence}\rrbracket,\)\\
\(                \VAR{bigEndianSequence}\rrbracket\,\}\)\-\-\-\\\poptabs\poptabs\poptabs
\(\KWD{end}\)
\end{Fortress}


\Trait{Fortress.Core.BinaryEndianHeapEndianSequence}
\seclabel{lib:BinaryEndianHeapEndianSequence}

%% trait BinaryEndianHeapEndianSequence[\nat b, bool bigEndianBytes, bool bigEndianBits,
%%                                       bool bigEndianSequence\]
%%     extends { HeapSequence[\BinaryEndianWord[\b,bigEndianBytes,bigEndianBits\]\],
%%               BasicBinaryHeapSubsequenceOperations[\
%%                 BinaryHeapEndianSequence[\b,bigEndianSequence\],
%%                 bigEndianSequence\] }
%% end
\begin{Fortress}
\(\KWD{trait} \TYP{BinaryEndianHeapEndianSequence}\llbracket\null\)\pushtabs\=\+\(\KWD{nat} b, \KWD{bool} \VAR{bigEndianBytes}, \KWD{bool} \VAR{bigEndianBits},\)\\
\(                                      \KWD{bool} \VAR{bigEndianSequence}\rrbracket\)\-\\\poptabs
{\tt~~~~}\pushtabs\=\+\(    \KWD{extends} \{\,\null\)\pushtabs\=\+\(\TYP{HeapSequence}\llbracket\TYP{BinaryEndianWord}\llbracket{}b,\VAR{bigEndianBytes},\VAR{bigEndianBits}\rrbracket\rrbracket,\)\\
\(              \TYP{BasicBinaryHeapSubsequenceOperations}\llbracket\)\\
{\tt~~}\pushtabs\=\+\(                \TYP{BinaryHeapEndianSequence}\llbracket{}b,\VAR{bigEndianSequence}\rrbracket,\)\\
\(                \VAR{bigEndianSequence}\rrbracket\,\}\)\-\-\-\\\poptabs\poptabs\poptabs
\(\KWD{end}\)
\end{Fortress}


\Trait{Fortress.Core.BasicBinaryHeapSubsequenceOperations}
\seclabel{lib:BasicBinaryHeapSubsequenceOperations}

%% trait BasicBinaryHeapSubsequenceOperations[\
%%       T extends BasicBinaryHeapSubsequenceOperations[\T,bigEndianSequence\],
%%       bool bigEndianSequence\]
%%   copy(selfStart: IndexInt, source: T, sourceStart: IndexInt, length: IndexInt): ()
%%     throws { IndexOutOfBounds }
%%   wrappingAdd(selfStart: IndexInt, source: T, sourceStart: IndexInt, length: IndexInt): ()
%%     throws { IndexOutOfBounds }
%%   add(selfStart: IndexInt, source: T, sourceStart: IndexInt,
%%       length: IndexInt, carryIn: Bit=0): Bit
%%     throws { IndexOutOfBounds }
%%   signedAdd(selfStart: IndexInt, source: T, sourceStart: IndexInt,
%%             length: IndexInt, overflowAction: ()->()): ()
%%     throws { IndexOutOfBounds }
%%   unsignedAdd(selfStart: IndexInt, source: T, sourceStart: IndexInt,
%%               length: IndexInt, overflowAction: ()->()): ()
%%     throws { IndexOutOfBounds }
%%   saturatingSignedAdd(selfStart: IndexInt, source: T, sourceStart: IndexInt, length: IndexInt): ()
%%     throws { IndexOutOfBounds }
%%   saturatingUnsignedAdd(selfStart: IndexInt, source: T, sourceStart: IndexInt, length: IndexInt): ()
%%     throws { IndexOutOfBounds }
%%   wrappingSubtract(selfStart: IndexInt, source: T, sourceStart: IndexInt, length: IndexInt): ()
%%     throws { IndexOutOfBounds }
%%   subtract(selfStart: IndexInt, source: T, sourceStart: IndexInt,
%%            length: IndexInt, carryIn: Bit=1): Bit
%%     throws { IndexOutOfBounds }
%%   signedSubtract(selfStart: IndexInt, source: T, sourceStart: IndexInt,
%%                  length: IndexInt, overflowAction: ()->()): ()
%%     throws { IndexOutOfBounds }
%%   unsignedSubtract(selfStart: IndexInt, source: T, sourceStart: IndexInt,
%%                    length: IndexInt, overflowAction: ()->()): ()
%%     throws { IndexOutOfBounds }
%%   saturatingSignedSubtract(selfStart: IndexInt, source: T, sourceStart: IndexInt,
%%                            length: IndexInt): ()
%%     throws { IndexOutOfBounds }
%%   saturatingUnsignedSubtract(selfStart: IndexInt, source: T, sourceStart: IndexInt,
%%                              length: IndexInt): ()
%%     throws { IndexOutOfBounds }
%%   wrappingNegate(selfStart: IndexInt, length: IndexInt): ()
%%     throws { IndexOutOfBounds }
%%   negate(selfStart: IndexInt, length: IndexInt, carryIn: Bit=1): Bit
%%     throws { IndexOutOfBounds }
%%   signedNegate(selfStart: IndexInt, length: IndexInt, overflowAction: ()->()): ()
%%     throws { IndexOutOfBounds }
%%   unsignedNegate(selfStart: IndexInt, length: IndexInt, overflowAction: ()->()): ()
%%     throws { IndexOutOfBounds }
%%   saturatingSignedNegate(selfStart: IndexInt, length: IndexInt): ()
%%     throws { IndexOutOfBounds }
%%   bitNot(selfStart: IndexInt, length: IndexInt): ()
%%     throws { IndexOutOfBounds }
%%   bitAnd(selfStart: IndexInt, source: T, sourceStart: IndexInt, length: IndexInt): ()
%%     throws { IndexOutOfBounds }
%%   bitOr(selfStart: IndexInt, source: T, sourceStart: IndexInt, length: IndexInt): ()
%%     throws { IndexOutOfBounds }
%%   bitXor(selfStart: IndexInt, source: T, sourceStart: IndexInt, length: IndexInt): ()
%%     throws { IndexOutOfBounds }
%%   bitXorNot(selfStart: IndexInt, source: T, sourceStart: IndexInt, length: IndexInt): ()
%%     throws { IndexOutOfBounds }
%%   bitNand(selfStart: IndexInt, source: T, sourceStart: IndexInt, length: IndexInt): ()
%%     throws { IndexOutOfBounds }
%%   bitNor(selfStart: IndexInt, source: T, sourceStart: IndexInt, length: IndexInt): ()
%%     throws { IndexOutOfBounds }
%%   bitAndNot(selfStart: IndexInt, source: T, sourceStart: IndexInt, length: IndexInt): ()
%%     throws { IndexOutOfBounds }
%%   bitOrNot(selfStart: IndexInt, source: T, sourceStart: IndexInt, length: IndexInt): ()
%%     throws { IndexOutOfBounds }
%%   signedMax(selfStart: IndexInt, source: T, sourceStart: IndexInt, length: IndexInt): ()
%%     throws { IndexOutOfBounds }
%%   signedMin(selfStart: IndexInt, source: T, sourceStart: IndexInt, length: IndexInt): ()
%%     throws { IndexOutOfBounds }
%%   unsignedMax(selfStart: IndexInt, source: T, sourceStart: IndexInt, length: IndexInt): ()
%%     throws { IndexOutOfBounds }
%%   unsignedMin(selfStart: IndexInt, source: T, sourceStart: IndexInt, length: IndexInt): ()
%%     throws { IndexOutOfBounds }
%%   equal(selfStart: IndexInt, source: T, sourceStart: IndexInt, length: IndexInt): Boolean
%%     throws { IndexOutOfBounds }
%%   unequal(selfStart: IndexInt, source: T, sourceStart: IndexInt, length: IndexInt): Boolean
%%     throws { IndexOutOfBounds }
%%   signedLT(selfStart: IndexInt, source: T, sourceStart: IndexInt, length: IndexInt): Boolean
%%     throws { IndexOutOfBounds }
%%   signedLE(selfStart: IndexInt, source: T, sourceStart: IndexInt, length: IndexInt): Boolean
%%     throws { IndexOutOfBounds }
%%   signedGE(selfStart: IndexInt, source: T, sourceStart: IndexInt, length: IndexInt): Boolean
%%     throws { IndexOutOfBounds }
%%   signedGT(selfStart: IndexInt, source: T, sourceStart: IndexInt, length: IndexInt): Boolean
%%     throws { IndexOutOfBounds }
%%   unsignedLT(selfStart: IndexInt, source: T, sourceStart: IndexInt, length: IndexInt): Boolean
%%     throws { IndexOutOfBounds }
%%   unsignedLE(selfStart: IndexInt, source: T, sourceStart: IndexInt, length: IndexInt): Boolean
%%     throws { IndexOutOfBounds }
%%   unsignedGE(selfStart: IndexInt, source: T, sourceStart: IndexInt, length: IndexInt): Boolean
%%     throws { IndexOutOfBounds }
%%   unsignedGT(selfStart: IndexInt, source: T, sourceStart: IndexInt, length: IndexInt): Boolean
%%     throws { IndexOutOfBounds }
%%   signedShift(selfStart: IndexInt, length: IndexInt, j: IndexInt): ()
%%     throws { IndexOutOfBounds }
%%   signedShift(selfStart: IndexInt, length: IndexInt, j: IndexInt, overflowAction: ()->()): ()
%%     throws { IndexOutOfBounds }
%%   saturatingSignedShift(selfStart: IndexInt, length: IndexInt, j: IndexInt): ()
%%     throws { IndexOutOfBounds }
%%   unsignedShift(selfStart: IndexInt, length: IndexInt, j: IndexInt): ()
%%     throws { IndexOutOfBounds }
%%   unsignedShift(selfStart: IndexInt, length: IndexInt, j: IndexInt, overflowAction: ()->()): ()
%%     throws { IndexOutOfBounds }
%%   saturatingUnsignedShift(selfStart: IndexInt, length: IndexInt, j: IndexInt): ()
%%     throws { IndexOutOfBounds }
%%   bitRotate(selfStart: IndexInt, length: IndexInt, j: IndexInt): ()
%%     throws { IndexOutOfBounds }
%%   countOneBits(selfStart: IndexInt, length: IndexInt): IndexInt
%%     throws { IndexOutOfBounds }
%%   countLeadingZeroBits(selfStart: IndexInt, length: IndexInt): IndexInt
%%     throws { IndexOutOfBounds }
%%   countTrailingZeroBits(selfStart: IndexInt, length: IndexInt): IndexInt
%%     throws { IndexOutOfBounds }
%%   leftmostOneBit(selfStart: IndexInt, length: IndexInt): ()
%%     throws { IndexOutOfBounds }
%%   rightmostOneBit(selfStart: IndexInt, length: IndexInt): ()
%%     throws { IndexOutOfBounds }
%%   bitReverse(selfStart: IndexInt, length: IndexInt): ()
%%     throws { IndexOutOfBounds }
%%   gatherBits(selfStart: IndexInt, mask: T, maskStart: IndexInt, length: IndexInt): ()
%%     throws { IndexOutOfBounds }
%%   spreadBits(selfStart: IndexInt, mask: T, maskStart: IndexInt, length: IndexInt): ()
%%     throws { IndexOutOfBounds }
%%   clearAllBits(selfStart: IndexInt, length: IndexInt): ()
%%     throws { IndexOutOfBounds }
%%   setAllBits(selfStart: IndexInt, length: IndexInt): ()
%%     throws { IndexOutOfBounds }
%%   signedIndex(): IndexInt
%%     throws { IntegerOverflow }
%%   signedIndex(selfStart: IndexInt, length: IndexInt): IndexInt
%%     throws { IndexOutOfBounds, IntegerOverflow }
%%   unsignedIndex(): IndexInt
%%     throws { IntegerOverflow }
%%   unsignedIndex(selfStart: IndexInt, length: IndexInt): IndexInt
%%     throws { IndexOutOfBounds, IntegerOverflow }
%% end
\begin{Fortress}
\(\KWD{trait} \null\)\pushtabs\=\+\(\TYP{BasicBinaryHeapSubsequenceOperations}\llbracket\)\\
\(      T \KWD{extends} \TYP{BasicBinaryHeapSubsequenceOperations}\llbracket{}T,\VAR{bigEndianSequence}\rrbracket,\)\\
\(      \KWD{bool} \VAR{bigEndianSequence}\rrbracket\)\-\\\poptabs
{\tt~~}\pushtabs\=\+\(  \VAR{copy}(\VAR{selfStart}\COLON \TYP{IndexInt}, \VAR{source}\COLON T, \VAR{sourceStart}\COLON \TYP{IndexInt}, \VAR{length}\COLON \TYP{IndexInt})\COLON ()\)\\
{\tt~~}\pushtabs\=\+\(    \KWD{throws} \{\,\TYP{IndexOutOfBounds}\,\}\)\-\\\poptabs
\(  \VAR{wrappingAdd}(\VAR{selfStart}\COLON \TYP{IndexInt}, \VAR{source}\COLON T, \VAR{sourceStart}\COLON \TYP{IndexInt}, \VAR{length}\COLON \TYP{IndexInt})\COLON ()\)\\
{\tt~~}\pushtabs\=\+\(    \KWD{throws} \{\,\TYP{IndexOutOfBounds}\,\}\)\-\\\poptabs
\(  \VAR{add}(\null\)\pushtabs\=\+\(\VAR{selfStart}\COLON \TYP{IndexInt}, \VAR{source}\COLON T, \VAR{sourceStart}\COLON \TYP{IndexInt},\)\\
\(      \VAR{length}\COLON \TYP{IndexInt}, \VAR{carryIn}\COLON \TYP{Bit}=0)\COLON \TYP{Bit}\)\-\\\poptabs
{\tt~~}\pushtabs\=\+\(    \KWD{throws} \{\,\TYP{IndexOutOfBounds}\,\}\)\-\\\poptabs
\(  \VAR{signedAdd}(\null\)\pushtabs\=\+\(\VAR{selfStart}\COLON \TYP{IndexInt}, \VAR{source}\COLON T, \VAR{sourceStart}\COLON \TYP{IndexInt},\)\\
\(            \VAR{length}\COLON \TYP{IndexInt}, \VAR{overflowAction}\COLON ()\rightarrow())\COLON ()\)\-\\\poptabs
{\tt~~}\pushtabs\=\+\(    \KWD{throws} \{\,\TYP{IndexOutOfBounds}\,\}\)\-\\\poptabs
\(  \VAR{unsignedAdd}(\null\)\pushtabs\=\+\(\VAR{selfStart}\COLON \TYP{IndexInt}, \VAR{source}\COLON T, \VAR{sourceStart}\COLON \TYP{IndexInt},\)\\
\(              \VAR{length}\COLON \TYP{IndexInt}, \VAR{overflowAction}\COLON ()\rightarrow())\COLON ()\)\-\\\poptabs
{\tt~~}\pushtabs\=\+\(    \KWD{throws} \{\,\TYP{IndexOutOfBounds}\,\}\)\-\\\poptabs
\(  \VAR{saturatingSignedAdd}(\VAR{selfStart}\COLON \TYP{IndexInt}, \VAR{source}\COLON T, \VAR{sourceStart}\COLON \TYP{IndexInt}, \VAR{length}\COLON \TYP{IndexInt})\COLON ()\)\\
{\tt~~}\pushtabs\=\+\(    \KWD{throws} \{\,\TYP{IndexOutOfBounds}\,\}\)\-\\\poptabs
\(  \VAR{saturatingUnsignedAdd}(\VAR{selfStart}\COLON \TYP{IndexInt}, \VAR{source}\COLON T, \VAR{sourceStart}\COLON \TYP{IndexInt}, \VAR{length}\COLON \TYP{IndexInt})\COLON ()\)\\
{\tt~~}\pushtabs\=\+\(    \KWD{throws} \{\,\TYP{IndexOutOfBounds}\,\}\)\-\\\poptabs
\(  \VAR{wrappingSubtract}(\VAR{selfStart}\COLON \TYP{IndexInt}, \VAR{source}\COLON T, \VAR{sourceStart}\COLON \TYP{IndexInt}, \VAR{length}\COLON \TYP{IndexInt})\COLON ()\)\\
{\tt~~}\pushtabs\=\+\(    \KWD{throws} \{\,\TYP{IndexOutOfBounds}\,\}\)\-\\\poptabs
\(  \VAR{subtract}(\null\)\pushtabs\=\+\(\VAR{selfStart}\COLON \TYP{IndexInt}, \VAR{source}\COLON T, \VAR{sourceStart}\COLON \TYP{IndexInt},\)\\
\(           \VAR{length}\COLON \TYP{IndexInt}, \VAR{carryIn}\COLON \TYP{Bit}=1)\COLON \TYP{Bit}\)\-\\\poptabs
{\tt~~}\pushtabs\=\+\(    \KWD{throws} \{\,\TYP{IndexOutOfBounds}\,\}\)\-\\\poptabs
\(  \VAR{signedSubtract}(\null\)\pushtabs\=\+\(\VAR{selfStart}\COLON \TYP{IndexInt}, \VAR{source}\COLON T, \VAR{sourceStart}\COLON \TYP{IndexInt},\)\\
\(                 \VAR{length}\COLON \TYP{IndexInt}, \VAR{overflowAction}\COLON ()\rightarrow())\COLON ()\)\-\\\poptabs
{\tt~~}\pushtabs\=\+\(    \KWD{throws} \{\,\TYP{IndexOutOfBounds}\,\}\)\-\\\poptabs
\(  \VAR{unsignedSubtract}(\null\)\pushtabs\=\+\(\VAR{selfStart}\COLON \TYP{IndexInt}, \VAR{source}\COLON T, \VAR{sourceStart}\COLON \TYP{IndexInt},\)\\
\(                   \VAR{length}\COLON \TYP{IndexInt}, \VAR{overflowAction}\COLON ()\rightarrow())\COLON ()\)\-\\\poptabs
{\tt~~}\pushtabs\=\+\(    \KWD{throws} \{\,\TYP{IndexOutOfBounds}\,\}\)\-\\\poptabs
\(  \VAR{saturatingSignedSubtract}(\null\)\pushtabs\=\+\(\VAR{selfStart}\COLON \TYP{IndexInt}, \VAR{source}\COLON T, \VAR{sourceStart}\COLON \TYP{IndexInt},\)\\
\(                           \VAR{length}\COLON \TYP{IndexInt})\COLON ()\)\-\\\poptabs
{\tt~~}\pushtabs\=\+\(    \KWD{throws} \{\,\TYP{IndexOutOfBounds}\,\}\)\-\\\poptabs
\(  \VAR{saturatingUnsignedSubtract}(\null\)\pushtabs\=\+\(\VAR{selfStart}\COLON \TYP{IndexInt}, \VAR{source}\COLON T, \VAR{sourceStart}\COLON \TYP{IndexInt},\)\\
\(                             \VAR{length}\COLON \TYP{IndexInt})\COLON ()\)\-\\\poptabs
{\tt~~}\pushtabs\=\+\(    \KWD{throws} \{\,\TYP{IndexOutOfBounds}\,\}\)\-\\\poptabs
\(  \VAR{wrappingNegate}(\VAR{selfStart}\COLON \TYP{IndexInt}, \VAR{length}\COLON \TYP{IndexInt})\COLON ()\)\\
{\tt~~}\pushtabs\=\+\(    \KWD{throws} \{\,\TYP{IndexOutOfBounds}\,\}\)\-\\\poptabs
\(  \VAR{negate}(\VAR{selfStart}\COLON \TYP{IndexInt}, \VAR{length}\COLON \TYP{IndexInt}, \VAR{carryIn}\COLON \TYP{Bit}=1)\COLON \TYP{Bit}\)\\
{\tt~~}\pushtabs\=\+\(    \KWD{throws} \{\,\TYP{IndexOutOfBounds}\,\}\)\-\\\poptabs
\(  \VAR{signedNegate}(\VAR{selfStart}\COLON \TYP{IndexInt}, \VAR{length}\COLON \TYP{IndexInt}, \VAR{overflowAction}\COLON ()\rightarrow())\COLON ()\)\\
{\tt~~}\pushtabs\=\+\(    \KWD{throws} \{\,\TYP{IndexOutOfBounds}\,\}\)\-\\\poptabs
\(  \VAR{unsignedNegate}(\VAR{selfStart}\COLON \TYP{IndexInt}, \VAR{length}\COLON \TYP{IndexInt}, \VAR{overflowAction}\COLON ()\rightarrow())\COLON ()\)\\
{\tt~~}\pushtabs\=\+\(    \KWD{throws} \{\,\TYP{IndexOutOfBounds}\,\}\)\-\\\poptabs
\(  \VAR{saturatingSignedNegate}(\VAR{selfStart}\COLON \TYP{IndexInt}, \VAR{length}\COLON \TYP{IndexInt})\COLON ()\)\\
{\tt~~}\pushtabs\=\+\(    \KWD{throws} \{\,\TYP{IndexOutOfBounds}\,\}\)\-\\\poptabs
\(  \VAR{bitNot}(\VAR{selfStart}\COLON \TYP{IndexInt}, \VAR{length}\COLON \TYP{IndexInt})\COLON ()\)\\
{\tt~~}\pushtabs\=\+\(    \KWD{throws} \{\,\TYP{IndexOutOfBounds}\,\}\)\-\\\poptabs
\(  \VAR{bitAnd}(\VAR{selfStart}\COLON \TYP{IndexInt}, \VAR{source}\COLON T, \VAR{sourceStart}\COLON \TYP{IndexInt}, \VAR{length}\COLON \TYP{IndexInt})\COLON ()\)\\
{\tt~~}\pushtabs\=\+\(    \KWD{throws} \{\,\TYP{IndexOutOfBounds}\,\}\)\-\\\poptabs
\(  \VAR{bitOr}(\VAR{selfStart}\COLON \TYP{IndexInt}, \VAR{source}\COLON T, \VAR{sourceStart}\COLON \TYP{IndexInt}, \VAR{length}\COLON \TYP{IndexInt})\COLON ()\)\\
{\tt~~}\pushtabs\=\+\(    \KWD{throws} \{\,\TYP{IndexOutOfBounds}\,\}\)\-\\\poptabs
\(  \VAR{bitXor}(\VAR{selfStart}\COLON \TYP{IndexInt}, \VAR{source}\COLON T, \VAR{sourceStart}\COLON \TYP{IndexInt}, \VAR{length}\COLON \TYP{IndexInt})\COLON ()\)\\
{\tt~~}\pushtabs\=\+\(    \KWD{throws} \{\,\TYP{IndexOutOfBounds}\,\}\)\-\\\poptabs
\(  \VAR{bitXorNot}(\VAR{selfStart}\COLON \TYP{IndexInt}, \VAR{source}\COLON T, \VAR{sourceStart}\COLON \TYP{IndexInt}, \VAR{length}\COLON \TYP{IndexInt})\COLON ()\)\\
{\tt~~}\pushtabs\=\+\(    \KWD{throws} \{\,\TYP{IndexOutOfBounds}\,\}\)\-\\\poptabs
\(  \VAR{bitNand}(\VAR{selfStart}\COLON \TYP{IndexInt}, \VAR{source}\COLON T, \VAR{sourceStart}\COLON \TYP{IndexInt}, \VAR{length}\COLON \TYP{IndexInt})\COLON ()\)\\
{\tt~~}\pushtabs\=\+\(    \KWD{throws} \{\,\TYP{IndexOutOfBounds}\,\}\)\-\\\poptabs
\(  \VAR{bitNor}(\VAR{selfStart}\COLON \TYP{IndexInt}, \VAR{source}\COLON T, \VAR{sourceStart}\COLON \TYP{IndexInt}, \VAR{length}\COLON \TYP{IndexInt})\COLON ()\)\\
{\tt~~}\pushtabs\=\+\(    \KWD{throws} \{\,\TYP{IndexOutOfBounds}\,\}\)\-\\\poptabs
\(  \VAR{bitAndNot}(\VAR{selfStart}\COLON \TYP{IndexInt}, \VAR{source}\COLON T, \VAR{sourceStart}\COLON \TYP{IndexInt}, \VAR{length}\COLON \TYP{IndexInt})\COLON ()\)\\
{\tt~~}\pushtabs\=\+\(    \KWD{throws} \{\,\TYP{IndexOutOfBounds}\,\}\)\-\\\poptabs
\(  \VAR{bitOrNot}(\VAR{selfStart}\COLON \TYP{IndexInt}, \VAR{source}\COLON T, \VAR{sourceStart}\COLON \TYP{IndexInt}, \VAR{length}\COLON \TYP{IndexInt})\COLON ()\)\\
{\tt~~}\pushtabs\=\+\(    \KWD{throws} \{\,\TYP{IndexOutOfBounds}\,\}\)\-\\\poptabs
\(  \VAR{signedMax}(\VAR{selfStart}\COLON \TYP{IndexInt}, \VAR{source}\COLON T, \VAR{sourceStart}\COLON \TYP{IndexInt}, \VAR{length}\COLON \TYP{IndexInt})\COLON ()\)\\
{\tt~~}\pushtabs\=\+\(    \KWD{throws} \{\,\TYP{IndexOutOfBounds}\,\}\)\-\\\poptabs
\(  \VAR{signedMin}(\VAR{selfStart}\COLON \TYP{IndexInt}, \VAR{source}\COLON T, \VAR{sourceStart}\COLON \TYP{IndexInt}, \VAR{length}\COLON \TYP{IndexInt})\COLON ()\)\\
{\tt~~}\pushtabs\=\+\(    \KWD{throws} \{\,\TYP{IndexOutOfBounds}\,\}\)\-\\\poptabs
\(  \VAR{unsignedMax}(\VAR{selfStart}\COLON \TYP{IndexInt}, \VAR{source}\COLON T, \VAR{sourceStart}\COLON \TYP{IndexInt}, \VAR{length}\COLON \TYP{IndexInt})\COLON ()\)\\
{\tt~~}\pushtabs\=\+\(    \KWD{throws} \{\,\TYP{IndexOutOfBounds}\,\}\)\-\\\poptabs
\(  \VAR{unsignedMin}(\VAR{selfStart}\COLON \TYP{IndexInt}, \VAR{source}\COLON T, \VAR{sourceStart}\COLON \TYP{IndexInt}, \VAR{length}\COLON \TYP{IndexInt})\COLON ()\)\\
{\tt~~}\pushtabs\=\+\(    \KWD{throws} \{\,\TYP{IndexOutOfBounds}\,\}\)\-\\\poptabs
\(  \VAR{equal}(\VAR{selfStart}\COLON \TYP{IndexInt}, \VAR{source}\COLON T, \VAR{sourceStart}\COLON \TYP{IndexInt}, \VAR{length}\COLON \TYP{IndexInt})\COLON \TYP{Boolean} \)\\
{\tt~~}\pushtabs\=\+\(    \KWD{throws} \{\,\TYP{IndexOutOfBounds}\,\}\)\-\\\poptabs
\(  \VAR{unequal}(\VAR{selfStart}\COLON \TYP{IndexInt}, \VAR{source}\COLON T, \VAR{sourceStart}\COLON \TYP{IndexInt}, \VAR{length}\COLON \TYP{IndexInt})\COLON \TYP{Boolean} \)\\
{\tt~~}\pushtabs\=\+\(    \KWD{throws} \{\,\TYP{IndexOutOfBounds}\,\}\)\-\\\poptabs
\(  \VAR{signedLT}(\VAR{selfStart}\COLON \TYP{IndexInt}, \VAR{source}\COLON T, \VAR{sourceStart}\COLON \TYP{IndexInt}, \VAR{length}\COLON \TYP{IndexInt})\COLON \TYP{Boolean} \)\\
{\tt~~}\pushtabs\=\+\(    \KWD{throws} \{\,\TYP{IndexOutOfBounds}\,\}\)\-\\\poptabs
\(  \VAR{signedLE}(\VAR{selfStart}\COLON \TYP{IndexInt}, \VAR{source}\COLON T, \VAR{sourceStart}\COLON \TYP{IndexInt}, \VAR{length}\COLON \TYP{IndexInt})\COLON \TYP{Boolean} \)\\
{\tt~~}\pushtabs\=\+\(    \KWD{throws} \{\,\TYP{IndexOutOfBounds}\,\}\)\-\\\poptabs
\(  \VAR{signedGE}(\VAR{selfStart}\COLON \TYP{IndexInt}, \VAR{source}\COLON T, \VAR{sourceStart}\COLON \TYP{IndexInt}, \VAR{length}\COLON \TYP{IndexInt})\COLON \TYP{Boolean} \)\\
{\tt~~}\pushtabs\=\+\(    \KWD{throws} \{\,\TYP{IndexOutOfBounds}\,\}\)\-\\\poptabs
\(  \VAR{signedGT}(\VAR{selfStart}\COLON \TYP{IndexInt}, \VAR{source}\COLON T, \VAR{sourceStart}\COLON \TYP{IndexInt}, \VAR{length}\COLON \TYP{IndexInt})\COLON \TYP{Boolean} \)\\
{\tt~~}\pushtabs\=\+\(    \KWD{throws} \{\,\TYP{IndexOutOfBounds}\,\}\)\-\\\poptabs
\(  \VAR{unsignedLT}(\VAR{selfStart}\COLON \TYP{IndexInt}, \VAR{source}\COLON T, \VAR{sourceStart}\COLON \TYP{IndexInt}, \VAR{length}\COLON \TYP{IndexInt})\COLON \TYP{Boolean} \)\\
{\tt~~}\pushtabs\=\+\(    \KWD{throws} \{\,\TYP{IndexOutOfBounds}\,\}\)\-\\\poptabs
\(  \VAR{unsignedLE}(\VAR{selfStart}\COLON \TYP{IndexInt}, \VAR{source}\COLON T, \VAR{sourceStart}\COLON \TYP{IndexInt}, \VAR{length}\COLON \TYP{IndexInt})\COLON \TYP{Boolean} \)\\
{\tt~~}\pushtabs\=\+\(    \KWD{throws} \{\,\TYP{IndexOutOfBounds}\,\}\)\-\\\poptabs
\(  \VAR{unsignedGE}(\VAR{selfStart}\COLON \TYP{IndexInt}, \VAR{source}\COLON T, \VAR{sourceStart}\COLON \TYP{IndexInt}, \VAR{length}\COLON \TYP{IndexInt})\COLON \TYP{Boolean} \)\\
{\tt~~}\pushtabs\=\+\(    \KWD{throws} \{\,\TYP{IndexOutOfBounds}\,\}\)\-\\\poptabs
\(  \VAR{unsignedGT}(\VAR{selfStart}\COLON \TYP{IndexInt}, \VAR{source}\COLON T, \VAR{sourceStart}\COLON \TYP{IndexInt}, \VAR{length}\COLON \TYP{IndexInt})\COLON \TYP{Boolean} \)\\
{\tt~~}\pushtabs\=\+\(    \KWD{throws} \{\,\TYP{IndexOutOfBounds}\,\}\)\-\\\poptabs
\(  \VAR{signedShift}(\VAR{selfStart}\COLON \TYP{IndexInt}, \VAR{length}\COLON \TYP{IndexInt}, j\COLON \TYP{IndexInt})\COLON ()\)\\
{\tt~~}\pushtabs\=\+\(    \KWD{throws} \{\,\TYP{IndexOutOfBounds}\,\}\)\-\\\poptabs
\(  \VAR{signedShift}(\VAR{selfStart}\COLON \TYP{IndexInt}, \VAR{length}\COLON \TYP{IndexInt}, j\COLON \TYP{IndexInt}, \VAR{overflowAction}\COLON ()\rightarrow())\COLON ()\)\\
{\tt~~}\pushtabs\=\+\(    \KWD{throws} \{\,\TYP{IndexOutOfBounds}\,\}\)\-\\\poptabs
\(  \VAR{saturatingSignedShift}(\VAR{selfStart}\COLON \TYP{IndexInt}, \VAR{length}\COLON \TYP{IndexInt}, j\COLON \TYP{IndexInt})\COLON ()\)\\
{\tt~~}\pushtabs\=\+\(    \KWD{throws} \{\,\TYP{IndexOutOfBounds}\,\}\)\-\\\poptabs
\(  \VAR{unsignedShift}(\VAR{selfStart}\COLON \TYP{IndexInt}, \VAR{length}\COLON \TYP{IndexInt}, j\COLON \TYP{IndexInt})\COLON ()\)\\
{\tt~~}\pushtabs\=\+\(    \KWD{throws} \{\,\TYP{IndexOutOfBounds}\,\}\)\-\\\poptabs
\(  \VAR{unsignedShift}(\VAR{selfStart}\COLON \TYP{IndexInt}, \VAR{length}\COLON \TYP{IndexInt}, j\COLON \TYP{IndexInt}, \VAR{overflowAction}\COLON ()\rightarrow())\COLON ()\)\\
{\tt~~}\pushtabs\=\+\(    \KWD{throws} \{\,\TYP{IndexOutOfBounds}\,\}\)\-\\\poptabs
\(  \VAR{saturatingUnsignedShift}(\VAR{selfStart}\COLON \TYP{IndexInt}, \VAR{length}\COLON \TYP{IndexInt}, j\COLON \TYP{IndexInt})\COLON ()\)\\
{\tt~~}\pushtabs\=\+\(    \KWD{throws} \{\,\TYP{IndexOutOfBounds}\,\}\)\-\\\poptabs
\(  \VAR{bitRotate}(\VAR{selfStart}\COLON \TYP{IndexInt}, \VAR{length}\COLON \TYP{IndexInt}, j\COLON \TYP{IndexInt})\COLON ()\)\\
{\tt~~}\pushtabs\=\+\(    \KWD{throws} \{\,\TYP{IndexOutOfBounds}\,\}\)\-\\\poptabs
\(  \VAR{countOneBits}(\VAR{selfStart}\COLON \TYP{IndexInt}, \VAR{length}\COLON \TYP{IndexInt})\COLON \TYP{IndexInt}\)\\
{\tt~~}\pushtabs\=\+\(    \KWD{throws} \{\,\TYP{IndexOutOfBounds}\,\}\)\-\\\poptabs
\(  \VAR{countLeadingZeroBits}(\VAR{selfStart}\COLON \TYP{IndexInt}, \VAR{length}\COLON \TYP{IndexInt})\COLON \TYP{IndexInt}\)\\
{\tt~~}\pushtabs\=\+\(    \KWD{throws} \{\,\TYP{IndexOutOfBounds}\,\}\)\-\\\poptabs
\(  \VAR{countTrailingZeroBits}(\VAR{selfStart}\COLON \TYP{IndexInt}, \VAR{length}\COLON \TYP{IndexInt})\COLON \TYP{IndexInt}\)\\
{\tt~~}\pushtabs\=\+\(    \KWD{throws} \{\,\TYP{IndexOutOfBounds}\,\}\)\-\\\poptabs
\(  \VAR{leftmostOneBit}(\VAR{selfStart}\COLON \TYP{IndexInt}, \VAR{length}\COLON \TYP{IndexInt})\COLON ()\)\\
{\tt~~}\pushtabs\=\+\(    \KWD{throws} \{\,\TYP{IndexOutOfBounds}\,\}\)\-\\\poptabs
\(  \VAR{rightmostOneBit}(\VAR{selfStart}\COLON \TYP{IndexInt}, \VAR{length}\COLON \TYP{IndexInt})\COLON ()\)\\
{\tt~~}\pushtabs\=\+\(    \KWD{throws} \{\,\TYP{IndexOutOfBounds}\,\}\)\-\\\poptabs
\(  \VAR{bitReverse}(\VAR{selfStart}\COLON \TYP{IndexInt}, \VAR{length}\COLON \TYP{IndexInt})\COLON ()\)\\
{\tt~~}\pushtabs\=\+\(    \KWD{throws} \{\,\TYP{IndexOutOfBounds}\,\}\)\-\\\poptabs
\(  \VAR{gatherBits}(\VAR{selfStart}\COLON \TYP{IndexInt}, \VAR{mask}\COLON T, \VAR{maskStart}\COLON \TYP{IndexInt}, \VAR{length}\COLON \TYP{IndexInt})\COLON ()\)\\
{\tt~~}\pushtabs\=\+\(    \KWD{throws} \{\,\TYP{IndexOutOfBounds}\,\}\)\-\\\poptabs
\(  \VAR{spreadBits}(\VAR{selfStart}\COLON \TYP{IndexInt}, \VAR{mask}\COLON T, \VAR{maskStart}\COLON \TYP{IndexInt}, \VAR{length}\COLON \TYP{IndexInt})\COLON ()\)\\
{\tt~~}\pushtabs\=\+\(    \KWD{throws} \{\,\TYP{IndexOutOfBounds}\,\}\)\-\\\poptabs
\(  \VAR{clearAllBits}(\VAR{selfStart}\COLON \TYP{IndexInt}, \VAR{length}\COLON \TYP{IndexInt})\COLON ()\)\\
{\tt~~}\pushtabs\=\+\(    \KWD{throws} \{\,\TYP{IndexOutOfBounds}\,\}\)\-\\\poptabs
\(  \VAR{setAllBits}(\VAR{selfStart}\COLON \TYP{IndexInt}, \VAR{length}\COLON \TYP{IndexInt})\COLON ()\)\\
{\tt~~}\pushtabs\=\+\(    \KWD{throws} \{\,\TYP{IndexOutOfBounds}\,\}\)\-\\\poptabs
\(  \VAR{signedIndex}()\COLON \TYP{IndexInt}\)\\
{\tt~~}\pushtabs\=\+\(    \KWD{throws} \{\,\TYP{IntegerOverflow}\,\}\)\-\\\poptabs
\(  \VAR{signedIndex}(\VAR{selfStart}\COLON \TYP{IndexInt}, \VAR{length}\COLON \TYP{IndexInt})\COLON \TYP{IndexInt}\)\\
{\tt~~}\pushtabs\=\+\(    \KWD{throws} \{\,\TYP{IndexOutOfBounds}, \TYP{IntegerOverflow}\,\}\)\-\\\poptabs
\(  \VAR{unsignedIndex}()\COLON \TYP{IndexInt}\)\\
{\tt~~}\pushtabs\=\+\(    \KWD{throws} \{\,\TYP{IntegerOverflow}\,\}\)\-\\\poptabs
\(  \VAR{unsignedIndex}(\VAR{selfStart}\COLON \TYP{IndexInt}, \VAR{length}\COLON \TYP{IndexInt})\COLON \TYP{IndexInt}\)\\
{\tt~~}\pushtabs\=\+\(    \KWD{throws} \{\,\TYP{IndexOutOfBounds}, \TYP{IntegerOverflow}\,\}\)\-\-\\\poptabs\poptabs
\(\KWD{end}\)
\end{Fortress}


%%   copy(selfStart: IndexInt, source: T, sourceStart: IndexInt, length: IndexInt): ()
%%     throws { IndexOutOfBounds }
\Method{\EXP{\VAR{copy}(\VAR{selfStart}\COLON \TYP{IndexInt}, \VAR{source}\COLON T, \VAR{sourceStart}\COLON \TYP{IndexInt}, \VAR{length}\COLON \TYP{IndexInt})\COLON ()}\\
{\tt~~}\EXP{\KWD{throws} \{\,\TYP{IndexOutOfBounds}\,\}}}

[Description to be supplied.]


%%   wrappingAdd(selfStart: IndexInt, source: T, sourceStart: IndexInt, length: IndexInt): ()
%%     throws { IndexOutOfBounds }
%%   add(selfStart: IndexInt, source: T, sourceStart: IndexInt,
%%       length: IndexInt, carryIn: Bit=0): Bit
%%     throws { IndexOutOfBounds }
%%   signedAdd(selfStart: IndexInt, source: T, sourceStart: IndexInt,
%%             length: IndexInt, overflowAction: ()->()): ()
%%     throws { IndexOutOfBounds }
%%   unsignedAdd(selfStart: IndexInt, source: T, sourceStart: IndexInt,
%%               length: IndexInt, overflowAction: ()->()): ()
%%     throws { IndexOutOfBounds }
%%   saturatingSignedAdd(selfStart: IndexInt, source: T, sourceStart: IndexInt, length: IndexInt): ()
%%     throws { IndexOutOfBounds }
%%   saturatingUnsignedAdd(selfStart: IndexInt, source: T, sourceStart: IndexInt, length: IndexInt): ()
%%     throws { IndexOutOfBounds }
\Method{\EXP{\VAR{wrappingAdd}(\VAR{selfStart}\COLON \TYP{IndexInt}, \VAR{source}\COLON T, \VAR{sourceStart}\COLON \TYP{IndexInt}, \VAR{length}\COLON \TYP{IndexInt})\COLON ()}\\
{\tt~~}\EXP{\KWD{throws} \{\,\TYP{IndexOutOfBounds}\,\}}}
\Method*{\EXP{\VAR{add}(\VAR{selfStart}\COLON \TYP{IndexInt}, \VAR{source}\COLON T, \VAR{sourceStart}\COLON \TYP{IndexInt},}\\
{\tt~~~~}\EXP{\VAR{length}\COLON \TYP{IndexInt}, \VAR{carryIn}\COLON \TYP{Bit}=0)\COLON \TYP{Bit}}\\
{\tt~~}\EXP{\KWD{throws} \{\,\TYP{IndexOutOfBounds}\,\}}}
\Method*{\EXP{\VAR{signedAdd}(\VAR{selfStart}\COLON \TYP{IndexInt}, \VAR{source}\COLON T, \VAR{sourceStart}\COLON \TYP{IndexInt},}\\
{\tt~~~~~~~~~~}\EXP{\VAR{length}\COLON \TYP{IndexInt}, \VAR{overflowAction}\COLON ()\rightarrow())\COLON ()}\\
{\tt~~}\EXP{\KWD{throws} \{\,\TYP{IndexOutOfBounds}\,\}}}
\Method*{\EXP{\VAR{unsignedAdd}(\VAR{selfStart}\COLON \TYP{IndexInt}, \VAR{source}\COLON T, \VAR{sourceStart}\COLON \TYP{IndexInt},}\\
{\tt~~~~~~~~~~~~}\EXP{\VAR{length}\COLON \TYP{IndexInt}, \VAR{overflowAction}\COLON ()\rightarrow())\COLON ()}\\
{\tt~~}\EXP{\KWD{throws} \{\,\TYP{IndexOutOfBounds}\,\}}}
\Method*{\EXP{\VAR{saturatingSignedAdd}(\VAR{selfStart}\COLON \TYP{IndexInt}, \VAR{source}\COLON T, \VAR{sourceStart}\COLON \TYP{IndexInt}, \VAR{length}\COLON \TYP{IndexInt})\COLON ()}\\
{\tt~~}\EXP{\KWD{throws} \{\,\TYP{IndexOutOfBounds}\,\}}}
\Method*{\EXP{\VAR{saturatingUnsignedAdd}(\VAR{selfStart}\COLON \TYP{IndexInt}, \VAR{source}\COLON T, \VAR{sourceStart}\COLON \TYP{IndexInt}, \VAR{length}\COLON \TYP{IndexInt})\COLON ()}\\
{\tt~~}\EXP{\KWD{throws} \{\,\TYP{IndexOutOfBounds}\,\}}}

[Description to be supplied.]


%%   wrappingSubtract(selfStart: IndexInt, source: T, sourceStart: IndexInt, length: IndexInt): ()
%%     throws { IndexOutOfBounds }
%%   subtract(selfStart: IndexInt, source: T, sourceStart: IndexInt,
%%            length: IndexInt, carryIn: Bit=1): Bit
%%     throws { IndexOutOfBounds }
%%   signedSubtract(selfStart: IndexInt, source: T, sourceStart: IndexInt,
%%                  length: IndexInt, overflowAction: ()->()): ()
%%     throws { IndexOutOfBounds }
%%   unsignedSubtract(selfStart: IndexInt, source: T, sourceStart: IndexInt,
%%                    length: IndexInt, overflowAction: ()->()): ()
%%     throws { IndexOutOfBounds }
%%   saturatingSignedSubtract(selfStart: IndexInt, source: T, sourceStart: IndexInt,
%%                            length: IndexInt): ()
%%     throws { IndexOutOfBounds }
%%   saturatingUnsignedSubtract(selfStart: IndexInt, source: T, sourceStart: IndexInt,
%%                              length: IndexInt): ()
%%     throws { IndexOutOfBounds }
\Method{\EXP{\VAR{wrappingSubtract}(\VAR{selfStart}\COLON \TYP{IndexInt}, \VAR{source}\COLON T, \VAR{sourceStart}\COLON \TYP{IndexInt}, \VAR{length}\COLON \TYP{IndexInt})\COLON ()}\\
{\tt~~}\EXP{\KWD{throws} \{\,\TYP{IndexOutOfBounds}\,\}}}
\Method*{\EXP{\VAR{subtract}(\VAR{selfStart}\COLON \TYP{IndexInt}, \VAR{source}\COLON T, \VAR{sourceStart}\COLON \TYP{IndexInt},}\\
{\tt~~~~~~~~~}\EXP{\VAR{length}\COLON \TYP{IndexInt}, \VAR{carryIn}\COLON \TYP{Bit}=1)\COLON \TYP{Bit}}\\
{\tt~~}\EXP{\KWD{throws} \{\,\TYP{IndexOutOfBounds}\,\}}}
\Method*{\EXP{\VAR{signedSubtract}(\VAR{selfStart}\COLON \TYP{IndexInt}, \VAR{source}\COLON T, \VAR{sourceStart}\COLON \TYP{IndexInt},}\\
{\tt~~~~~~~~~~~~~~~}\EXP{\VAR{length}\COLON \TYP{IndexInt}, \VAR{overflowAction}\COLON ()\rightarrow())\COLON ()}\\
{\tt~~}\EXP{\KWD{throws} \{\,\TYP{IndexOutOfBounds}\,\}}}
\Method*{\EXP{\VAR{unsignedSubtract}(\VAR{selfStart}\COLON \TYP{IndexInt}, \VAR{source}\COLON T, \VAR{sourceStart}\COLON \TYP{IndexInt},}\\
{\tt~~~~~~~~~~~~~~~~~}\EXP{\VAR{length}\COLON \TYP{IndexInt}, \VAR{overflowAction}\COLON ()\rightarrow())\COLON ()}\\
{\tt~~}\EXP{\KWD{throws} \{\,\TYP{IndexOutOfBounds}\,\}}}
\Method*{\EXP{\VAR{saturatingSignedSubtract}(\VAR{selfStart}\COLON \TYP{IndexInt}, \VAR{source}\COLON T, \VAR{sourceStart}\COLON \TYP{IndexInt},}\\
{\tt~~~~~~~~~~~~~~~~~~~~~~~~~}\EXP{\VAR{length}\COLON \TYP{IndexInt})\COLON ()}\\
{\tt~~}\EXP{\KWD{throws} \{\,\TYP{IndexOutOfBounds}\,\}}}
\Method*{\EXP{\VAR{saturatingUnsignedSubtract}(\VAR{selfStart}\COLON \TYP{IndexInt}, \VAR{source}\COLON T, \VAR{sourceStart}\COLON \TYP{IndexInt},}\\
{\tt~~~~~~~~~~~~~~~~~~~~~~~~~~~}\EXP{\VAR{length}\COLON \TYP{IndexInt})\COLON ()}\\
{\tt~~}\EXP{\KWD{throws} \{\,\TYP{IndexOutOfBounds}\,\}}}

[Description to be supplied.]


%%   wrappingNegate(selfStart: IndexInt, length: IndexInt): ()
%%     throws { IndexOutOfBounds }
%%   negate(selfStart: IndexInt, length: IndexInt, carryIn: Bit=1): Bit
%%     throws { IndexOutOfBounds }
%%   signedNegate(selfStart: IndexInt, length: IndexInt, overflowAction: ()->()): ()
%%     throws { IndexOutOfBounds }
%%   unsignedNegate(selfStart: IndexInt, length: IndexInt, overflowAction: ()->()): ()
%%     throws { IndexOutOfBounds }
%%   saturatingSignedNegate(selfStart: IndexInt, length: IndexInt): ()
%%     throws { IndexOutOfBounds }
\Method{\EXP{\VAR{wrappingNegate}(\VAR{selfStart}\COLON \TYP{IndexInt}, \VAR{length}\COLON \TYP{IndexInt})\COLON ()}\\
{\tt~~}\EXP{\KWD{throws} \{\,\TYP{IndexOutOfBounds}\,\}}}
\Method*{\EXP{\VAR{negate}(\VAR{selfStart}\COLON \TYP{IndexInt}, \VAR{length}\COLON \TYP{IndexInt}, \VAR{carryIn}\COLON \TYP{Bit}=1)\COLON \TYP{Bit}}\\
{\tt~~}\EXP{\KWD{throws} \{\,\TYP{IndexOutOfBounds}\,\}}}
\Method*{\EXP{\VAR{signedNegate}(\VAR{selfStart}\COLON \TYP{IndexInt}, \VAR{length}\COLON \TYP{IndexInt}, \VAR{overflowAction}\COLON ()\rightarrow())\COLON ()}\\
{\tt~~}\EXP{\KWD{throws} \{\,\TYP{IndexOutOfBounds}\,\}}}
\Method*{\EXP{\VAR{unsignedNegate}(\VAR{selfStart}\COLON \TYP{IndexInt}, \VAR{length}\COLON \TYP{IndexInt}, \VAR{overflowAction}\COLON ()\rightarrow())\COLON ()}\\
{\tt~~}\EXP{\KWD{throws} \{\,\TYP{IndexOutOfBounds}\,\}}}
\Method*{\EXP{\VAR{saturatingSignedNegate}(\VAR{selfStart}\COLON \TYP{IndexInt}, \VAR{length}\COLON \TYP{IndexInt})\COLON ()}\\
{\tt~~}\EXP{\KWD{throws} \{\,\TYP{IndexOutOfBounds}\,\}}}

[Description to be supplied.]


%%   bitNot(selfStart: IndexInt, length: IndexInt): ()
%%     throws { IndexOutOfBounds }
\Method{\EXP{\VAR{bitNot}(\VAR{selfStart}\COLON \TYP{IndexInt}, \VAR{length}\COLON \TYP{IndexInt})\COLON ()}\\
{\tt~~}\EXP{\KWD{throws} \{\,\TYP{IndexOutOfBounds}\,\}}}

[Description to be supplied.]


%%   bitAnd(selfStart: IndexInt, source: T, sourceStart: IndexInt, length: IndexInt): ()
%%     throws { IndexOutOfBounds }
%%   bitOr(selfStart: IndexInt, source: T, sourceStart: IndexInt, length: IndexInt): ()
%%     throws { IndexOutOfBounds }
%%   bitXor(selfStart: IndexInt, source: T, sourceStart: IndexInt, length: IndexInt): ()
%%     throws { IndexOutOfBounds }
%%   bitXorNot(selfStart: IndexInt, source: T, sourceStart: IndexInt, length: IndexInt): ()
%%     throws { IndexOutOfBounds }
%%   bitNand(selfStart: IndexInt, source: T, sourceStart: IndexInt, length: IndexInt): ()
%%     throws { IndexOutOfBounds }
%%   bitNor(selfStart: IndexInt, source: T, sourceStart: IndexInt, length: IndexInt): ()
%%     throws { IndexOutOfBounds }
%%   bitAndNot(selfStart: IndexInt, source: T, sourceStart: IndexInt, length: IndexInt): ()
%%     throws { IndexOutOfBounds }
%%   bitOrNot(selfStart: IndexInt, source: T, sourceStart: IndexInt, length: IndexInt): ()
%%     throws { IndexOutOfBounds }
\Method{\EXP{\VAR{bitAnd}(\VAR{selfStart}\COLON \TYP{IndexInt}, \VAR{source}\COLON T, \VAR{sourceStart}\COLON \TYP{IndexInt}, \VAR{length}\COLON \TYP{IndexInt})\COLON ()}\\
{\tt~~}\EXP{\KWD{throws} \{\,\TYP{IndexOutOfBounds}\,\}}}
\Method*{\EXP{\VAR{bitOr}(\VAR{selfStart}\COLON \TYP{IndexInt}, \VAR{source}\COLON T, \VAR{sourceStart}\COLON \TYP{IndexInt}, \VAR{length}\COLON \TYP{IndexInt})\COLON ()}\\
{\tt~~}\EXP{\KWD{throws} \{\,\TYP{IndexOutOfBounds}\,\}}}
\Method*{\EXP{\VAR{bitXor}(\VAR{selfStart}\COLON \TYP{IndexInt}, \VAR{source}\COLON T, \VAR{sourceStart}\COLON \TYP{IndexInt}, \VAR{length}\COLON \TYP{IndexInt})\COLON ()}\\
{\tt~~}\EXP{\KWD{throws} \{\,\TYP{IndexOutOfBounds}\,\}}}
\Method*{\EXP{\VAR{bitXorNot}(\VAR{selfStart}\COLON \TYP{IndexInt}, \VAR{source}\COLON T, \VAR{sourceStart}\COLON \TYP{IndexInt}, \VAR{length}\COLON \TYP{IndexInt})\COLON ()}\\
{\tt~~}\EXP{\KWD{throws} \{\,\TYP{IndexOutOfBounds}\,\}}}
\Method*{\EXP{\VAR{bitNand}(\VAR{selfStart}\COLON \TYP{IndexInt}, \VAR{source}\COLON T, \VAR{sourceStart}\COLON \TYP{IndexInt}, \VAR{length}\COLON \TYP{IndexInt})\COLON ()}\\
{\tt~~}\EXP{\KWD{throws} \{\,\TYP{IndexOutOfBounds}\,\}}}
\Method*{\EXP{\VAR{bitNor}(\VAR{selfStart}\COLON \TYP{IndexInt}, \VAR{source}\COLON T, \VAR{sourceStart}\COLON \TYP{IndexInt}, \VAR{length}\COLON \TYP{IndexInt})\COLON ()}\\
{\tt~~}\EXP{\KWD{throws} \{\,\TYP{IndexOutOfBounds}\,\}}}
\Method*{\EXP{\VAR{bitAndNot}(\VAR{selfStart}\COLON \TYP{IndexInt}, \VAR{source}\COLON T, \VAR{sourceStart}\COLON \TYP{IndexInt}, \VAR{length}\COLON \TYP{IndexInt})\COLON ()}\\
{\tt~~}\EXP{\KWD{throws} \{\,\TYP{IndexOutOfBounds}\,\}}}
\Method*{\EXP{\VAR{bitOrNot}(\VAR{selfStart}\COLON \TYP{IndexInt}, \VAR{source}\COLON T, \VAR{sourceStart}\COLON \TYP{IndexInt}, \VAR{length}\COLON \TYP{IndexInt})\COLON ()}\\
{\tt~~}\EXP{\KWD{throws} \{\,\TYP{IndexOutOfBounds}\,\}}}

[Description to be supplied.]


%%   signedMax(selfStart: IndexInt, source: T, sourceStart: IndexInt, length: IndexInt): ()
%%     throws { IndexOutOfBounds }
%%   signedMin(selfStart: IndexInt, source: T, sourceStart: IndexInt, length: IndexInt): ()
%%     throws { IndexOutOfBounds }
\Method{\EXP{\VAR{signedMax}(\VAR{selfStart}\COLON \TYP{IndexInt}, \VAR{source}\COLON T, \VAR{sourceStart}\COLON \TYP{IndexInt}, \VAR{length}\COLON \TYP{IndexInt})\COLON ()}\\
{\tt~~}\EXP{\KWD{throws} \{\,\TYP{IndexOutOfBounds}\,\}}}
\Method*{\EXP{\VAR{signedMin}(\VAR{selfStart}\COLON \TYP{IndexInt}, \VAR{source}\COLON T, \VAR{sourceStart}\COLON \TYP{IndexInt}, \VAR{length}\COLON \TYP{IndexInt})\COLON ()}\\
{\tt~~}\EXP{\KWD{throws} \{\,\TYP{IndexOutOfBounds}\,\}}}

[Description to be supplied.]


%%   unsignedMax(selfStart: IndexInt, source: T, sourceStart: IndexInt, length: IndexInt): ()
%%     throws { IndexOutOfBounds }
%%   unsignedMin(selfStart: IndexInt, source: T, sourceStart: IndexInt, length: IndexInt): ()
%%     throws { IndexOutOfBounds }
\Method{\EXP{\VAR{unsignedMax}(\VAR{selfStart}\COLON \TYP{IndexInt}, \VAR{source}\COLON T, \VAR{sourceStart}\COLON \TYP{IndexInt}, \VAR{length}\COLON \TYP{IndexInt})\COLON ()}\\
{\tt~~}\EXP{\KWD{throws} \{\,\TYP{IndexOutOfBounds}\,\}}}
\Method*{\EXP{\VAR{unsignedMin}(\VAR{selfStart}\COLON \TYP{IndexInt}, \VAR{source}\COLON T, \VAR{sourceStart}\COLON \TYP{IndexInt}, \VAR{length}\COLON \TYP{IndexInt})\COLON ()}\\
{\tt~~}\EXP{\KWD{throws} \{\,\TYP{IndexOutOfBounds}\,\}}}

[Description to be supplied.]


%%   equal(selfStart: IndexInt, source: T, sourceStart: IndexInt, length: IndexInt): Boolean
%%     throws { IndexOutOfBounds }
%%   unequal(selfStart: IndexInt, source: T, sourceStart: IndexInt, length: IndexInt): Boolean
%%     throws { IndexOutOfBounds }
\Method{\EXP{\VAR{equal}(\VAR{selfStart}\COLON \TYP{IndexInt}, \VAR{source}\COLON T, \VAR{sourceStart}\COLON \TYP{IndexInt}, \VAR{length}\COLON \TYP{IndexInt})\COLON \TYP{Boolean} }\\
{\tt~~}\EXP{\KWD{throws} \{\,\TYP{IndexOutOfBounds}\,\}}}
\Method*{\EXP{\VAR{unequal}(\VAR{selfStart}\COLON \TYP{IndexInt}, \VAR{source}\COLON T, \VAR{sourceStart}\COLON \TYP{IndexInt}, \VAR{length}\COLON \TYP{IndexInt})\COLON \TYP{Boolean} }\\
{\tt~~}\EXP{\KWD{throws} \{\,\TYP{IndexOutOfBounds}\,\}}}

[Description to be supplied.]


%%   signedLT(selfStart: IndexInt, source: T, sourceStart: IndexInt, length: IndexInt): Boolean
%%     throws { IndexOutOfBounds }
%%   signedLE(selfStart: IndexInt, source: T, sourceStart: IndexInt, length: IndexInt): Boolean
%%     throws { IndexOutOfBounds }
%%   signedGE(selfStart: IndexInt, source: T, sourceStart: IndexInt, length: IndexInt): Boolean
%%     throws { IndexOutOfBounds }
%%   signedGT(selfStart: IndexInt, source: T, sourceStart: IndexInt, length: IndexInt): Boolean
%%     throws { IndexOutOfBounds }
\Method{\EXP{\VAR{signedLT}(\VAR{selfStart}\COLON \TYP{IndexInt}, \VAR{source}\COLON T, \VAR{sourceStart}\COLON \TYP{IndexInt}, \VAR{length}\COLON \TYP{IndexInt})\COLON \TYP{Boolean} }\\
{\tt~~}\EXP{\KWD{throws} \{\,\TYP{IndexOutOfBounds}\,\}}}
\Method*{\EXP{\VAR{signedLE}(\VAR{selfStart}\COLON \TYP{IndexInt}, \VAR{source}\COLON T, \VAR{sourceStart}\COLON \TYP{IndexInt}, \VAR{length}\COLON \TYP{IndexInt})\COLON \TYP{Boolean} }\\
{\tt~~}\EXP{\KWD{throws} \{\,\TYP{IndexOutOfBounds}\,\}}}
\Method*{\EXP{\VAR{signedGE}(\VAR{selfStart}\COLON \TYP{IndexInt}, \VAR{source}\COLON T, \VAR{sourceStart}\COLON \TYP{IndexInt}, \VAR{length}\COLON \TYP{IndexInt})\COLON \TYP{Boolean} }\\
{\tt~~}\EXP{\KWD{throws} \{\,\TYP{IndexOutOfBounds}\,\}}}
\Method*{\EXP{\VAR{signedGT}(\VAR{selfStart}\COLON \TYP{IndexInt}, \VAR{source}\COLON T, \VAR{sourceStart}\COLON \TYP{IndexInt}, \VAR{length}\COLON \TYP{IndexInt})\COLON \TYP{Boolean} }\\
{\tt~~}\EXP{\KWD{throws} \{\,\TYP{IndexOutOfBounds}\,\}}}

[Description to be supplied.]


%%   unsignedLT(selfStart: IndexInt, source: T, sourceStart: IndexInt, length: IndexInt): Boolean
%%     throws { IndexOutOfBounds }
%%   unsignedLE(selfStart: IndexInt, source: T, sourceStart: IndexInt, length: IndexInt): Boolean
%%     throws { IndexOutOfBounds }
%%   unsignedGE(selfStart: IndexInt, source: T, sourceStart: IndexInt, length: IndexInt): Boolean
%%     throws { IndexOutOfBounds }
%%   unsignedGT(selfStart: IndexInt, source: T, sourceStart: IndexInt, length: IndexInt): Boolean
%%     throws { IndexOutOfBounds }
\Method{\EXP{\VAR{unsignedLT}(\VAR{selfStart}\COLON \TYP{IndexInt}, \VAR{source}\COLON T, \VAR{sourceStart}\COLON \TYP{IndexInt}, \VAR{length}\COLON \TYP{IndexInt})\COLON \TYP{Boolean} }\\
{\tt~~}\EXP{\KWD{throws} \{\,\TYP{IndexOutOfBounds}\,\}}}
\Method*{\EXP{\VAR{unsignedLE}(\VAR{selfStart}\COLON \TYP{IndexInt}, \VAR{source}\COLON T, \VAR{sourceStart}\COLON \TYP{IndexInt}, \VAR{length}\COLON \TYP{IndexInt})\COLON \TYP{Boolean} }\\
{\tt~~}\EXP{\KWD{throws} \{\,\TYP{IndexOutOfBounds}\,\}}}
\Method*{\EXP{\VAR{unsignedGE}(\VAR{selfStart}\COLON \TYP{IndexInt}, \VAR{source}\COLON T, \VAR{sourceStart}\COLON \TYP{IndexInt}, \VAR{length}\COLON \TYP{IndexInt})\COLON \TYP{Boolean} }\\
{\tt~~}\EXP{\KWD{throws} \{\,\TYP{IndexOutOfBounds}\,\}}}
\Method*{\EXP{\VAR{unsignedGT}(\VAR{selfStart}\COLON \TYP{IndexInt}, \VAR{source}\COLON T, \VAR{sourceStart}\COLON \TYP{IndexInt}, \VAR{length}\COLON \TYP{IndexInt})\COLON \TYP{Boolean} }\\
{\tt~~}\EXP{\KWD{throws} \{\,\TYP{IndexOutOfBounds}\,\}}}

[Description to be supplied.]


%%   signedShift(selfStart: IndexInt, length: IndexInt, j: IndexInt): ()
%%     throws { IndexOutOfBounds }
%%   signedShift(selfStart: IndexInt, length: IndexInt, j: IndexInt, overflowAction: ()->()): ()
%%     throws { IndexOutOfBounds }
%%   saturatingSignedShift(selfStart: IndexInt, length: IndexInt, j: IndexInt): ()
%%     throws { IndexOutOfBounds }
\Method{\EXP{\VAR{signedShift}(\VAR{selfStart}\COLON \TYP{IndexInt}, \VAR{length}\COLON \TYP{IndexInt}, j\COLON \TYP{IndexInt})\COLON ()}\\
{\tt~~}\EXP{\KWD{throws} \{\,\TYP{IndexOutOfBounds}\,\}}}
\Method*{\EXP{\VAR{signedShift}(\VAR{selfStart}\COLON \TYP{IndexInt}, \VAR{length}\COLON \TYP{IndexInt}, j\COLON \TYP{IndexInt}, \VAR{overflowAction}\COLON ()\rightarrow())\COLON ()}\\
{\tt~~}\EXP{\KWD{throws} \{\,\TYP{IndexOutOfBounds}\,\}}}
\Method*{\EXP{\VAR{saturatingSignedShift}(\VAR{selfStart}\COLON \TYP{IndexInt}, \VAR{length}\COLON \TYP{IndexInt}, j\COLON \TYP{IndexInt})\COLON ()}\\
{\tt~~}\EXP{\KWD{throws} \{\,\TYP{IndexOutOfBounds}\,\}}}

[Description to be supplied.]


%%   unsignedShift(selfStart: IndexInt, length: IndexInt, j: IndexInt): ()
%%     throws { IndexOutOfBounds }
%%   unsignedShift(selfStart: IndexInt, length: IndexInt, j: IndexInt, overflowAction: ()->()): ()
%%     throws { IndexOutOfBounds }
%%   saturatingUnsignedShift(selfStart: IndexInt, length: IndexInt, j: IndexInt): ()
%%     throws { IndexOutOfBounds }
\Method{\EXP{\VAR{unsignedShift}(\VAR{selfStart}\COLON \TYP{IndexInt}, \VAR{length}\COLON \TYP{IndexInt}, j\COLON \TYP{IndexInt})\COLON ()}\\
{\tt~~}\EXP{\KWD{throws} \{\,\TYP{IndexOutOfBounds}\,\}}}
\Method*{\EXP{\VAR{unsignedShift}(\VAR{selfStart}\COLON \TYP{IndexInt}, \VAR{length}\COLON \TYP{IndexInt}, j\COLON \TYP{IndexInt}, \VAR{overflowAction}\COLON ()\rightarrow())\COLON ()}\\
{\tt~~}\EXP{\KWD{throws} \{\,\TYP{IndexOutOfBounds}\,\}}}
\Method*{\EXP{\VAR{saturatingUnsignedShift}(\VAR{selfStart}\COLON \TYP{IndexInt}, \VAR{length}\COLON \TYP{IndexInt}, j\COLON \TYP{IndexInt})\COLON ()}\\
{\tt~~}\EXP{\KWD{throws} \{\,\TYP{IndexOutOfBounds}\,\}}}

[Description to be supplied.]


%%   bitRotate(selfStart: IndexInt, length: IndexInt, j: IndexInt): ()
%%     throws { IndexOutOfBounds }
\Method{\EXP{\VAR{bitRotate}(\VAR{selfStart}\COLON \TYP{IndexInt}, \VAR{length}\COLON \TYP{IndexInt}, j\COLON \TYP{IndexInt})\COLON ()}\\
{\tt~~}\EXP{\KWD{throws} \{\,\TYP{IndexOutOfBounds}\,\}}}

[Description to be supplied.]


%%   countOneBits(selfStart: IndexInt, length: IndexInt): IndexInt
%%     throws { IndexOutOfBounds }
\Method{\EXP{\VAR{countOneBits}(\VAR{selfStart}\COLON \TYP{IndexInt}, \VAR{length}\COLON \TYP{IndexInt})\COLON \TYP{IndexInt}}\\
{\tt~~}\EXP{\KWD{throws} \{\,\TYP{IndexOutOfBounds}\,\}}}

[Description to be supplied.]


%%   countLeadingZeroBits(selfStart: IndexInt, length: IndexInt): IndexInt
%%     throws { IndexOutOfBounds }
%%   countTrailingZeroBits(selfStart: IndexInt, length: IndexInt): IndexInt
%%     throws { IndexOutOfBounds }
\Method{\EXP{\VAR{countLeadingZeroBits}(\VAR{selfStart}\COLON \TYP{IndexInt}, \VAR{length}\COLON \TYP{IndexInt})\COLON \TYP{IndexInt}}\\
{\tt~~}\EXP{\KWD{throws} \{\,\TYP{IndexOutOfBounds}\,\}}}
\Method*{\EXP{\VAR{countTrailingZeroBits}(\VAR{selfStart}\COLON \TYP{IndexInt}, \VAR{length}\COLON \TYP{IndexInt})\COLON \TYP{IndexInt}}\\
{\tt~~}\EXP{\KWD{throws} \{\,\TYP{IndexOutOfBounds}\,\}}}

[Description to be supplied.]


%%   leftmostOneBit(selfStart: IndexInt, length: IndexInt): ()
%%     throws { IndexOutOfBounds }
%%   rightmostOneBit(selfStart: IndexInt, length: IndexInt): ()
%%     throws { IndexOutOfBounds }
\Method{\EXP{\VAR{leftmostOneBit}(\VAR{selfStart}\COLON \TYP{IndexInt}, \VAR{length}\COLON \TYP{IndexInt})\COLON ()}\\
{\tt~~}\EXP{\KWD{throws} \{\,\TYP{IndexOutOfBounds}\,\}}}
\Method*{\EXP{\VAR{rightmostOneBit}(\VAR{selfStart}\COLON \TYP{IndexInt}, \VAR{length}\COLON \TYP{IndexInt})\COLON ()}\\
{\tt~~}\EXP{\KWD{throws} \{\,\TYP{IndexOutOfBounds}\,\}}}

[Description to be supplied.]


%%   bitReverse(selfStart: IndexInt, length: IndexInt): ()
%%     throws { IndexOutOfBounds }
\Method{\EXP{\VAR{bitReverse}(\VAR{selfStart}\COLON \TYP{IndexInt}, \VAR{length}\COLON \TYP{IndexInt})\COLON ()}\\
{\tt~~}\EXP{\KWD{throws} \{\,\TYP{IndexOutOfBounds}\,\}}}

[Description to be supplied.]


%%   gatherBits(selfStart: IndexInt, mask: T, maskStart: IndexInt, length: IndexInt): ()
%%     throws { IndexOutOfBounds }
%%   spreadBits(selfStart: IndexInt, mask: T, maskStart: IndexInt, length: IndexInt): ()
%%     throws { IndexOutOfBounds }
\Method{\EXP{\VAR{gatherBits}(\VAR{selfStart}\COLON \TYP{IndexInt}, \VAR{mask}\COLON T, \VAR{maskStart}\COLON \TYP{IndexInt}, \VAR{length}\COLON \TYP{IndexInt})\COLON ()}\\
{\tt~~}\EXP{\KWD{throws} \{\,\TYP{IndexOutOfBounds}\,\}}}
\Method*{\EXP{\VAR{spreadBits}(\VAR{selfStart}\COLON \TYP{IndexInt}, \VAR{mask}\COLON T, \VAR{maskStart}\COLON \TYP{IndexInt}, \VAR{length}\COLON \TYP{IndexInt})\COLON ()}\\
{\tt~~}\EXP{\KWD{throws} \{\,\TYP{IndexOutOfBounds}\,\}}}

[Description to be supplied.]


%%   clearAllBits(selfStart: IndexInt, length: IndexInt): ()
%%     throws { IndexOutOfBounds }
%%   setAllBits(selfStart: IndexInt, length: IndexInt): ()
%%     throws { IndexOutOfBounds }
\Method{\EXP{\VAR{clearAllBits}(\VAR{selfStart}\COLON \TYP{IndexInt}, \VAR{length}\COLON \TYP{IndexInt})\COLON ()}\\
{\tt~~}\EXP{\KWD{throws} \{\,\TYP{IndexOutOfBounds}\,\}}}
\Method*{\EXP{\VAR{setAllBits}(\VAR{selfStart}\COLON \TYP{IndexInt}, \VAR{length}\COLON \TYP{IndexInt})\COLON ()}\\
{\tt~~}\EXP{\KWD{throws} \{\,\TYP{IndexOutOfBounds}\,\}}}

[Description to be supplied.]


%%   signedIndex(): IndexInt
%%     throws { IntegerOverflow }
%%   signedIndex(selfStart: IndexInt, length: IndexInt): IndexInt
%%     throws { IndexOutOfBounds, IntegerOverflow }
%%   unsignedIndex(): IndexInt
%%     throws { IntegerOverflow }
%%   unsignedIndex(selfStart: IndexInt, length: IndexInt): IndexInt
%%     throws { IndexOutOfBounds, IntegerOverflow }
\Method{\EXP{\VAR{signedIndex}()\COLON \TYP{IndexInt}}\\
{\tt~~}\EXP{\KWD{throws} \{\,\TYP{IntegerOverflow}\,\}}}
\Method*{\EXP{\VAR{signedIndex}(\VAR{selfStart}\COLON \TYP{IndexInt}, \VAR{length}\COLON \TYP{IndexInt})\COLON \TYP{IndexInt}}\\
{\tt~~}\EXP{\KWD{throws} \{\,\TYP{IndexOutOfBounds}, \TYP{IntegerOverflow}\,\}}}
\Method*{\EXP{\VAR{unsignedIndex}()\COLON \TYP{IndexInt}}\\
{\tt~~}\EXP{\KWD{throws} \{\,\TYP{IntegerOverflow}\,\}}}
\Method*{\EXP{\VAR{unsignedIndex}(\VAR{selfStart}\COLON \TYP{IndexInt}, \VAR{length}\COLON \TYP{IndexInt})\COLON \TYP{IndexInt}}\\
{\tt~~}\EXP{\KWD{throws} \{\,\TYP{IndexOutOfBounds}, \TYP{IntegerOverflow}\,\}}}

[Description to be supplied.]


%% BinaryEndianLinearEndianSequence[\nat b, bool bigEndianBytes, bool bigEndianBits,nat n,bool bigEndianSequence\]
%% is a linear sequence of words of type BinaryEndianWord[\b,bigEndianBytes,bigEndianBits\].
%% This is good because you can declare the endianness information once for the
%% sequence of words, and then when you index into it to get a word, it already has
%% the right endianness; you don't have to say .littleEndian or .bigEndian before
%% splitting or bit extraction.  If bigEndianSequence is true, then lower-indexed
%% words are at higher memory addresses (that is, the array is laid out "backwards"
%% in memory---this may seem stupid, but you need it to properly represent bit
%% fields extracted from a big-endian word).  A BinaryLinearEndianSequence can also
%% be subjected to a split operation that specifies a smaller word size b'; the
%% result is a sequence of n 2^(b-b') words of size 2^b' bits.  The flag
%% bigEndianBytes controls how the new smaller words are mapped onto the old larger
%% words.

%% BinaryHeapEndianSequence[\nat b, bool bigEndianBytes, bool bigEndianBits\]
%% is a heap sequence of words of type BinaryEndianWord[\b,bigEndianBytes,bigEndianBits\].

%% All sensible type conversions basically work (details to be provided).  You can
%% concatenate a mixture of binary words and binary sequences as long as their b
%% parameters match and their endianness (or lack thereof) matches.  Note that
%% concatenation of bits and bit fields is a special case of this, and in addition
%% allows use of literals of radix 2, 4, 8, or 16.  (To make this work, we have to
%% assume that literals have detailed types that reveal their radix *and* the
%% number of digits.)  Here is an example of making a new 64-bit IEEE double float
%% by taking the sign bit of one float, the significand of another, and smashing in
%% a constant exponent field expressed as a binary literal, all using SPARC
%% endianness conventions:

%%   (* SPARC uses big-endian byte order but little-endian bit numbering! *)
%%   type BinaryLinearSPARCSequence[\b,n\] = BinaryLinearEndianSequence[\b,true,false,n,false\]

%%   data: BinaryLinearSPARCSequence[\20,6\] = ...

%%   first = data[3]
%%   second = data[7]
%%   result = first[63] || 01111111111_2 || second[51:0]

%% Here is how we might encode the fields of the first five words of an IP packet
%% header represented using SPARC bit numbering:

%% object IPHeader(data:BinaryLinearSPARCSequence[\5,5\])
%%   getter version()              = data[0][31:28]
%%   getter internetHeaderLength() = data[0][27:24]
%%   getter typeOfService()        = data[0][23:16]
%%   getter totalLength()          = data[0][15:0]
%%   getter identification()       = data[1][31:16]
%%   setter identification(v:BinaryWord[\4\]) = data.update(1,31:16,v)
%%   getter flags()                = data[1][15:11]
%%   getter fragmentOffset()       = data[1][10:0]
%%   getter timeToLive()           = data[2].split[\3\][0]
%%   getter protocol()             = data[2].split[\3\][1]
%%   getter headerChecksum()       = data[2].split[\3\][2:3]
%%   getter sourceIPaddress()      = data[3]
%%   setter sourceIPaddress(v:BinaryWord[\5\]) = data.update(3,v)
%%   getter destinationIPaddress() = data[4]
%% end

%% For fun, I specified the elements of the third word in a slightly strange way:
%% by splitting the (big-endian) word into bytes and then referring to the bytes by
%% their big-endian index within the word, rather than referring to the word itself
%% and then selecting bits using (SPARC little-endian) bit numbering.  I also
%% specified setters for three of the fields.  (Maybe we ought to work out a way
%% not to have to specify the setters separately.)


%% (*********************************************************************************)

%% api fortress.machineDependentParameters

%% maxMultiplyBitLog = 6
%% maxDivideBitLog = 6
%% indexIntBitLog = 6
%% maxBinaryWordBitLog = 30

%% end

%% (*********************************************************************************)

%% api fortress.lowLevelData

%% import { maxMultiplyBitLog, maxDivideBitLog } from fortress.machineDependentParameters
%% import { RangeOfStaticSize } from fortress.ranges
