/*******************************************************************************
 Copyright 2008,2009, Oracle and/or its affiliates.
 All rights reserved.


 Use is subject to license terms.

 This distribution may include materials developed by third parties.

 ******************************************************************************/

package com.sun.fortress.parser_util.instrumentation;

import java.io.File;
import java.io.FileFilter;
import java.io.PrintWriter;
import java.io.StringWriter;
import java.lang.reflect.Field;
import java.util.*;

/*
 * Parser coverage command-line tool
 *
 * usage: java com.sun.parser_util.instrumentation.Coverage
 *   (no arguments)
 *
 * The coverage tool runs the instrumented parser (c.s.f.parser.FortressInstrumented,
 * generated by InstrumentedParserGenerator) on the test files in TEST_DIRS ("tests"
 * and "static_tests"), excluding the ones expected to raise a parse error ("XXX*.fs[is]").
 * These files constitute the sample corpus. It reports coverage of the Fortress grammar
 * based on all of the test files together.
 *
 * The report currently consists of two parts: a summary and a detailed analysis of
 * alternates.
 *
 * Example summary line:
 *   74% alternate coverage in com.sun.fortress.parser.Type (attempted  97%)
 *
 * Of all of the alternates belonging to all of the nonterminals in module Type,
 * the parser started to try 97% of the alternates, but only 74% of them had
 * committed parses. The other 23% contains alternates that failed to parse and
 * also alternates that successfully parsed but were reverted because they were on
 * a branch that failed later.
 *
 * Example detailed section:
 *   Module com.sun.fortress.parser.Symbol
 *     EncloserPair case 1/1 (no name) was never tried
 *     ExponentOp case 1/1 (no name) never succeeded
 *     bar case 1/1 (no name) had successful parses reverted
 *     closingComprehension case 1/4 (no name) had successful parses reverted
 *     closingComprehension case 2/4 (no name) had successful parses reverted
 *     closingComprehension case 3/4 (no name) was never tried
 *     closingComprehension case 4/4 (no name) was never tried
 *     ...
 *
 * The EncloserPair nonterminal's single alternate was never tried.
 * The ExponentOp nonterminals' single alternate was tried, but always failed.
 * The bar nonterminal's single alternate was tried and successfully parsed, but
 * only on a failed branch; it had no surviving successful parses.
 * The closingComprehension nonterminal has four cases, and the coverage tool
 * reports them separately.
 */

public class Coverage {

    static final String PARSER_CLASS = InstrumentedParserGenerator.INSTR_PARSER;

    private static final boolean EXCLUDE_SLOW_FILES = false;

    static final List<String> TEST_DIRS = new LinkedList<String>();

    static {
        TEST_DIRS.add("tests");
        TEST_DIRS.add("static_tests");
        TEST_DIRS.add("parser_tests");
        TEST_DIRS.add("not_passing_yet");
        if (!EXCLUDE_SLOW_FILES) TEST_DIRS.add("../Library");
    }

    private static final boolean RETHROW_PROGRAM_ERRORS = false;
    private static final boolean INCLUDE_OK_ALTERNATES = false;
    private static final boolean SHOW_FREQUENCIES = true;
    private static final boolean SIMPLIFIED_REPORT = true;
    private static final boolean VERBOSE = false;

    private static final boolean SHOW_COVERAGE = true;
    private static final boolean SHOW_MEMO = true;
    private static final boolean SHOW_TRANSIENT_LIST = true;

    static class AnalyzingParser extends Parser {

        AnalyzingParser(String parserClass) {
            super(parserClass);
        }

        public Map<String, Integer> hits = new HashMap<String, Integer>();
        public Map<String, Integer> misses = new HashMap<String, Integer>();
        public Map<String, Long> missLocalCost = new HashMap<String, Long>();
        public Map<String, Long> missCost = new HashMap<String, Long>();
        public Map<String, String> names = new HashMap<String, String>();
        public boolean memoInfoFound = false;

        void analyzeMemoRates() {
            try {
                Field[] fields = this.parserClass.getDeclaredFields();
                for (Field field : fields) {
                    String fieldName = field.getName();
                    if (fieldName.endsWith("MemoMisses")) {
                        String name = fieldName.substring(0, fieldName.length() - "MemoMisses".length());
                        misses.put(name, (Integer) field.get(null));
                        this.memoInfoFound = true;
                    } else if (field.getName().endsWith("MemoHits")) {
                        String name = fieldName.substring(0, fieldName.length() - "MemoHits".length());
                        hits.put(name, (Integer) field.get(null));
                        this.memoInfoFound = true;
                    } else if (field.getName().endsWith("MissCost")) {
                        String name = fieldName.substring(0, fieldName.length() - "MissCost".length());
                        missCost.put(name, (Long) field.get(null));
                        this.memoInfoFound = true;
                    } else if (field.getName().endsWith("MissLocalCost")) {
                        String name = fieldName.substring(0, fieldName.length() - "MissLocalCost".length());
                        missLocalCost.put(name, (Long) field.get(null));
                        this.memoInfoFound = true;
                    } else if (field.getName().endsWith("NTName")) {
                        String name = fieldName.substring(0, fieldName.length() - "NTName".length());
                        names.put(name, (String) field.get(null));
                        this.memoInfoFound = true;
                    }
                }
            }
            catch (Exception e) {
                throw new RuntimeException(e);
            }
        }
    }

    public static void main(String[] args) {
        if (args.length > 1) {
            System.err.println("Warning: Ignoring command-line arguments!");
        }
        AnalyzingParser parser = new AnalyzingParser(PARSER_CLASS);
        parseFiles(parser);
        reportCoverage(parser);
    }

    private static void parseFiles(Parser parser) {
        for (String dir : TEST_DIRS) {
            File f = new File(dir);
            File[] srcfiles = f.listFiles(new FileFilter() {
                public boolean accept(File sf) {
                    return (sf.getName().endsWith(".fsi") || sf.getName().endsWith(".fss"));
                }
            });
            System.out.println("Loading " + srcfiles.length + " test files from " + dir);
            for (File srcfile : srcfiles) {
                parseFile(parser, srcfile);
            }
        }
        System.out.println();
    }

    private static void parseFile(Parser parser, File file) {
        String filename = file.getAbsolutePath();
        if (VERBOSE) System.out.println("Parsing " + filename + " ...");

        if (EXCLUDE_SLOW_FILES) {
            // FIXME: temp blacklist
            if (file.getName().endsWith("taskTrace2.fss")) return;
        }

        try {
            parser.parse(file);
        }
        catch (RuntimeException re) {
            String parent = file.getParent();
            int size = parent.length();
            if (size < 12 || !(parent.substring(size - 12, size).equals("parser_tests"))) System.out.println(
                    "Parse error in file: " + filename);
            if (RETHROW_PROGRAM_ERRORS) {
                throw re;
            }
        }
    }

    private static void reportCoverage(AnalyzingParser parser) {
        System.out.println("** Time");
        System.out.println("  Parse time: " + parser.parseTime + " ms");
        System.out.println();

        Collection<Info.ModuleInfo> rawModuleInfos = parser.info();
        if (rawModuleInfos == null) {
            System.out.println("** Coverage");
            System.out.println("No coverage info available. Are you using an instrumented parser?");
        } else {
            List<Info.ModuleInfo> moduleInfos;
            moduleInfos = new LinkedList<Info.ModuleInfo>(rawModuleInfos);
            Collections.sort(moduleInfos, new Comparator<Info.ModuleInfo>() {
                public int compare(Info.ModuleInfo a, Info.ModuleInfo b) {
                    return a.module.compareTo(b.module);
                }
            });
            if (SHOW_COVERAGE) {
                System.out.println("** Coverage summary: Alternate coverage by module");
                for (Info.ModuleInfo moduleInfo : moduleInfos) {
                    printStats(moduleInfo);
                }
                System.out.println();
                System.out.println("** Coverage details");
                for (Info.ModuleInfo moduleInfo : moduleInfos) {
                    printUnused(moduleInfo);
                }
                System.out.println();
            }
        }
        if (SHOW_MEMO) {
            System.out.println("** Memoization details");
            printMemoRates(parser);
        }
    }

    private static void printStats(Info.ModuleInfo m) {
        int all = 0;
        int started = 0;
        int ended = 0;
        int committed = 0;
        for (Info.ProductionInfo p : m.productions) {
            for (Info.SequenceInfo s : p.sequences) {
                all++;
                if (s.startedCount > 0) started++;
                if (s.endedCount > 0) ended++;
                if (s.committedCount > 0) committed++;
            }
        }

        double start_coverage = ((double) started) / ((double) all) * 100.0;
        double comit_coverage = ((double) committed) / ((double) all) * 100.0;

        System.out.println(String.format("%3d%% alternate coverage in %s (attempted %3d%%)",
                                         (int) comit_coverage,
                                         m.module,
                                         (int) start_coverage));
    }

    private static void printDetails(Info.ModuleInfo m) {
        int m_all = 0;
        int m_started = 0;
        int m_ended = 0;
        int m_committed = 0;
        StringWriter string_out = new StringWriter();
        PrintWriter out = new PrintWriter(string_out);
        for (Info.ProductionInfo p : m.productions) {
            int p_all = 0;
            int p_started = 0;
            int p_ended = 0;
            int p_committed = 0;
            for (Info.SequenceInfo s : p.sequences) {
                p_all++;
                if (s.startedCount > 0) p_started++;
                if (s.endedCount > 0) p_ended++;
                if (s.committedCount > 0) p_committed++;
            }
            out.println("  Production " + p.production);
            //out.println(coverage(2, "started", p_started, p_all));
            //out.println(coverage(2, "ended", p_ended, p_all));
            out.println(coverage(2, "committed", p_committed, p_all));

            m_all++;
            if (p_started > 0) m_started++;
            if (p_ended > 0) m_ended++;
            if (p_committed > 0) m_committed++;
        }
        System.out.println("Module " + m.module);
        //System.out.println(coverage(0,"started", m_started, m_all));
        //System.out.println(coverage(0,"ended", m_ended, m_all));
        System.out.println(coverage(0, "committed", m_committed, m_all));
        System.out.println(string_out.toString());
    }

    /* We don't check the grammar coverage for error productions and
       the following two modules:
           com.sun.fortress.parser.Unicode
           com.sun.fortress.parser.Syntax
     */
    private static void printUnused(Info.ModuleInfo m) {
        if (SIMPLIFIED_REPORT && (m.module.equals("com.sun.fortress.parser.Unicode") || m.module.equals(
                "com.sun.fortress.parser.Syntax"))) return;
        System.out.println("Module " + m.module);
        for (Info.ProductionInfo p : m.productions) {
            int sequenceCount = p.sequences.size();
            for (Info.SequenceInfo s : p.sequences) {
                if (s.committedCount == 0 || INCLUDE_OK_ALTERNATES) {
                    String name = s.sequence == null ? "no name" : s.sequence;
                    int size = name.length();
                    boolean print = true;
                    if (SIMPLIFIED_REPORT) {
                        if (size >= 15 && name.substring(0, 15).equals("ErrorProduction")) print = false;
                    }
                    if (print) {
                        System.out.print(String.format("    %s case %d/%d (%s)",
                                                       p.production,
                                                       s.sequenceIndex,
                                                       sequenceCount,
                                                       name));
                        if (s.startedCount == 0) {
                            System.out.print(" was never tried");
                        } else if (s.endedCount == 0) {
                            System.out.print(" never succeeded");
                        } else if (s.committedCount == 0) {
                            System.out.print(" had successful parses reverted");
                        } else {
                            System.out.print(" succeeded");
                        }
                        if (SHOW_FREQUENCIES) {
                            System.out.print(frequency(s));
                        }
                        System.out.println();
                    }
                }
            }
        }
    }

    private static void printMemoRates(AnalyzingParser p) {
        p.analyzeMemoRates();

        if (!p.memoInfoFound) {
            System.out.println("  No memoization info found!");
            System.out.println("  Are you using the modified Rats! parser generator?");
            return;
        }

        List<String> transientList = new ArrayList<String>();
        for (String key : new TreeSet<String>(p.hits.keySet())) {
            int hitCount = p.hits.get(key);
            int missCount = p.misses.get(key);
            long missCost = p.missCost.get(key);
            long missLocalCost = p.missLocalCost.get(key);
            String name = p.names.get(key);
            name = (name != null) ? name : ("f = " + key);
            System.out.print(coverage(0, name, hitCount, hitCount + missCount));
            if (missCount > 0) {
                double avgMissCost = ((float) missCost) / (missCount * 1.0e6);
                System.out.print(String.format("; avg miss cost %.3f ms", avgMissCost));
            }
            if (lowCacheBenefit(hitCount, missCount, missCost)) {
                transientList.add(name);
            }
            System.out.println();
        }
        System.out.println();

        if (SHOW_TRANSIENT_LIST) {
            System.out.println("** Transient List Recommendation");
            for (String name : transientList) {
                System.out.println(name);
            }
            System.out.println();
        }
    }

    private static boolean lowCacheBenefit(int hits, int misses, long cost) {
        int total = hits + misses;
        if (total == 0) {
            return true;
        } else {
            float ratio = ((float) hits) / ((float) total);
            double avgCost = ((double) cost) / ((double) misses * 1.0e6);
            return ratio < 0.10 || avgCost < 0.10;
        }
    }

    private static String frequency(Info.SequenceInfo s) {
        return String.format(" [%d-%d-%d]", s.startedCount, s.endedCount, s.committedCount);
    }

    private static String coverage(int indent, String label, int covered, int total) {
        double percentage = (100.0 * covered) / (double) total;
        char[] indentation = new char[indent];
        Arrays.fill(indentation, ' ');
        return String.format("%s-- %s %3d%% (%d/%d)", new String(indentation), label, (int) percentage, covered, total);
    }
}
